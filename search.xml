<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速绘制UML图</title>
      <link href="/2019/10/01/quick-start-of-uml/"/>
      <url>/2019/10/01/quick-start-of-uml/</url>
      
        <content type="html"><![CDATA[<p>之前介绍了一些<a href="https://zachaxy.github.io/2018/04/20/uml%E5%9B%BE%E5%9F%BA%E7%A1%80/">UML图基础</a>的概念,这次推荐一个快速绘制UML图的工具</p><a id="more"></a><h1 id="绘制工具"><a href="#绘制工具" class="headerlink" title="绘制工具"></a>绘制工具</h1><p>在经历了一番折腾后,最终还是选择了 <a href="http://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a>,原因是看重其使用特有的语言书写接口,类,并自动生成UML. 同时,自己也在使用 VSCode ,发现 PlantUML 在 VSCode 上提供了插件,于是直接在 VSCode 上安装了 PlantUML的插件.<br>同时,要实时预览,还要安装 <code>graphviz</code>, 如果是 Mac,那么直接使用 homebrew 安装即可: <code>brew install graphviz</code>, 安装完成很后,使用 <code>dot -v</code> 查看是否安装成功</p><p>在 VSCode 中,使用 <code>alt</code> + <code>d</code> 进行实时预览</p><h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><ul><li>接口声明: interface 接口名</li><li>抽象类声明: abstract class 类名</li><li>类声明: class 类名</li><li>注解类声明: annotation 注解名</li><li>枚举类声明: enum 枚举类名</li></ul><h2 id="属性-方法修饰符"><a href="#属性-方法修饰符" class="headerlink" title="属性/方法修饰符"></a>属性/方法修饰符</h2><table><thead><tr><th align="center">关系</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">+</td></tr><tr><td align="center">protected</td><td align="center">#</td></tr><tr><td align="center">default</td><td align="center">~</td></tr><tr><td align="center">private</td><td align="center">-</td></tr></tbody></table><h2 id="PlantUML用下面的符号来表示类之间的关系"><a href="#PlantUML用下面的符号来表示类之间的关系" class="headerlink" title="PlantUML用下面的符号来表示类之间的关系:"></a>PlantUML用下面的符号来表示类之间的关系:</h2><table><thead><tr><th align="center">关系</th><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">实现</td><td align="center">`&lt;</td><td align="center">..`</td></tr><tr><td align="center">泛化</td><td align="center">`&lt;</td><td align="center">–-`</td></tr><tr><td align="center">依赖</td><td align="center"><code>&lt;..</code></td><td align="center">Dependency, 带箭头的虚线表示</td></tr><tr><td align="center">组合</td><td align="center"><code>*–-</code></td><td align="center">Composition, 带实心的菱形的直线表示</td></tr><tr><td align="center">聚合</td><td align="center"><code>o–-</code></td><td align="center">Aggregation, 带空心菱形的直线表示</td></tr><tr><td align="center">关联</td><td align="center"><code>&lt;–</code></td><td align="center">Association</td></tr><tr><td align="center">单向关联</td><td align="center"><code>&lt;--</code></td><td align="center">Association,带箭头的实线表示</td></tr><tr><td align="center">双向关联</td><td align="center"><code>--</code></td><td align="center">直线表示</td></tr><tr><td align="center">多重性关联</td><td align="center"><code>“1..*”&lt;--&quot;0..*&quot;</code></td><td align="center">关联直线上用一个数字或者一个数字的范围表示</td></tr></tbody></table><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">interface IUser</span><br><span class="line"></span><br><span class="line">abstract class BaseUser</span><br><span class="line">class User</span><br><span class="line">class ShadowUser</span><br><span class="line"></span><br><span class="line">IUser &lt;|.. BaseUser</span><br><span class="line">IUser &lt;|.. ShadowUser</span><br><span class="line">BaseUser &lt;|-- User</span><br><span class="line"></span><br><span class="line">interface IUserCenter &#123;</span><br><span class="line">    + IUser getCurrentUser()</span><br><span class="line">    + boolean isLogin()</span><br><span class="line">    + void queryUserProfile(int uid, string sid)</span><br><span class="line">    + void search(int uid, string sid)</span><br><span class="line">    + IUpdater updater(int uid, string sid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UserCenter &#123;</span><br><span class="line">    - HostUserManager</span><br><span class="line">    - GuestUserManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IUserCenter &lt;|.. UserCenter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IUserManager &#123;</span><br><span class="line">    void getUser(int uid, string sid)</span><br><span class="line">    void getProfile(int uid, string sid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HostUserManager &#123;</span><br><span class="line">    - HostUserCache</span><br><span class="line">    - HostUpdater</span><br><span class="line">&#125;</span><br><span class="line">class GuestUserManager &#123;</span><br><span class="line">    - GuestUserCache</span><br><span class="line">    - GuestUpdater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IUserManager &lt;|..HostUserManager</span><br><span class="line">IUserManager &lt;|..GuestUserManager</span><br><span class="line"></span><br><span class="line">interface IUserCache &#123;</span><br><span class="line">    + void cacheUser(IUser user)</span><br><span class="line">    + void deleteUser(int uid)</span><br><span class="line">    + boolean hasUser(int uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HostUserCache &#123;</span><br><span class="line">    - SharedPreference sp</span><br><span class="line">&#125;</span><br><span class="line">class GuestUserCache &#123;</span><br><span class="line">    - HashMap cache</span><br><span class="line">&#125;</span><br><span class="line">IUserCache &lt;|..HostUserCache</span><br><span class="line">IUserCache &lt;|..GuestUserCache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IUpdater &#123;</span><br><span class="line">    + void setXXX(var xxx)</span><br><span class="line">    + void update()</span><br><span class="line">&#125;</span><br><span class="line">class HostUpdater</span><br><span class="line">class GuestUpdater</span><br><span class="line">IUpdater &lt;|..HostUpdater</span><br><span class="line">IUpdater &lt;|..GuestUpdater</span><br><span class="line"></span><br><span class="line">note top of IUpdater:主态update方法之后,需要拉取下User,客态update方法之后,直接设置回UserCache即可</span><br><span class="line"></span><br><span class="line">UserCenter &lt;-- HostUserManager</span><br><span class="line">UserCenter &lt;-- GuestUserManager</span><br><span class="line"></span><br><span class="line">HostUserManager &lt;-- HostUserCache</span><br><span class="line">HostUserManager &lt;-- HostUpdater</span><br><span class="line"></span><br><span class="line">GuestUserManager &lt;-- GuestUserCache</span><br><span class="line">GuestUserManager &lt;-- GuestUpdater</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">note as N1 #red</span><br><span class="line">IUserCenter 作为User相关操作对外暴露的唯一对象</span><br><span class="line">UserCache,UserManager 均为内部实现</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ul><li><a href="http://plantuml.com/zh/object-diagram" target="_blank" rel="noopener">对象图</a><ul><li><a href="https://blog.csdn.net/qq_26819733/article/details/84895850" target="_blank" rel="noopener">用VS Code画uml</a></li><li><a href="https://blog.csdn.net/zxc123e/article/details/71837923" target="_blank" rel="noopener">使用PlantUML快速绘图</a></li><li><a href="https://www.youtube.com/watch?v=UI6lqHOVHic" target="_blank" rel="noopener">UML Class Diagram Tutorial</a></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机的启动流程</title>
      <link href="/2019/09/15/the-progress-of-boot/"/>
      <url>/2019/09/15/the-progress-of-boot/</url>
      
        <content type="html"><![CDATA[<p>按下主机的电源键，伴随着屏幕上一闪而过的打印信息,片刻之后计算机就启动了,如果我们安装了多个系统，计算机会让我们选择一个系统来启动。。。这些过程中，计算机的内部都经历了什么？<br>接下来的内容将对计算机的启动有一个简单的介绍。</p><a id="more"></a><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>市面上的个人计算机一般都搭载了各自的操作系统，eg：windows，macOS，Ubuntu等，这些操作系统的代码在计算机的硬盘或者U盘中，是不能自启动的，需要一个引导启动的程序来将它们加载到内存中，那么这个加载的过程就是计算机启动的流程。</p><ul><li>强硬件相关的：由烧写在硬件电路中的程序负责执行引导流程</li><li>操作系统无关的：不论安装什么类型的操作系统，都要遵守引导程序的规则，否则无法被载入到内存中。</li></ul><p>计算机的整个启动过程分成四个阶段：</p><ol><li>BIOS启动</li><li>主引导记录</li><li>硬盘启动</li><li>操作系统启动</li></ol><h1 id="BIOS启动"><a href="#BIOS启动" class="headerlink" title="BIOS启动"></a>BIOS启动</h1><p>上个世纪70年代初，”只读内存”（read-only memory，缩写为ROM）问世，开机引导程序被写入ROM中，在计算机通电后，第一件事就是读取并执行这段程序。该过程有硬件厂商来实现。这段程序有一个名字叫 BIOS（Basic Input/Output System）。其主要流程如下：</p><h2 id="1-硬件自检"><a href="#1-硬件自检" class="headerlink" title="1. 硬件自检"></a>1. 硬件自检</h2><p>BIOS程序首先检查计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p><p><img src="https://raw.githubusercontent.com/zachaxy/zachaxy.github.io/hexo/images/bg2013021503.png" alt="boot info"></p><h2 id="2-确定启动顺序"><a href="#2-确定启动顺序" class="headerlink" title="2. 确定启动顺序"></a>2. 确定启动顺序</h2><p>经过上一步的硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪里。<br>如果你自己安装过系统，那么对这个一定不陌生。系统的启动并不一定是硬盘，也可能是U盘或者软盘，这一步的设置可以在BIOS中进行设定</p><p><img src="https://raw.githubusercontent.com/zachaxy/zachaxy.github.io/hexo/images/1282003915_iQipOt.jpg" alt="boot sequence"></p><p>BIOS会根据外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p><h1 id="主引导记录"><a href="#主引导记录" class="headerlink" title="主引导记录"></a>主引导记录</h1><p>BIOS按照”启动顺序”，把控制权转交给合适的储存设备。注意，这里并不是在启动顺序中排在首位，就一定从该设备启动的，因为要想真正的启动设备，该设备必须符合规范，计算机会读取该设备最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p><p>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。实现一个操作系统，必须要满足最后两个字节是0x55和0xAA即可，前面的510个字节，只要能正确将操作系统引导到内存即可。但是现代操作系统如果要实现更好的系统启动管理，没有一定的规范是不可能的。下面介绍下主引导记录的结构，并了解分区表的基本概念，但是依然要提醒，这并非必须的！</p><h2 id="1-主引导记录的结构"><a href="#1-主引导记录的结构" class="headerlink" title="1 主引导记录的结构"></a>1 主引导记录的结构</h2><p>“主引导记录”只有512个字节，是不可能放下整个操作系统的。其主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p><p>主引导记录由三个部分组成：</p><ol><li>第1-446字节：调用操作系统的机器码。</li><li>第447-510字节：分区表（Partition table）。</li><li>第511-512字节：主引导记录签名（0x55和0xAA）。</li></ol><p>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p><h2 id="2-分区表"><a href="#2-分区表" class="headerlink" title="2 分区表"></a>2 分区表</h2><p>在使用Windows时，我们的硬盘一般会划分C/D/E/F盘，操作系统一般会放在C盘（当然，这个并不是必须的，而是可以设置的），针对这种情况，”主引导记录” 就必须知道将控制权转交给哪个区，也就是说要具体从哪个盘启动操作系统。</p><p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p><p>每个主分区的16个字节，由6个部分组成：</p><ol><li>第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li><li>第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li><li>第5个字节：主分区类型。</li><li>第6-8个字节：主分区最后一个扇区的物理位置。</li><li>第9-12字节：该主分区第一个扇区的逻辑地址。</li><li>第13-16字节：主分区的扇区总数。</li></ol><p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p><p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p><h1 id="硬盘启动"><a href="#硬盘启动" class="headerlink" title="硬盘启动"></a>硬盘启动</h1><p>这里以最常见的硬盘启动为例，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p><h2 id="1-卷引导记录"><a href="#1-卷引导记录" class="headerlink" title="1 卷引导记录"></a>1 卷引导记录</h2><p>这种方式也是最常见的一种方式，计算机上只安装的一个操作系统，根据前面提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。<br>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p><h2 id="2-扩展分区和逻辑分区"><a href="#2-扩展分区和逻辑分区" class="headerlink" title="2 扩展分区和逻辑分区"></a>2 扩展分区和逻辑分区</h2><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。<br>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。一般这种情况是安装了双系统的情况，eg：我们在c盘安装了windows系统，同时又分出一个单独的盘用来安装Ubuntu。</p><p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。<br>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p><p>但是，似乎很少通过这种方式启动操作系统，因为这种方式的安装较为复杂，同时无法给用户提供选择进入哪个系统，仅仅是作为了解，因为如果操作系统确实安装在扩展分区，一般采用下面Grub的方式启动。</p><h2 id="3-启动管理器"><a href="#3-启动管理器" class="headerlink" title="3 启动管理器"></a>3 启动管理器</h2><p>安装双系统，这种情况最为常见的，如果你之前在window上安装过ubuntu的双系统，那么对Easybcd 这个软件应该不陌生，这个软件就是修改主引导记录的前512字节里面的代码，这时计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。Linux环境中，目前最流行的启动管理器是Grub。在计算机启动的时候，会出现一个菜单供你选择启动哪个系统。</p><p><img src="https://raw.githubusercontent.com/zachaxy/zachaxy.github.io/hexo/images/201701343941760.png" alt="boot select"></p><h1 id="操作系统启动"><a href="#操作系统启动" class="headerlink" title="操作系统启动"></a>操作系统启动</h1><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p><p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件 /etc/initab，产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p><p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>计算机的启动，本质上就是要把操作系统加载到内存中，一旦操作系统加载到内存中，接下来就开始执行操作系统内部的逻辑了。<br>但是要实现这一功能，就必须引入一个引导程序，通过硬件上电后立即执行（BIOS），先检测当前硬件环境是否正常，历史原因，随着硬件的逐步发展，软盘，硬盘，U盘等存储介质的出现，BIOS也要兼容市面上的几种引导介质，接下来开始从设置好的启动顺序中逐个判断该设备是否可以引导操作系统。一旦确定了设备，接下来就要确定操作系统在目标引导设备上的具体位置，根据一层层的缩小范围，最终将操作系统加载到内存中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理解计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl 使用指南</title>
      <link href="/2019/09/07/how-to-use-curl/"/>
      <url>/2019/09/07/how-to-use-curl/</url>
      
        <content type="html"><![CDATA[<p>curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。它支持多种协议，下面将介绍 curl 的简单使用</p><a id="more"></a><h1 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h1><pre><code>curl https://github.com/</code></pre><p>curl 后面直接跟一个url，那么将会返回该网站的response。</p><h1 id="查看具体的相应"><a href="#查看具体的相应" class="headerlink" title="查看具体的相应"></a>查看具体的相应</h1><ul><li><code>-i</code> 参数可以显示http response的头信息，连同网页代码一起。</li><li><code>-I</code> 参数则是只显示http response的头信息。</li><li><code>-v</code> 参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</li></ul><p>如果 <code>-v</code> 参数还不够详细，可以使用 <code>--trace</code> 将相应保存在文件中查看</p><pre><code>curl --trace output.txt https://github.com/curl --trace-ascii output.txt https://github.com/</code></pre><h1 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h1><p>上述只是查看一个响应，接下来我们通过添加参数的方式，去构造一个请求，并获取相应。</p><p>curl 默认的 HTTP 方法是 GET，使用<code>-X</code>参数可以支持其他方法。</p><h2 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h2><p>如果要对 GET 请求添加参数只要在 url 后面拼接参数就可以了，这里要注意的是如果参数需要编码，必须显示的指明<br>    curl -G –data-urlencode “key1=value1” –data-urlencode “key2=value2” <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>其中 <code>-G</code> 表明将接下来的参数拼接到url 后面， 而 <code>--data-urlencode</code> 表明需要对后面的 k-v 进行编码，每添加一个k-v 对，都需要显示指明编码</p><h2 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h2><p>使用 <code>-X</code> 后面指定方法，</p><pre><code>curl -X POST --data &quot;key1=value1&quot; --data-urlencode &quot;key2=value2&quot; https://github.com/</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>假定文件上传的表单是下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">'multipart/form-data'</span> <span class="attr">action</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">upload</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">press</span> <span class="attr">value</span>=<span class="string">"OK"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么文件上传的命令为：</p><pre><code>curl --form upload=@localfilename --form press=OK  https://github.com/</code></pre><h2 id="auth-认证"><a href="#auth-认证" class="headerlink" title="auth 认证"></a>auth 认证</h2><p>有些网域需要HTTP认证，这时curl需要用到<code>-u</code>参数。</p><pre><code>curl -i -u your_username https://api.github.com/users/defunktEnter host password for user your_username:</code></pre><h2 id="添加头信息"><a href="#添加头信息" class="headerlink" title="添加头信息"></a>添加头信息</h2><p>有时需要在http request之中，自行增加一个头信息。<code>-H</code> 或者 <code>--header</code>参数就可以起到这个作用。</p><pre><code>curl -H &quot;Content-Type:application/json&quot; https://github.com/</code></pre><h2 id="添加-User-Agent字段"><a href="#添加-User-Agent字段" class="headerlink" title="添加 User Agent字段"></a>添加 User Agent字段</h2><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p><p>iPhone4的User Agent是</p><p>　　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</p><p>curl可以这样模拟：</p><pre><code>curl --user-agent &quot;your agent&quot; https://github.com/</code></pre><h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><pre><code>curl -help</code></pre><p>一切尽在说明中～</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程的理解(Java语言)</title>
      <link href="/2019/09/07/introduce-Java8-lambda/"/>
      <url>/2019/09/07/introduce-Java8-lambda/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">view.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am clicked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">view.setOnClickListener(v -&gt; System.out.println(<span class="string">"I am clicked"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line">view.setOnClickListener(<span class="keyword">this</span>::onViewClick);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onViewClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"I am clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方式最终都是为view 设置了点击的监听,最终效果都是一样的, 但是哪种方式更好呢?</p><a id="more"></a><h1 id="几个基本的概念"><a href="#几个基本的概念" class="headerlink" title="几个基本的概念"></a>几个基本的概念</h1><ul><li><p>函数式接口(Functional Interface): 有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p></li><li><p>函数式编程(functional programming),也称函数程序设计，或者泛函编程: 是一种编程典范，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。其实,函数式并非是 Java8 首创的概念,其本身是范畴论（Category Theory）的数学分支,用来解决数学问题的,后来有人将这种方法论运用在了编程上,所以才形成了函数式编程</p></li><li><p>函数编程语言最重要的基础是λ演算(lambda calculus)。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p></li><li><p>Lambda表达式: Lambda允许把函数作为一个方法的参数(函数作为参数传递进方法中)</p></li><li><p>方法引用: lambda表达式的一种特殊形式，如果正好有某个方法满足一个lambda表达式的形式，那就可以将这个lambda表达式用方法引用的方式表示，但是如果这个lambda表达式的比较复杂就不能用方法引用进行替换。实际上方法引用是lambda表达式的一种语法糖。</p></li></ul><hr><p>上述几个概念似乎没有什么关联,那么我们再次回到文章开头给出的三种实现方式. 第一种方式是最常见的一种方式,view 的 setOnClickListener 方法要传入一个接口, 我们一般都是直接在参数传入的地方,传入一个匿名内部类,但是这样使得代码的整体结构变得略微有些复杂,并且不够直观,那么有没有一种更简洁的写法呢? 于是 Java8 便退出了更为简洁的lambda 表达式,一行代码就可以替代之前臃肿的结构.</p><p>但是,并非所有参数是接口的方法,都可以用 lambda 表达式来替代,这个接口有一个特殊的限定—有且仅包含一个抽象方法的接口(函数式接口). Java8 并没有在之前的基础上提供额外的语法来创建函数式接口,而是在原有接口的范畴内,进行限定.这样就可以在参数为函数式接口的方法中,使用 lambda 来表达.</p><p>透过开篇的示例代码,我们发现 setOnClickListener 方法要传入一个接口,本质上是在view 接受到点击事件后,要往外抛出一个事件,而接口正是 view 内部点击事件与外部处理点击事件的桥梁,实际上,就是需要一个特定的代码块来处理点击事件,所以lambda表达式就产生了,但是如果我们再进一步分析,似乎我们并没有必要特意去强调实现了该接口,才可以接受回调,只要满足其接口内的方法签名,任意一个方法都可以传入用来处理对应的回调,甚至都不需要满足函数式接口的约束,这就是方法引用产生的背景.</p><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><h1 id="Lambda-简介"><a href="#Lambda-简介" class="headerlink" title="Lambda 简介"></a>Lambda 简介</h1><p>Lambda 表达式，也可称为闭包,其替代的是函数式接口被当做参数传入方法是的一种场景.</p><p>Lambda 表达式的语法格式如下(两种方式):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line"></span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值. 如果使用大括号,则需要指定明表达式返回了一个数值。</li></ul><p>lambda 表达式实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的和</span></span><br><span class="line">(x, y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值</span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p><strong>再次重申</strong>:单纯的定义lambda表达式,没有任何意义, lambda 表达式只有在传入函数式接口为参数的方法被调用时,才可以替代为lambda表达式</p><h1 id="函数式编程的核心思想"><a href="#函数式编程的核心思想" class="headerlink" title="函数式编程的核心思想"></a>函数式编程的核心思想</h1><p>最主要的特征是，函数是第一等公民。强调将计算过程分解成可复用的函数只有引用透明的、没有副作用的函数,才是合格的函数.</p><p>这里有三个特性需要特别说明:</p><ul><li><p>函数是”第一等公民”: 所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，它不仅拥有一切传统函数的使用方式（声明和调用），可以赋值给其他变量（赋值），也可以作为参数，传入另一个函数（传参），或者作为别的函数的返回值（返回）。函数可以作为参数进行传递，意味我们可以把行为”参数化”，处理逻辑可以从外部传入，这样程序就可以设计得更灵活。</p></li><li><p>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。这里强调了一点”输入”不变则”输出”也不变，就像数学函数里面的f(x),只要输入的x一样那得到的结果也肯定定是一样的。</p></li><li><p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p></li></ul><p>根据函数式编程的特性,我们发现函数式编程有以下天然的优势:</p><ol><li><p>代码简洁，开发快速。</p><blockquote><p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。Paul Graham在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。如果程序员每天所写的代码行数基本相同，这就意味着，”C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。”当然，这样的对比故意夸大了差异，但是”在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。” </p></blockquote></li><li><p>接近自然语言，易于理解</p><blockquote><p>函数式编程的自由度很高，可以写出很接近自然语言的代码。这基本就是自然语言的表达了，大家应该一眼就能明白它的意思吧。 </p></blockquote></li><li><p>更方便的代码管理</p><blockquote><p>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。 </p></blockquote></li><li><p>易于”并发编程”</p><blockquote><p>函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。请看下面的代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s1 = f1();</span><br><span class="line">var s2 = f2();</span><br><span class="line">var s3 = concat(f1, f2);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。</p></blockquote><ol start="5"><li>代码的热升级<blockquote><p>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。Erlang语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。</p></blockquote></li></ol><h1 id="best-practice"><a href="#best-practice" class="headerlink" title="best practice"></a>best practice</h1><ol><li><p>Lambda表达式的底层实现</p><blockquote><p>Java8 内部 Lambda 表达式的实现方式在本质是以匿名内部类的形式的实现的,但是注意, <strong>lambda 和 匿名内部类并不是等价的</strong>,这里面有个重要的上下文的概念是不同的,也就是<strong>this</strong>的指代,匿名内部类中的 this 就是其内部类对象,而 lambda 中的 this 指的是外部定义该 lambda 的对象,当然如果是定义在静态方法中的 lambda 是无法使用 this 的</p></blockquote></li><li><p>lambda 中使用变量的作用域</p></li></ol><ul><li>和匿名内部类相似, 不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。 </li><li>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改(即隐性的具有 final 的语义),但是依然强烈建议标记为 final,用来表达更明确的语义</li><li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li></ul><ol start="3"><li>使用 <code>@FunctionalInterface</code> 注解<blockquote><p>如果你确定了某个interface是用于Lambda表达式，请一定要加上@FunctionalInterface，表明你的意图。不然将来说不定某个不知情的同事，在这个interface上面加了另外一个抽像方法时，那么你之前的代码就无法正常运行. 其实 Java8 中已经提供了一些默认的函数式接口供外部使用; 优先使用java.util.function包下面的函数式接口 java.util.function 这个包下面提供了大量的功能性接口，可以满足大多数开发人员为 lambda 表达式和方法引用提供目标类型的需求。每个接口都是通用的和抽象的，使它们易于适应几乎任何lambda表达式。开发人员应该在创建新的功能接口之前研究这个包，避免重复定义接口。另外一点就是，里面的接口不会被别人修改;</p></blockquote></li></ol><table><thead><tr><th>函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="center">用途</th></tr></thead><tbody><tr><td>Consumer<t>(消费型接口)</t></td><td align="center">T</td><td align="center">void</td><td align="center">对类型为T的对象应用操作。void accept(T t)</td></tr><tr><td>Supplier<t>(供给型接口)</t></td><td align="center">无</td><td align="center">T</td><td align="center">返回类型为T的对象。 T get();</td></tr><tr><td>Function&lt;T, R&gt;(函数型接口)</td><td align="center">T</td><td align="center">R</td><td align="center">对类型为T的对象应用操作并返回R类型的对象。R apply(T t);</td></tr><tr><td>Predicate<t>(断言型接口)</t></td><td align="center">T</td><td align="center">boolean</td><td align="center">确定类型为T的对象是否满足约束。boolean test(T t);</td></tr></tbody></table><ol start="4"><li><p>不要在Lambda表达中执行有”副作用”的操作</p><blockquote><p>“副作用”是严重违背函数式编程的设计原则，在工作中我经常看到有人在forEach操作里面操作外面的某个List或者设置某个Map这其实是不对的</p></blockquote></li><li><p>尽量避免在lambda中使用{},也就是说lambda的结构体应该尽量简单,如果内部语句复杂,最好定义一个方法,然后在 lambda 结构体中去引用.</p></li><li><p>相比于lambda,更推荐使用方法引用,虽然两者能起到相同的作用，但两者相比，方法引用通常可读性更高并且代码会简短</p></li></ol><p>方法引用共分为四类:</p><ul><li>类名::静态方法名</li><li>对象::实例方法名</li><li>类名::实例方法名(相比于2,其表达含义更清楚,但是这种方式语义的理解有点绕)</li><li>类名::new</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"aa"</span>, <span class="number">60</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"bb"</span>, <span class="number">70</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">"cc"</span>, <span class="number">80</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">"dd"</span>, <span class="number">90</span>);</span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        students.sort(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        students.sort((o1, o2) -&gt; o1.age - o2.age);</span><br><span class="line"></span><br><span class="line">        students.sort(Main::compare1);</span><br><span class="line"></span><br><span class="line">        students.sort(Student::compare2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare1</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare2</span><span class="params">(Student other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要盲目的开启并行流</p><blockquote><p>Lambda的并行流虽好，但也要注意使用场景。如果平常的业务处理比如过滤，提取数据，没有涉及特别大的数据和耗时操作，则不需要开启并行流。如果一个只有几十个元素的列表的过滤操作也开启了并行流，其实这样做会更慢。因为多行线程的开启和同步这些花费的时间往往比你真实的处理时间要多很多。但一些耗时的操作比如I/O访问，DB查询，远程调用，这些如果可以并行的话，则开启并行流是可提升很大性能的。因为并行流的底层原理是fork/join，如果你的数据分块不是很好切分，也不建议开启并行流。举个例子ArrayList的Stream可以开启并行流，而LinkedList则不建议，因为LinkedList每次做数据切分要遍历整个链表，这本身就已经很浪费性能，而ArrayList则不会</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/linlinismine/p/9283532.html" target="_blank" rel="noopener">聊聊Java 8 Lambda 表达式</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a></li><li><a href="https://segmentfault.com/a/1190000012269548" target="_blank" rel="noopener">Java8-8-方法引用详解</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uml图基础</title>
      <link href="/2018/04/20/uml%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/04/20/uml%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li>类名</li><li>属性名</li><li>方法名</li></ul><blockquote><p>属性或方法前面的符号，<code>+</code> 表示public；<code>-</code> 表示private； <code>#</code> 表示protected; <code>~</code> 表示 default,只有同一个包中的类才能访问<br>静态方法或者静态属性用下划线</p></blockquote><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>同 类 的格式是一样的,只不过类名需要用斜体,抽象方法也用斜体</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>接口名</li><li>方法名</li></ul><blockquote><p>其中接口名要用两行,首行固定为<code>&lt;&lt;interface&gt;&gt;</code>,第二行为接口名</p></blockquote><h1 id="类与类之间的继承关系"><a href="#类与类之间的继承关系" class="headerlink" title="类与类之间的继承关系"></a>类与类之间的继承关系</h1><ul><li>空心三角实线,指向父类</li></ul><h1 id="类与接口的实现关系"><a href="#类与接口的实现关系" class="headerlink" title="类与接口的实现关系"></a>类与接口的实现关系</h1><ul><li>空心三角虚线,指向接口</li></ul><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><blockquote><p>聚合(Aggregation)表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p></blockquote><ul><li>空心的菱形实线箭头,指向A</li></ul><h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><blockquote><p>当类A知道另一个类B时，可以用关联(association),是一种拥有的关系;eg:A 中使用了 B; A 中生成了 B; A 向 B 发送消息等都算关联</p></blockquote><ul><li>实线箭头,指向B</li></ul><p>比较常见的一种UML 图中,经常是聚合与关联同时有的,A 和 B 之间,空心菱形指向 A,实线箭头指向 B</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><blockquote><p> 组合(Composition)是一种强的拥有关系，体现了严格的部分B和整体A的关系，部分B和整体A的生命周期一样。</p></blockquote><ul><li>实心的菱形实线箭头,指向A</li></ul><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><blockquote><p>依赖关系(Dependency)，是一种使用关系。多用于局部变量，方法的参数或者对静态方法的调用。要避免双向依赖。</p></blockquote><ul><li>虚线箭头，指向所依赖的类</li></ul><h1 id="连接线的注释说明"><a href="#连接线的注释说明" class="headerlink" title="连接线的注释说明"></a>连接线的注释说明</h1><blockquote><p>有时候在一个类图中光有上面的元素,依然无法清楚的说明类之间的关系,因此可以在连接线上,再伸出一根虚线到旁边,并附带一个折掉右上角的矩形,在该矩形中,添加相关说明</p></blockquote><ul><li>虚线 + 折掉右上角的矩形</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TestMusic</title>
      <link href="/2018/01/23/TestMusic/"/>
      <url>/2018/01/23/TestMusic/</url>
      
        <content type="html"><![CDATA[<p>测试音乐播放器。依次使用了 iframe，audio，embed三个标签，推荐指数逐渐降低。</p><a id="more"></a><h1 id="使用-iframe"><a href="#使用-iframe" class="headerlink" title="使用 iframe"></a>使用 iframe</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=208891&amp;auto=1&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果网易云音乐中有对应资源，推荐使用iframe播放，缺点就是网易云音乐版权太少。</p><h1 id="使用-audio"><a href="#使用-audio" class="headerlink" title="使用 audio"></a>使用 audio</h1><audio src="http://musics.gimhoy.com/mp3/2018/01/50583a8f3e36638aba61c52de18185fc.mp3" controls="controls" autoplay="autoplay" loop="loop"></audio><p>如果网易云音乐没有版权的话，推荐使用audio。<br>音乐外链获取方式：<a href="http://music.gimhoy.com/" target="_blank" rel="noopener">gimhoy音乐盘</a></p><h1 id="使用flash插件"><a href="#使用flash插件" class="headerlink" title="使用flash插件"></a>使用flash插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;embed src=&quot;//music.163.com/style/swf/widget.swf?sid=25714332&amp;type=2&amp;auto=1&amp;width=320&amp;height=66&quot; width=&quot;340&quot; height=&quot;86&quot;  allowNetworking=&quot;all&quot;&gt;&lt;/embed&gt;</span><br></pre></td></tr></table></figure><p>不推荐，无法实现自动播放，页面中还需要手动点击，影响体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(18)异常处理机制</title>
      <link href="/2018/01/20/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-18-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/20/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-18-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>前面介绍了方法的调用过程，简单的方法可以在我们自己写的 JVM 中运行起来了，但是方法的执行过程并不完整，因为方法可能会抛出异常，我们暂时还无法处理异常。本节依然通过示例来讲解异常的处理机制。进一步完善我们的 JVM。核心是 <a href="https://github.com/zachaxy/JVM/blob/master/Java/src/instructions/references/ATHROW.java" target="_blank" rel="noopener">athrow 指令的实现</a></p><a id="more"></a><h1 id="本节异常处理机制所用的示例"><a href="#本节异常处理机制所用的示例" class="headerlink" title="本节异常处理机制所用的示例"></a>本节异常处理机制所用的示例</h1><p>本节所讲解的异常处理机制是基于以下面的例子做说明的，有两个方法，(1)func 方法直接抛出了一个异常；(2)test 方法调用了 func 方法，同时试图用 try-catch 来捕获异常，但是其所捕获的异常并非 func 抛出的异常，也就是说 test 方法处理不了，最终交由 JVM 来处理，而 JVM 默认的处理方式则是打印虚拟机堆栈信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        i = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 方法的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 0 bipush 100</span><br><span class="line"> 2 istore_0</span><br><span class="line"> 3 invokestatic #60 &lt;test/TestException12.func&gt;</span><br><span class="line"> 6 goto 14 (+8)</span><br><span class="line"> 9 astore_1</span><br><span class="line">10 sipush 200</span><br><span class="line">13 istore_0</span><br><span class="line">14 return</span><br></pre></td></tr></table></figure><h1 id="直观的感受-athrow-命令"><a href="#直观的感受-athrow-命令" class="headerlink" title="直观的感受 athrow 命令"></a>直观的感受 athrow 命令</h1><p>由上面的 func 方法，其方法体直接通过 throw 关键字抛出了一个异常，那么查看 func 方法对应的字节码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 new #62 &lt;java/lang/IndexOutOfBoundsException&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #63 &lt;java/lang/IndexOutOfBoundsException.&lt;init&gt;&gt;</span><br><span class="line">7 athrow</span><br></pre></td></tr></table></figure><p>前面的三个指令是在创建 IndexOutOfBoundsException 异常的一个实例，并执行其 init 方法。<br>接下来就是一个 athrow 命令，将上面创建的异常抛出。这就是 athrow 指令出现的场景。现在只是只管的感受一下 athrow 指令，暂时先不去实现它。</p><h1 id="异常处理表"><a href="#异常处理表" class="headerlink" title="异常处理表"></a>异常处理表</h1><p>func 方法内部抛出了异常，那么接下来需要另一个方法 test 来调用 func 方法。在 test 方法中，我们 catch 了一个异常 NumberFormatException，但是该异常的类型并不是 func 方法抛出的异常，因此是不会执行对应的 catch 块的。我们通过定义一个变量 i 来标示，如果执行了 catch 块，那么该变量 i 会变为 200，否则还是初值 100；</p><p>如果在方法中使用了 try-catch 语句，那么在该方法的 code 属性中就会有一个异常处理表。这里之所以叫表，是因为我们可能会 catch 多个异常，每 catch 一个异常，就会产生一条表项。<br>在上面的 test 方法中就有异常表，因为我们这里只有一个 catch，所以异常表只有一条表项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    start:3</span><br><span class="line">    end:6</span><br><span class="line">    hadlerPC:9</span><br><span class="line">    catchType: #5 (java/lang/NumberFormatException)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 中定义的异常处理表项有四个字段：均为整数</p><ul><li>startPc</li><li>endPc</li><li>handlerPc</li><li>catchType</li></ul><p>其含义如下：<br>[startPc,endPc) 一个区间:锁定一个指令区间,该区间可能抛出某种异常。test 的异常表表示在字节码 3 到字节码 6(不包含 6)之间，可能会抛出异常，而指令 3 正是调用了抛出异常的 func 方法。<br>handlerPc:负责处理异常的 catch 块的其实位置，一旦发现某个 catch 可以处理该异常，那么就将 nextPc 改为 handlerPc。<br>catchType:指向运行时常量池的一个索引,通过该索引可以得到一个异常的类 xxxException 的对象，也就是我们在代码中显式 catch 的异常的类型。</p><h1 id="解析异常处理表"><a href="#解析异常处理表" class="headerlink" title="解析异常处理表"></a>解析异常处理表</h1><p>和之前的常量池类似，异常处理表也是保存 class 文件中，我们在读取 class 文件的时候，一样要对其进行转换。<br>首先看一下其在 ClassFile 中的表现形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTableEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startPc;        <span class="comment">//可能排除异常的代码块的起始字节码（包括）</span></span><br><span class="line">    <span class="keyword">int</span> endPc;          <span class="comment">//可能排除异常的代码块的终止字节码（不包括）</span></span><br><span class="line">    <span class="keyword">int</span> handlerPc;      <span class="comment">//负责处理异常的 catch 块的其实位置</span></span><br><span class="line">    <span class="keyword">int</span> catchType;      <span class="comment">//指向运行时常量池的一个索引，解析后可以得到一个异常类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其在 Zclass 中的表现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> startPc;</span><br><span class="line">    <span class="keyword">int</span> endPc;</span><br><span class="line">    <span class="keyword">int</span> handlerPc;</span><br><span class="line">    ClassRef catchType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比发现，具体的转换是将 catchType 运行时常量池的常量直接转换为对应的异常类的引用，其转换过程是在 ClassFile-&gt;Zclass 的转换过程中，具体对应到方法的转换过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zclass</span><span class="params">(ClassFile classFile)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    runtimeConstantPool = <span class="keyword">new</span> RuntimeConstantPool(<span class="keyword">this</span>, classFile.getConstantPool());</span><br><span class="line">    fileds = Zfield.makeFields(<span class="keyword">this</span>, classFile.getFields());</span><br><span class="line">    methods = Zmethod.makeMethods(<span class="keyword">this</span>, classFile.getMethods());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="athorw-命令的实现-异常处理流程"><a href="#athorw-命令的实现-异常处理流程" class="headerlink" title="athorw 命令的实现(异常处理流程)"></a>athorw 命令的实现(异常处理流程)</h1><p>再次贴出 test 方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        i = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 对应的栈帧为 frame1，当其内部执行 func 方法时，会为其创建栈帧 frame2，在 frame2 中执行 func 方法，在 func 方法中，首先创建了一个异常——IndexOutOfBoundsException 的对象，该对象放在 frame2 的操作数栈顶。然后遇到了 athrow 命令，该指令将 frame2 操作数栈顶的异常对象 ex pop 出来，然后从当前 frame 开始遍历虚拟机栈。我们知道当前 JVM 的栈为 frame1 -&gt; frame2。那么先从 frame2 开始，查找当前方法的异常处理表，当然我们一般在写代码的时候不会在手动写了 throw 异常之后，立刻在当前方法就去 catch 它，我们一般的做法都是在 func 方法的声明处显示的 throws 对应的异常，等待调用 func 的上层方法来出来，但是语法也是允许自己来 catch 的，所以先从 frame2 查找，查找不到，那么将 frame2 从虚拟机栈弹出，然后再从当前栈顶的 frame1 中查找是否可以找到异常处理项，就这样一直遍历下去。</p><p>这样的遍历会产生两个结果：</p><ol><li>在某个 frame 中找到了可以处理该异常的项，那么首先到该 frame 的操作数栈清空，然后把异常对象压入当前操作数栈，接着执行该 frame 对应的 catch 块语句。</li><li>遍历了整个虚拟机栈都没有找到可以处理的异常项，因此交由 JVM 来处理，而 JVM 的处理方式就是打印虚拟机栈信息(从产生异常的方法 func 对应的 frame，依次到 main 方法对应的 frame)</li></ol><p>athrow 指令的处理流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Zobject ex = frame.getOperandStack().popRef();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前 thread,是想从 thread 中获取所有的 frame(一个 frame 就是一个方法调用过程的抽象)</span></span><br><span class="line">Zthread thread = frame.getThread();</span><br><span class="line"><span class="keyword">if</span> (!findAndGotoExceptionHandler(thread, ex)) &#123;</span><br><span class="line">    <span class="comment">//所有的方法调用栈均不能处理该异常了,那么交由 JVM 来处理;</span></span><br><span class="line">    handleUncaughtException(thread, ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面多次提到了在当前 frame 寻找对应的异常处理项，如何寻找，这就用到了 findAndGotoExceptionHandler 方法，具体流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从当前帧开始,遍历 Java 虚拟机栈,查找方法的异常处理表</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findAndGotoExceptionHandler</span><span class="params">(Zthread thread, Zobject ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Zframe frame = thread.getCurrentFrame();</span><br><span class="line">        <span class="comment">//正常情况下,获取一条指令后,bytereader 中的 pc 是要+1,指向下一条指令的地址</span></span><br><span class="line">        <span class="comment">// 但是 athrow 指令比较特殊,因为现在已经抛出异常了,不能继续向下执行了,所以要回退;</span></span><br><span class="line">        <span class="keyword">int</span> pc = frame.getNextPC() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时 pc 指向的是 throw 异常的那一行;因为接下来就要在当前方法的异常处理表中寻找可以处理当前 pc 指向的指令所抛出的异常了</span></span><br><span class="line">        <span class="keyword">int</span> handlerPC = frame.getMethod().findExceptionHandler(ex.getClazz(), pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前方法能处理自己抛出的异常</span></span><br><span class="line">        <span class="keyword">if</span> (handlerPC &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            OperandStack operandStack = frame.getOperandStack();</span><br><span class="line">            operandStack.clear();<span class="comment">//清空操作数栈</span></span><br><span class="line">            operandStack.pushRef(ex);<span class="comment">//将抛出的异常放进去</span></span><br><span class="line">            frame.setNextPC(handlerPC);<span class="comment">//指令跳转到对应的 catch 块中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//能走到这一步,说明当前方法不能处理当前方法抛出的异常,需要回到调用该方法的帧 frame</span></span><br><span class="line">        thread.popFrame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整个调用栈都无法处理异常，交由 JVM 来处理吧；JVM 处理的方法就是下面的 handleUncaughtException</span></span><br><span class="line">        <span class="keyword">if</span> (thread.isStackEmpty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超找异常处理项，最终是在 Method 的 ExceptionTable 对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回能解决当前 Exception 的 handler=&gt;多个 catch 块,决定用哪个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExceptionHandler <span class="title">findExceptionHandler</span><span class="params">(Zclass exClazz, <span class="keyword">int</span> pc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exceptionTable.length; i++) &#123;</span><br><span class="line">        ExceptionHandler handler = exceptionTable[i];</span><br><span class="line">        <span class="keyword">if</span> (pc &gt;= handler.startPc &amp;&amp; pc &lt; handler.endPc) &#123;</span><br><span class="line">            <span class="comment">// catch all</span></span><br><span class="line">            <span class="keyword">if</span> (handler.catchType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 catch 的异常是实际抛出的异常的父类，也可以捕获</span></span><br><span class="line">            Zclass catchClazz = handler.catchType.resolvedClass();</span><br><span class="line">            <span class="keyword">if</span> (catchClazz == exClazz || catchClazz.isSuperClassOf(exClazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面能找到对应的异常处理项，那么整个程序还可以正常运行，但如果没有找到的话，就要交给 JVM 来处理的，此时也意味着当前的虚拟机栈已经被清空了，解释器也停止执行了，JVM 将整个调用链打印出来，程序结束。</p><h1 id="Java-虚拟机栈信息"><a href="#Java-虚拟机栈信息" class="headerlink" title="Java 虚拟机栈信息"></a>Java 虚拟机栈信息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NStackTraceElement</span> </span>&#123;</span><br><span class="line">    String fileName;<span class="comment">//类所在的 java 文件</span></span><br><span class="line">    String className;<span class="comment">//声明方法的类名</span></span><br><span class="line">    String methodName;<span class="comment">//调用方法名</span></span><br><span class="line">    <span class="keyword">int</span> lineNumber;<span class="comment">//出现 exception 的行号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NStackTraceElement 代表每个 frame 中调用抛出异常方法的具体消息。</p><p>上面实现了 ATHROW 命令，但是目前程序还是无法运行，因为异常的父类 Exception 的构造方法中会调用一个 native 的方法——fillInStackTrace，因此还要在 native 方法中注册 fillInStackTrace 方法，同时在该方法中进行虚拟机调用栈的收集工作。<br>具体的代码请参考<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/znative/java/lang/Nthrowable" target="_blank" rel="noopener">Nthrowable.java</a>，注释已经写的很清楚，相信不会有太大的阅读困难。</p><h1 id="异常的测试用例"><a href="#异常的测试用例" class="headerlink" title="异常的测试用例"></a>异常的测试用例</h1><p>同样，这里提供了一个单独的<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestException12.java" target="_blank" rel="noopener">测试用例</a>来测试异常，我们的 test 方法并没有不会 func 方法抛出的异常，这一点从最终打印 test 的本地变量表就可以发现，i 的值为 100，没有走到 catch 语句中。同时程序也打印出了虚拟机堆栈信息，具体打印信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">the same as testInterpreter06!</span><br><span class="line">java -cp /Users/zachaxy/TestClassFiles  TestException12</span><br><span class="line">current instruction: 0: BIPUSH</span><br><span class="line">current instruction: 2: ISTORE_0</span><br><span class="line">current instruction: 3: INVOKE_STATIC</span><br><span class="line">current instruction: 3: INVOKE_STATIC</span><br><span class="line">test.TestException12.f1(TestException12.java:82)</span><br><span class="line">test.TestException12.test(TestException12.java:75)</span><br><span class="line">100</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(17)本地方法的调用过程</title>
      <link href="/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-17-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-17-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>java 中有一些方法前面的关键字是<code>native</code>，该关键字修饰的方法表明当前方法不是由 java 实现的方法，而是由本地语言编写的。本地语言就是所在的操作系统所用的语言。因为一些和操作系统底层相关的方法是 java 无法实现的，或者基于性能的考虑，由 java 实现并没有用本地方法实现在执行效率上更高效，所以会用到本地方法。</p><p>本地方法的调用是通过 JNI(Java Native Interface)来实现的，JNI 是 JVM 中的一个重要组成部分，但是要让 JVM 支持 JNI 规范还需要做大量的工作，而本系列关于 JVM 的介绍主要还是 JVM 的工作原理，为了不陷入到 JNI 的细节中，同时我们的 JVM 是用 java 来实现的，本身也不具备实现 JNI 规范的能力。因此这里只是通过简单的实例，通过 java 来描述 JNI 的实现过程。本节所实现的代码都在<a href="https://github.com/zachaxy/JVM/tree/master/Java/src/znative" target="_blank" rel="noopener">znative 包下</a><br>有关 JNI 的细节，请参考<a href="https://zachaxy.github.io/tags/JNI/">JNI 系列文章</a></p><a id="more"></a><h1 id="本地方法的注册"><a href="#本地方法的注册" class="headerlink" title="本地方法的注册"></a>本地方法的注册</h1><p>这里提到了注册，一般说起注册，都是在某处进行登记，表明自身的存在。其实在 JVM 中有一个<strong>本地方法注册表</strong>，native 方法的注册也是起一个标记占坑的作用，在本地方法表中注册本地方法，方便后面 JVM 需要调用本地方法时，能够从本地方法注册表中找到对应的本地方法。本节注册本地方法的代码请参考<a href="https://github.com/zachaxy/JVM/tree/master/Java/src/znative/RegisterCenter.java" target="_blank" rel="noopener">RegisterCenter.java</a></p><p>JVM 一般是用 c 语言编写的，在 JVM 的实现中，本地方法其实是在 JVM 中实现的， java 中本地方法都会映射为 JVM 中 c 的一个方法指针。</p><p>要实现本地方法的注册，其实就是实现<strong>本地方法注册表</strong>，本地方法注册表本质是上就是一个 map 的数据结构，其 key 为方法所在的类+方法名+方法签名，value 为本地方法的指针。<br>然而我们用 java 实现的 JVM ，所以只能用接口的方式来模拟 c 中的方法指针。<strong>再次强调用 java 来实现 JVM 是不正规的，但是通过本章的介绍，依然可以对 JVM 本地方法的实现有一个整理的理解。</strong><br>用接口的方式模拟 c 中的指针，我们所定义的接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NativeMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Zframe frame)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 NativeMethod 接口，其接口中只有一个 run 方法，用来执行本地方法，同时该方法需要一个 frame 参数，之前介绍 Frame 时，代表一个方法的工作空间，同样本地方法也需要一个工作空间，该 frame 参数就是当前本地方法的工作空间。</p><p>下面是本地方法的注册实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, NativeMethod&gt; nativeMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String className, String methodName, String methodDescriptor, NativeMethod nativeMethod)</span> </span>&#123;</span><br><span class="line">    String key = className + <span class="string">"~"</span> + methodName + <span class="string">"~"</span> + methodDescriptor;</span><br><span class="line">    nativeMethods.put(key, nativeMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本地方法注册的时机"><a href="#本地方法注册的时机" class="headerlink" title="本地方法注册的时机"></a>本地方法注册的时机</h1><p>接下来要考虑的问题在何时进行注册，哪些方法需要注册。其实很多 java 类中都包含 native 方法，而在这些包含 native 方法的类中，一般都有一个 registerNatives 的本地方法，该方法的作用是用来将本类中其它的 native 方法注册到本地方法注册表中。而 registerNatives 方法都是在类的静态代码块中执行的，也就是当前类加载到虚拟机的时候，就将该类的本地方法注册到本地方法注册表中。<br>例如 <code>java.lang.Object</code>中的实现，java 中其它类基本上也是这样的套路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 JVM 只是简易的实现版本，所有的方法都是通过代码手动注册的，所以并没有实现 registerNatives 方法，而是将 Object 中的 native 方法一一手动注册进来。当然可以在遇到 registerNatives 的本地方法时，就将扫描当前类中的 native 方法，依次注册进来。我们的 JVM 就不这样实现了，开篇也也说了我们不想花太多精力在 JNI 的实现细节上，所以我们只是会手动注册有限的几个本地方法，来大致了解一下本地方法调用的整个流程。所以如果遇到了调用 registerNatives 方法的情况，不管其所在的哪个类，就返回一个空的实现。</p><p>而我们的 JVM 中所手动注册有限的几个本地方法，都在 RegisterCenter 的 init 方法中手动注册，并在我们的 JVM 开启时，手动调用该方法，即完成了注册。已下就是我的 JVM 中所有实现的本地方法，如果各位感兴趣，可以继续向 init 方法中添加对应的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对外供 JVM 启动后的唯一接入口，JVM 启动后应该立即调用 RegisterCenter 的 init 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    register(<span class="string">"java/lang/Object"</span>, <span class="string">"getClass"</span>, <span class="string">"()Ljava/lang/Class;"</span>, <span class="keyword">new</span> Nobject.getClass());</span><br><span class="line">    register(<span class="string">"java/lang/Class"</span>, <span class="string">"getPrimitiveClass"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/Class;"</span>, <span class="keyword">new</span> Nclass.getPrimitiveClass());</span><br><span class="line">    register(<span class="string">"java/lang/Class"</span>, <span class="string">"getName0"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">new</span> Nclass.getName0());</span><br><span class="line">    register(<span class="string">"java/lang/Class"</span>, <span class="string">"desiredAssertionStatus0"</span>, <span class="string">"(Ljava/lang/Class;)Z"</span>, <span class="keyword">new</span> Nclass.desiredAssertionStatus0());</span><br><span class="line">    register(<span class="string">"java/lang/Class"</span>, <span class="string">"isArray"</span>, <span class="string">"()Z"</span>, <span class="keyword">new</span> Nclass.isArray());</span><br><span class="line">    register(<span class="string">"java/lang/Throwable"</span>, <span class="string">"fillInStackTrace"</span>, <span class="string">"(I)Ljava/lang/Throwable;"</span>, <span class="keyword">new</span> Nthrowable.fillInStackTrace());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为本地方法注入字节码"><a href="#为本地方法注入字节码" class="headerlink" title="为本地方法注入字节码"></a>为本地方法注入字节码</h1><p>上面只是完成了本地方法的注册，接下来就要实现本地方法的执行过程了。但是在实现本地方法之前，我们还要对本地方法进行特殊的处理，因为在 JVM 中并没有规定如何实现和调用本地方法。在 JVM 中调用 native 方法和调用其它方法所用的指令是一样的，也就是说调用本地静态方法会产生一个<code>invoke_static</code>的指令，调用本地非静态方法，会产生一个<code>invoke_special</code>的指令。但是我们对于本地方法，我们要做特殊的处理，因为 <strong>native 方法在 class 文件中没有字节码。</strong> </p><p>以静态普通方法和静态本地方法的指令为例，JVM 都是产生的 invoke_static 的指令，其指令的指令过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">INVOKE_STATIC</span> <span class="keyword">extends</span> <span class="title">Index16Instruction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        RuntimeConstantPool runtimeConstantPool = frame.getMethod().getClazz().getRuntimeConstantPool();</span><br><span class="line">        <span class="comment">//通过 index,拿到方法符号引用</span></span><br><span class="line">        MethodRef methodRef = (MethodRef) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">        Zmethod resolvedMethod = methodRef.resolvedMethod();</span><br><span class="line">        <span class="keyword">if</span> (!resolvedMethod.isStatic()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncompatibleClassChangeError();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Zclass clazz = resolvedMethod.getClazz();</span><br><span class="line">        <span class="comment">//判断其 Class 是否已经加载过,如果还未加载,那么调用其类的&lt;clinit&gt;方法压栈</span></span><br><span class="line">        <span class="keyword">if</span> (!clazz.isInitStarted()) &#123;</span><br><span class="line">            <span class="comment">//当前指令已经是在执行 new 了,但是类还没有加载,所以当前帧先回退,让类初始化的帧入栈,等类初始化完成后,重新执行 new;</span></span><br><span class="line">            frame.revertNextPC();</span><br><span class="line">            ClassInitLogic.initClass(frame.getThread(), clazz);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MethodInvokeLogic.invokeMethod(frame, resolvedMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeLogic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(Zframe invokerFrame, Zmethod method)</span> </span>&#123;</span><br><span class="line">        Zthread thread = invokerFrame.getThread();</span><br><span class="line">        Zframe newFrame = thread.createFrame(method);</span><br><span class="line">        thread.pushFrame(newFrame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> argSlotCount = method.getArgSlotCount();</span><br><span class="line">        <span class="keyword">if</span> (argSlotCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = argSlotCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                Slot slot = invokerFrame.getOperandStack().popSlot();</span><br><span class="line">                newFrame.getLocalVars().setSlot(i, slot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 invoke_static 指令中，解析方法符号引用为直接引用，然后就会调用<code>MethodInvokeLogic.invokeMethod(frame, resolvedMethod)</code>方法，该方法内部会创建一个新的 frame 来供被调用的方法来执行，此时 JVM 的栈帧的顶部就是该 frame，解释器此时会读取 JVM 栈帧顶部的 frame 作为当前 frame，并执行该 frame 所绑定的 method 中的字节码。因为本地方法没有字节码，但我们又要让本地方法也适应 JVM 解释器，因此我们的做法是为本地方法注入字节码，本地方法的字节码只需要两个字节，第一个字节用来表示接下来要执行的方法是本地方法，(JVM 规范中预留了两条指令，操作码为 0xFE 和 0xFF，这里我们使用 0xFE 来表示本地方法的调用)。第二个字节用来表示本地方法的 return 指令，其 return 指令和非 native 方法的 return 指令完全一样。</p><p>接下来先完成本地方法字节码的构造，在创建 Zmethod 实例时，如果该方法是 native 的，我们将进行如下构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Zmethod</span><span class="params">(Zclass clazz, MemberInfo classFileMethod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(clazz, classFileMethod);</span><br><span class="line">    copyAttributes(classFileMethod);</span><br><span class="line">    parsedDescriptor = <span class="keyword">new</span> MethodDescriptor(<span class="keyword">this</span>.descriptor);</span><br><span class="line">    argSlotCount = calcArgSlotCount(parsedDescriptor.getParameterTypes());</span><br><span class="line">    <span class="keyword">if</span> (isNative()) &#123;</span><br><span class="line">        injectCodeAttribute(parsedDescriptor.getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM 并没有规定如何实现和调用本地方法，这里我们依然使用 JVM 栈 来执行本地方法</span></span><br><span class="line"><span class="comment">// 但是本地方法中并不包含字节码，那么本地方法的调用，这里我们利用接口来实现调用对应的方法；</span></span><br><span class="line"><span class="comment">// 同时 JVM 中预留了两条指令，操作码分别是 0xff 和 0xfe，下面使用 0xfe 来当前方法为表示本地方法</span></span><br><span class="line"><span class="comment">// 第二个字节为本地方法的返回指令，该指令和普通方法的返回指令是一样的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectCodeAttribute</span><span class="params">(String returnType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//本地方法的操作数栈暂时为 4;至少能容纳返回值</span></span><br><span class="line">    <span class="keyword">this</span>.maxStack = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//本地方法的局部变量表只用来存放参数,因此直接这样赋值</span></span><br><span class="line">    <span class="keyword">this</span>.maxLocals = <span class="keyword">this</span>.argSlotCount;</span><br><span class="line">    <span class="comment">//接下来为本地方法构造字节码:起始第一个字节都是 0xfe,用来表用这是本地方法;</span></span><br><span class="line">    <span class="comment">//第二个字节码则根据不同的返回值类型选择相应的 xreturn 的指令即可</span></span><br><span class="line">    <span class="comment">//不必担心下面的 byte 的强转，因为在读取字节码时，使用的是 readUint8()方法</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">            <span class="keyword">this</span>.code = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xfe</span>, (<span class="keyword">byte</span>) <span class="number">0xb1</span>&#125;; <span class="comment">// return</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">            <span class="keyword">this</span>.code = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xfe</span>, (<span class="keyword">byte</span>) <span class="number">0xb0</span>&#125;; <span class="comment">// areturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">this</span>.code = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xfe</span>, (<span class="keyword">byte</span>) <span class="number">0xaf</span>&#125;; <span class="comment">// dreturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">            <span class="keyword">this</span>.code = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xfe</span>, (<span class="keyword">byte</span>) <span class="number">0xae</span>&#125;; <span class="comment">// freturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'J'</span>:</span><br><span class="line">            <span class="keyword">this</span>.code = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xfe</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span>&#125;; <span class="comment">// lreturn</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">this</span>.code = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>) <span class="number">0xfe</span>, (<span class="keyword">byte</span>) <span class="number">0xac</span>&#125;;<span class="comment">// ireturn</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在上面的字节注入中，还未本地方法添加了本地变量表和操作数栈。本地变量表的大小为本地方法的参数个数。操作数栈的大小这里设置为 4，其实这个值至少是 2，因为我们只是用操作数栈来盛放本地方法的返回值。</p><h1 id="本地方法的调用"><a href="#本地方法的调用" class="headerlink" title="本地方法的调用"></a>本地方法的调用</h1><p>在完成了本地方法的字节注入之后，终于可以实现本地方法的调用了。因为我们为本地方法注入了两个字节码，所以在 JVM 的解释器真正执行本地方法时，会本地方法中的这两个字节码，首先是 0xFE，这是我们自己构造的，解释器在遇到这个字节码时，其实是不认识的，因为 JVM 规范中没有用到该字节码，于是在这里我们手动创建一个 invoke_native 指令，该指令就对应 0xFE。不要忘了在我们的 InstructionFactory.java 的 createInstruction 方法中，添加对该字节码的解析。注意：JVM 中是没有 invoke_native 指令的，这是我们自己创建的指令。其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">INVOKE_NATIVE</span> <span class="keyword">extends</span> <span class="title">NoOperandsInstruction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        Zmethod method = frame.getMethod();</span><br><span class="line">        String clazzName = method.getClazz().thisClassName;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        String descriptor = method.getDescriptor();</span><br><span class="line"></span><br><span class="line">        NativeMethod nativeMethod = RegisterCenter.findNativeMethod(clazzName, methodName, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (nativeMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String methodInfo = clazzName + <span class="string">"."</span> + methodName + descriptor;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(methodInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativeMethod.run(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面也说了本地方法中没有字节码，我们认为注入了标示本地方法开始的字节码 0xFE，已经本地方法返回的字节码。但是中间具体的指令流程我们是无法用字节码构造了，因为这样太麻烦了。所以在 java 层面是不知道本地方法内部如何执行，因为本地方法会映射到 JVM 中的一个 c 的指针，也就是说每一个本地方法对应的具体实现都已经在 JVM 中实现好了，由该指针指向的代码来执行具体的逻辑(我们的 JVM 中就是通过接口来模拟方法指针了)。这就需要在 JVM 找到对应的本地方法的具体实现，并执行本地方法。</p><p>本地方法的查找，也很简单，只要从本地方法注册表中根据方法名获取到具体实现即可，我们这里是获取到 NativeMethod 接口的一个实现类，然后调用其 run 方法。这里要注意的是如果方法名为 registerNatives,则返回一个空实现即可，原因在文章开始已经解释过了。对于其它情况，如果在本地方法表中没有提前注册，那么将抛出 UnsatisfiedLinkError 的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NativeMethod <span class="title">findNativeMethod</span><span class="params">(String className, String methodName, String methodDescriptor)</span> </span>&#123;</span><br><span class="line">    String key = className + <span class="string">"~"</span> + methodName + <span class="string">"~"</span> + methodDescriptor;</span><br><span class="line">    <span class="keyword">if</span> (nativeMethods.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeMethods.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"()V"</span>.equals(methodDescriptor)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"registerNatives"</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="comment">//返回一个空的方法执行体 emptyNativeMethod</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NativeMethod() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本地方法调用实战"><a href="#本地方法调用实战" class="headerlink" title="本地方法调用实战"></a>本地方法调用实战</h1><p>通过上面的讲解，可能还是一头雾水，请不要怀疑自己的能力，是我表达的不太够准确，因此在最后一节，准备了一个本地方法调用的实战，当你看明白了这个实战的流程之后，再看上面的讲解，也许你会豁然开朗。</p><p>本实战准备的例子是<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestGetClass11.java" target="_blank" rel="noopener">TestGetClass11.java</a><br>测试所用的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">int</span>.class.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是调用了基本类型的类，<a href="https://zachaxy.github.io/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-16-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/">上一章</a>反射中已经介绍了其实现原理，我们这里重点看 getName 方法，该方法内步流程是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String name = <span class="keyword">this</span>.name;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.name = name = getName0();</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">getName0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>发现这里调用了 getName0 方法，而 getName0 方法就是本地方法。所以我们要在 JVM 中实现该方法。在 znative 包下，创建 Nclass.java，在 java/lang/Class 中的本地方法都将在 Nclass 中进行实现。不过我们并不打算将 Class 中的本地方法全部实现，这里只用到了 getName0 的方法，所以我们只实现 getName0 的逻辑，其具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">getName0</span> <span class="keyword">implements</span> <span class="title">NativeMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        Zobject self = frame.getLocalVars().getRef(<span class="number">0</span>);</span><br><span class="line">        Zclass clazz = (Zclass) self.extra;</span><br><span class="line">        String name = clazz.getJavaName();</span><br><span class="line">        Zobject nameObj = StringPool.jString(clazz.getLoader(), name);</span><br><span class="line">        frame.getOperandStack().pushRef(nameObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JVM 本地方法 getName0 实现了 NativeMethod 接口，在 run 方法中，首先获取本地变量表中的第一个变量，也就是调用 getName0 方法的对象 <code>this</code>，然后获取到 this 的类，最核心就是 <code>class.getJavaName()</code>这一句，获取到当前 class 的 javaName，其实现也非常简单，在 Zclass.java 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getJavaName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> thisClassName.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了本地方法的具体实现，接下来记得在本地方法注册表中进行注册，其在 RegisterCenter.java 的 init 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">register(<span class="string">"java/lang/Class"</span>, <span class="string">"getName0"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">new</span> Nclass.getName0());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后不要忘记在 JVM 启动之前，调用<code>RegisterCenter.init()</code>，将本地方法注册到 JVM 中。具体实现流程请参考<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestGetClass11.java" target="_blank" rel="noopener">TestGetClass11.java</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(16)反射机制简介</title>
      <link href="/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-16-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/01/18/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-16-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>反射是 java 一个强大的机制，通过反射，我们可以动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型，然后调用类型的方法或访问其字段和属性。本节主要介绍反射机制中用到的类对象。</p><a id="more"></a><h1 id="理解类对象"><a href="#理解类对象" class="headerlink" title="理解类对象"></a>理解类对象</h1><p>我们之前在 JVM 中定义了 Zclass 类，用来表示一个 class 文件在 JVM 中的抽象(注意该 Zclass 和 java/lang/Class 中的做区分，前者是在 JVM 中，后者是在 java 应用程序中的类)。在构造 Zclass 对象时，我们是传入了一个 ClassFile 的对象,然后通过 ClassFile 对象的各个字段，构造了 Zclass 对象。同一个 class 文件会产生唯一的一个 Zclass 对象(前提是用同一个类加载器加载的 class 文件，如果是不同的类加载器，则另当别论，本文暂时不讨论多个类加载器加载同一个 class 文件的情况，所以暂且认为同一个 class 文件和 Zclass 对象是一一对应的)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zclass</span><span class="params">(ClassFile classFile)</span> </span>&#123;</span><br><span class="line">    accessFlags = classFile.getAccessFlags();</span><br><span class="line">    thisClassName = classFile.getClassName();</span><br><span class="line">    superClassName = classFile.getSuperClassName();</span><br><span class="line">    interfaceNames = classFile.getInterfaceNames();</span><br><span class="line">    runtimeConstantPool = <span class="keyword">new</span> RuntimeConstantPool(<span class="keyword">this</span>, classFile.getConstantPool());</span><br><span class="line">    fileds = Zfield.makeFields(<span class="keyword">this</span>, classFile.getFields());</span><br><span class="line">    methods = Zmethod.makeMethods(<span class="keyword">this</span>, classFile.getMethods());</span><br><span class="line">    sourceFile = classFile.getSourceFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Zclass 就可以描述一个类，其实我们在 java 中定义一个类，无非就是在定义两类东西，一个是该类中有哪些变量，另一个是该类中有哪些方法。这些都可以在 Zclass 中反映出来。</p><p>我们在 JVM 中定义的 Zobject(Zobject 表示的是在 JVM 中一个对象的，要注意其和在 java 应用中 Object 的区别) 中就有一个字段，其指向该对象对应的 Zclass 对象。这个很容易理解，因为 Zobject 中只保存了该对象的成员变量的值，如果要执行该类的方法，还是要去对应的 Zclass 中的 Zmethod 中获取对应的字节码。方法的字节码都是一样的，并不针对单独的对象，同一个类创建的对象，调用其方法时的字节码都是一样的，只不过传入的参数不同而已。因此为了节省 JVM 的内存，没有必要为每个 Zobject 中保存方法的字节码。</p><p>这里只是打通了 Zobject 到 Zclass 的单向通道，其实 Zclass 中也需要一个字段指向一个具体的 Zobject，注意该 Zobject 并不是由 Zclass 创建的<strong>实例对象</strong>，而是 Zclass 所代表的 Class 的<strong>类对象</strong>。<br>我们拿熟悉的 String 类举例子，每个字符串 eg:”hello”都是 String 的一个实例对象，对应 JVM 中的 Zobject。然而 String 所代表的类，也有一个实例对象，该对象的获取方式有两种：</p><ul><li>String.class</li><li>“hello”.getClass()</li></ul><p>这两种方法获取到的都是同一个对象。</p><p>这也解释了为什么 JVM 中每个 Zclass 中都需要一个字段指向该类的类对象(String.class)，而不是类的实例对象 “hello”</p><p>接下来我们就在 Zclass 中添加这个字段，让其指向该类的类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zclass</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    Zobject jObject;        <span class="comment">// jObject 指向的是该类的元类对象 obj。 eg：String.class 得到的结果</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了该字段，那么该字段具体在上面时候赋值呢？回想一下 Zclass 是何时被创建的，是通过类加载器加载 class 文件是生成的，于是我们也就很自然的想到类对象需要紧跟着在 Zclass 生成之后生成。</p><h1 id="实现类对象"><a href="#实现类对象" class="headerlink" title="实现类对象"></a>实现类对象</h1><p>前面也提到了，为类对象赋值是在 class 文件生成之后，那么我们再次修改类加载器，是其完成类对象的构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Zclass <span class="title">loadClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zclass clazz;</span><br><span class="line">    <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">        clazz = loadArrayClass(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clazz = loadNonArrayClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每一个 class 都关联一个元类</span></span><br><span class="line">    Zclass jlClassClass = map.get(<span class="string">"java/lang/Class"</span>);</span><br><span class="line">    <span class="keyword">if</span> (jlClassClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clazz.jObject = jlClassClass.newObject();</span><br><span class="line">        clazz.jObject.extra = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在产生 Zclass 之后，获取<code>java/lang/Class</code>的 Zclass——jlClassClass，在利用 jlClassClass 创建 Zobject，此 Zobject 就是之前加载的 Zclass 的类对象，通过对 Zclass 的 jObject 的赋值，那么加载到方法区的类就都有类对象了。</p><p>这里还有个问题：类也是对象，而对象又是类的实例，那么在 JVM 中，究竟是先有类还是先有对象呢？</p><p>在 JVM 中，我们手动触发的是加载<code>java/lang/Class</code>，但是在加载该类的时候，会先加载其父类 <code>java/lang/Object</code>，以及 Class 实现的接口类。那么此时 JVM 的方法区中已经有了这几个类的 Zclass 了，接下来再为这几个类创建类变量，其逻辑在下面的 loadBasicClasses 方法中，该方法是在 ZclassLoader 的构造方法中调用的，也就是说 JVM 启动时就触发这些基本类的加载，因为这些类太重要了，所有其它的子类都需要这些类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBasicClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//经过这一步 load 之后,classMap 中就有 Class 的 Class 了，已经 Object 和 Class 所实现的接口；</span></span><br><span class="line">    Zclass jlClassClass = loadClass(<span class="string">"java/lang/Class"</span>);</span><br><span class="line">    <span class="comment">//接下来对 classMap 中的每一个 Class 都创建一个 jClass;使用 jlClassClass.NewObject()方法;</span></span><br><span class="line">    <span class="comment">// 通过调用 newObject 方法，为每一个 Class 都创建一个元类对象；这样在使用 String.class 时可以直接获取到；</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Zclass&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        Zclass jClass = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (jClass.jObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jClass.jObject = jlClassClass.newObject();</span><br><span class="line">            jClass.jObject.extra = jClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本类型的类"><a href="#基本类型的类" class="headerlink" title="基本类型的类"></a>基本类型的类</h1><p>通过前面的介绍，已经完成了类与类对象的关联，但是 void 和基本类型也有对应的类对象，但其只能通过字面值来访问，eg:</p><ul><li>void.class</li><li>int.class</li></ul><p>就像之前的数组类一样，基本类型的类并没有 class 文件，其也是由 JVM 在运行期间生成的。那么我们就在 JVM 开启时，也手动创建基本类型的类，并将基本类型的类加载到方法区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//加载基本类型的类:void.class;boolean.class;byte.class</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPrimitiveClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : ClassNameHelper.primitiveTypes.entrySet()) &#123;</span><br><span class="line">        String className = entry.getKey();</span><br><span class="line">        loadPrimitiveClass(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载基本类型,和数组类似,也没有对应的 class 文件,只能在运行时创建;基本类型:无超类,也没有实现任何接口</span></span><br><span class="line"><span class="comment">/* 针对基本类型的三点说明：</span></span><br><span class="line"><span class="comment">1. void 和基本类型的类型名字就是：void，int，float 等</span></span><br><span class="line"><span class="comment">2. 基本类型的类没有超类，也没有实现任何接口</span></span><br><span class="line"><span class="comment">3. 非基本类型的类对象是通过 ldc 指令加载到操作数栈中的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPrimitiveClass</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    Zclass clazz = <span class="keyword">new</span> Zclass(AccessFlag.ACC_PUBLIC, className, <span class="keyword">this</span>, <span class="keyword">true</span>,</span><br><span class="line">            <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">new</span> Zclass[]&#123;&#125;);</span><br><span class="line">    clazz.jObject = map.get(<span class="string">"java/lang/Class"</span>).newObject();</span><br><span class="line">    clazz.jObject.extra = clazz;</span><br><span class="line">    map.put(className, clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; primitiveTypes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    primitiveTypes = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    primitiveTypes.put(<span class="string">"void"</span>, <span class="string">"V"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"boolean"</span>, <span class="string">"Z"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"byte"</span>, <span class="string">"B"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"short"</span>, <span class="string">"S"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"int"</span>, <span class="string">"I"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"long"</span>, <span class="string">"J"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"char"</span>, <span class="string">"C"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"float"</span>, <span class="string">"F"</span>);</span><br><span class="line">    primitiveTypes.put(<span class="string">"double"</span>, <span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于非基本类型的类对象，其获取是通过 ldc 指令获取到的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void fClazz() &#123;</span><br><span class="line">    Class c = String.class;</span><br><span class="line">&#125;</span><br><span class="line">//对应的字节码：</span><br><span class="line">0 ldc #4 &lt;java/lang/String&gt;</span><br><span class="line">2 astore_0</span><br><span class="line">3 return</span><br></pre></td></tr></table></figure><p>回想一下，之前介绍的 ldc 指令的功能，是用来加载基本类型，字符串字面值的，所以现在需要扩展 ldc 指令，根据 ldc 操作数得到的运行时常量池中的常量，如果是 ClassRef 类型的，那么就将其 Zclass 的 jObject 对象放到操作数栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LDC</span> <span class="keyword">extends</span> <span class="title">Index8Instruction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        OperandStack operandStack = frame.getOperandStack();</span><br><span class="line">        Zclass clazz = frame.getMethod().getClazz();</span><br><span class="line">        RuntimeConstantInfo runtimeConstant = clazz.getRuntimeConstantPool().getRuntimeConstant(index);</span><br><span class="line">        <span class="keyword">switch</span> (runtimeConstant.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Integer:</span><br><span class="line">                operandStack.pushInt((Integer) runtimeConstant.getValue());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_String:</span><br><span class="line">                Zobject internedStr = StringPool.jString(clazz.getLoader(), (String) runtimeConstant.getValue());</span><br><span class="line">                operandStack.pushRef(internedStr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Class:</span><br><span class="line">                ClassRef classRef = (ClassRef) runtimeConstant.getValue();</span><br><span class="line">                Zobject jObject = classRef.resolvedClass().getjObject();</span><br><span class="line">                operandStack.pushRef(jObject);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// case MethodType, MethodHandle //Java7 中的特性，不在本虚拟机范围内</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，基本类型的类对象，在 java 代码中看起来是通过字面量获取的，但是通过查看其编译后的 class 文件，发现并不是由 ldc 加载到内存的，而是通过 getstatic 指令。因为每个基本类型都有对应的包装类，包装类中都有一个静态常量：TYPE，该字段中保存的就是基本类型的类，我们查看 Integer.java 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">"int"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 getPrimitiveClass 方法是一个 native 的方法，关于 native 的方法的实现，请参考下一节的讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(15)-字符串的实现</title>
      <link href="/2018/01/16/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/01/16/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>Java 程序中最常用的除了基本类型的变量，就数得上字符串了吧，String 在 Java 中并不是基本类型，而是一个引用类型，但是它又很特别，所以特意对 JVM 中的 String 进行讲解。但是不得不承认的是，我的示例中是用 java 来构建的 JVM，起初的目的就是为了快速实现该 JVM，快速的了解 JVM 内部原理，虽然达到了目标，但是在实现该 JVM 内部的一些细节时，总有些不尽人意的地方，这是当初所没想到的，例如本节字符串池的实现，以及后面本地方法的实现上，所写的代码都显得有点挫。不过对于理解 JVM 的内部原理，依然有很大帮助。</p><a id="more"></a><h1 id="字符串在不同位置所使用的编码"><a href="#字符串在不同位置所使用的编码" class="headerlink" title="字符串在不同位置所使用的编码"></a>字符串在不同位置所使用的编码</h1><p>回想整个 JVM 对字符串处理的过程，有两个个关键的地方对字符串进行了处理。下面的讲解中出现了几种编码，如果你对编码不是很了解，请先阅读<a href="https://zachaxy.github.io/2018/01/15/%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">理解各种字符编码</a> ，以便后续内容的理解。</p><h2 id="class-文件中的字符串常量-gt-JVM"><a href="#class-文件中的字符串常量-gt-JVM" class="headerlink" title="class 文件中的字符串常量-&gt;JVM"></a>class 文件中的字符串常量-&gt;JVM</h2><p>class 文件中解析常量池时，在 class 文件中字符串常量是以 <code>MUTF-8</code>编码的形式保存的，我们读取文件时，需要进行额外的处理。</p><p>所谓的额外处理就是说当我们把常量池中<code>ConstantUtf8Info</code>类型的常量加载到内存中，该字符串在 JVM 中用哪种编码来表示。这其实取决于我们的 JVM 是用什么语言来写的，如果我们用 go 语言来实现 JVM，go 语言中的字符串是用<code>utf-8</code>的编码，所以 class 文件中的字符串常量被加载到 JVM 中之后，其表现形式就是 <code>utf-8</code>；而我的 JVM 是用 java 语言来写的，java 语言中字符串是用<code>unicode</code>的编码，所以 class 文件中的字符串常量被加载到 JVM 中之后，其表现形式就是 <code>unicode</code>；无论是<code>utf-8</code>还是<code>unicode</code>，都需要将<code>MUTF-8</code>格式的字节按照目标格式进行转换，才可以被正确的使用，否则就是乱码。如果你用的是另一种语言来写 JVM，而该语言中字符串的编码恰好为<code>MUTF-8</code>，那么你就不用进行转换，直接读取字符串到内存就好了。</p><p>可不幸的是，没有哪种编程语言中字符串是用的<code>MUTF-8</code>编码。这种编码格式也太不常用了，目前也搞不清楚为何 class 文件中要单独用 <code>MUTF-8</code>编码来保存字符串。既然是用 java 实现的 JVM，那么在解析 class 文件中的字符串常量时，我们是进行了编码的转换的：具体代码在<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/classfile/classconstant/ConstantUtf8Info.java" target="_blank" rel="noopener">ConstantUtf8Info.java 中</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantUtf8Info</span> <span class="keyword">extends</span> <span class="title">ConstantInfo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readInfo</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = reader.readUint16();</span><br><span class="line">    <span class="keyword">byte</span>[] data = reader.readBytes(len);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        val = decodeMUTF8(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 MUTF8 转为 UTF8 编码, 根据 java.io.DataInputStream.readUTF（）方法改写。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decodeMUTF8</span><span class="params">(<span class="keyword">byte</span>[] bytearr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chararr, <span class="number">0</span>, chararr_count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JVM-gt-Java-应用程序"><a href="#JVM-gt-Java-应用程序" class="headerlink" title="JVM-&gt;Java 应用程序"></a>JVM-&gt;Java 应用程序</h2><p>上面一步是将 class 文件中常量池的字符串加载到 JVM 中了，但这还不是最终目的，我们最终的目的是在应用程序中使用该字符，一个最简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中，我们的目标就是打印出 s 所代表的“hello”字符串。要能正确的打印出“hello”，首先要明白，我们在代码中写了“hello”这个字符串之后，通过<code>javac</code>的处理，“hello”会存储到 class 文件中了。我们真正用的是 class 文件。那么上一步已经把 class 中的“hello”加载到 JVM 中了，接下来程序要使用真实的 java 程序中，其 String 是用<code>unicode</code>来表示的，因此还需要将 JVM 中的“hello”转换为<code>unicode</code>编码。万幸的是，我们的 JVM 是用 java 来实现的，所以从 JVM 中获取对应的字符串，本身就已经是<code>unicode</code>编码了，无须任何转换就可以实现，但是这也是我所不满的地方，因为真实的 JVM 并不是用 java 来实现的，所以这里无法具体模拟具体转换的细节了（后续可能会考虑用 c++ 对本虚拟机进行重构，那么这个问题自然就遇到了。）</p><p>而底层真正实现这一转换是在下面即将介绍的 ldc 指令中实现的！</p><h1 id="class-文件常量池中的-ConstantStringInfo-常量-VS-ConstantUtf8Info-常量"><a href="#class-文件常量池中的-ConstantStringInfo-常量-VS-ConstantUtf8Info-常量" class="headerlink" title="class 文件常量池中的 ConstantStringInfo 常量 VS ConstantUtf8Info 常量"></a>class 文件常量池中的 ConstantStringInfo 常量 VS ConstantUtf8Info 常量</h1><p>在<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-5-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B8%B8%E9%87%8F%E6%B1%A0/">分析 class 文件中的常量池</a>中，我们介绍了<code>ConstantStringInfo</code>和<code>ConstantUtf8Info</code>这两个常量，但是其区别我们并没有做出说明，放着这一节进行说明，可能更合适。<br>我们知道 ConstantUtf8Info 常量是真正存放字符串的，而 ConstantStringInfo 常量中并没有字符串，而是保存了一个常量池的索引，该索引指向的正是一个 ConstantUtf8Info 常量。不知道你有没有想过为什么会有一个 ConstantStringInfo 的常量这么麻烦，要多一步才能获取到真正的字符串，全部都用 ConstantUtf8Info，省去中间一步的过程，岂不更快？</p><p>这里就涉及到 class 文件中<code>ConstantUtf8Info</code>常量保存的字符串是什么内容了，可以分为两类：</p><ul><li>类名，方法名，变量名，描述符，这些字符串是用来确定加载哪个类，调用哪个方法，使用哪个变量的，是供 JVM 内部使用的。</li><li>在 java 程序中显示声明的 String 类型的变量，是供 java 程序使用的。</li></ul><p>我们写 java 程序其实只关心我们定义的 String 类型的变量，而 String 类型的变量在 class 文件中就是用 <code>ConstantStringInfo</code>常量来表示的。这就解释了为什么都是表示字符串，使用两种常量进行区分。这里主要是把 JVM 使用的字符串和 java 应用程序使用的字符串所区分开。</p><p>两类字符串的赋值时期也是不同的，JVM 内部使用的像类名，方法名，描述符等字符串是在 class 文件转为 Zclass 对象时，进行的赋值。而<code>ConstantStringInfo</code>常量是在 class 文件中的常量池转换为 运行时常量池时进行的转换，此时 RuntimeConstantPool 中的字符串就不在是再通过索引指向另一个常量了，而是保存的真正的常量。下面是常量池转换时，对<code>ConstantStringInfo</code>常量的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ConstantInfo.CONSTANT_String:</span><br><span class="line">    <span class="comment">//在对字符串引用进行转换的时候，转为字符串直接引用</span></span><br><span class="line">    ConstantStringInfo stringInfo = (ConstantStringInfo) classFileConstantInfo;</span><br><span class="line">    <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;String&gt;(stringInfo.getString(), ConstantInfo.CONSTANT_String);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用到了 ConstantStringInfo 的 getString()方法，其源码为：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constantPool.getUtf8(stringIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="String-变量详解"><a href="#String-变量详解" class="headerlink" title="String 变量详解"></a>String 变量详解</h1><p>前面介绍<code>ConstantStringInfo</code>常量时，我说过在 java 代码中定义的 String 类型的变量，都会在 class 文件中保存为<code>ConstantStringInfo</code>常量，但是那个表述并不准确。并不是代码中任何一个 String 类型的变量，都会被保存在 class 文件中的<code>ConstantStringInfo</code>常量中。<br>我们看如下两个 String 类型的变量，已经其对应的字节码</p><ol><li>直接定义字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s0 = <span class="string">"a#4$"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法对应的字节码</span></span><br><span class="line">0 ldc #3 &lt;a#4$&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ol><p>通过查看字节码，我们发现如果是定义的直接字面量”a#4$”的 String 类型的变量，那么该字符串”a#4$”就会在 class 文件中保存为<code>ConstantStringInfo</code>常量，同时在运行时，被转为运行时常量池中的常量，ldc 指令表示将当前运行时常量池中索引为 3 的变量压入操作数栈，随后再将该变量保存到本地变量表索引为 1 的位置。</p><p>结论：String 类型的变量，在赋值时使用的是直接字面量，则会在 class 文件中保存为<code>ConstantStringInfo</code>常量。</p><ol><li>通过字符串连接符<code>+</code>定义字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"a#"</span> + <span class="string">"4$"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法对应的字节码</span></span><br><span class="line">0 ldc #3 &lt;a#4$&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ol><p>通过查看字节码，我们发现用字符串连接符<code>+</code>定义字符串，最终同样是想定义”a#4$”的字符串，其对应的字节码和直接定义”a#4$”是完全一样的，之所以会产生这样的结果，完全是编译器帮我们做的优化。</p><p>结论：使用字符串连接符<code>+</code>定义字符串，如果连接的子串也是直接字面量，那么编译器会帮我们做优化，其结果和定义连接后的字面量的字符串结果是完全一样的。</p><ol><li>通过变量定义字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String tmp = <span class="string">"4$"</span>;</span><br><span class="line">String s2 = <span class="string">"a#"</span> + tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法对应的字节码</span></span><br><span class="line"> 0 ldc #3 &lt;4$&gt;</span><br><span class="line"> <span class="number">2</span> astore_1</span><br><span class="line"> 3 new #4 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">6</span> dup</span><br><span class="line"> 7 invokespecial #5 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">10 ldc #6 &lt;a#&gt;</span><br><span class="line">12 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">22</span> astore_2</span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li></ol><p>通过查看字节码，我们同样是定义一个最终字符串为”a#4$”的变量，但是使用字符串连接符时，一个子串使用变量替代了之前的直接字面量，发现字节码有很大的不同，同样是编译器在背后做了手脚，其发现如果一个通过<code>+</code>定义的字符串中，如果子串有变量，那么编译器会偷偷的产生一个 StringBuilder 类，而<code>+</code>符号也会被转换为 StringBuilder 的 append 方法。最终拼接好的字符串是刚刚的 StringBuilder 调用了其 toString 方法，而查看 StringBuilder 的 toString 方法，其内部是重新创建了一个 String 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：使用字符串连接符<code>+</code>定义字符串，如果连接的子串中包含变量，那么该字符串不会在 class 文件中保存为<code>ConstantStringInfo</code>常量，而是通过 StringBuilder 在方法运行时动态生成的一个全新的 String 变量。</p><h1 id="字符串池-StringPool"><a href="#字符串池-StringPool" class="headerlink" title="字符串池 StringPool"></a>字符串池 StringPool</h1><p>通过上述三种定义字符串的创建过程，我们可以发现一个现象，虽然最终字面量是一样的，但是如果用<code>==</code>比较结果可能是不一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"a#4$"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"a#"</span> + <span class="string">"4$"</span>;</span><br><span class="line"></span><br><span class="line">String tmp = <span class="string">"4$"</span>;</span><br><span class="line">String s3 = <span class="string">"a#"</span> + tmp;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3.intern());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>通过该程序的结果，我们可以发现 s1 和 s2 都是直接从运行时常量池相同的位置获取的值，所以其用 <code>==</code>比较得到的结果是 true，因为本来就是同一个对象。但 s3 并不是从运行时常量池直接取的值，而是在方法内部通过 StringBuilder 的 toString 方法获取的一个新的 String 对象，所以和 s1 比较，自然得到的结果就是 false 了。</p><p>这里要注意的是：在运行时常量池保存的字符串类型的常量，其实保存的并不是字符串本身，而是一个 key ！这个 key 是 JVM 中 StringPool 的一个 key，由该 key 对应的 value 得到的值才是真正 Java 中 String 变量。</p><p>这样设计的原因是：String 是一个类，该类中保存了字符串的值，本质上是一个 char 类型的数组，但是 String 和 char[] 又不是对等的，char[] 是 String 的主要组成部分，但是 String 毕竟是一个类，其内部还有其它的成员和方法来操作自身的 char[]。同时 String 又是一个不可变类，也就是说如果一个 String 类型的变量确定之后，其内部的 char[] 的元素是不可以改变的，是不可变的(只读的)，同时 String 类型的变量在程序中又很常用，所以在 JVM 中定义了一块内存，叫做字符串池——StringPool。注意这个 StringPool 是整个应用程序所共享的，里面存放的就是在 class 文件中被定义为<code>ConstantStringInfo</code>常量所对应的真正的字符串，而在运行时常量池中保存的所谓的字符串常量，其实只是 StringPool 的一个引用。这样设计的目的，可以达到一个应用中所有相同的字符串常量是唯一的，从而达到节约 JVM 内存空间的目的。</p><p>观察字符串赋值的语句可以发现，在上例的(1)和(2)中，都是使用 ldc 指令，将运行时常量池中获取到字符串常量，注意：此时从运行时常量池获取到的字符串为 JVM 中的字符串，而不是 java 应用程序中的编码，真正实现这一转换过程的是在 ldc 命令中进行的转换，具体实现过程可参考 <a href="https://github.com/zachaxy/JVM/blob/master/Java/src/instructions/constants/LDC.java" target="_blank" rel="noopener">LDC.java</a> </p><p>这里简述一下 StringPool 的实现过程，其内部是一个 HashMap，key 为 JVM 中的字符串，value 为 java 引用程序中可是使用的 String，注意这个 String 是指包含了 char[] 的一个 Object，而不单单是 char[]。如果 key 相同，那么得到的 Object 就是同一个。当然，如果当前 map 中不存在 key，那么就添加该 (key,value)对。<br>这也就解释了为什么上例中 s1==s2。同时 s3 对应的 Object 并不不是从 StringPool 中获取的，而是在当前 Frame 中重新 new 的一个对象。所以 s1!=s3。</p><p>同时注意到 <code>s1==s3.intern()</code>。String 中有一个 intern 方法，该方法的作用是以 s3 的字面量为 key，从 StringPool 中寻找对应的值，如果不存在则添加，并返回对应的 object。因为 s3 的字面量和 s1 是相同的，所以从 StringPool 中返回值的话，得到的 object 和 s1 是一样的。</p><p>具体实现请参考 <a href="https://github.com/zachaxy/JVM/blob/master/Java/src/runtimedata/heap/StringPool.java" target="_blank" rel="noopener">StringPool.java</a><br>但是这里的实现，并不如意。原因还是本 JVM 是采用 java 实现的，导致字符串在 JVM 中的编码和 java 应用程序中的编码是一样的，这一个转换有些多此一举，但是为了模拟 StringPool 的功能，还是添加了对应的代码。同时要注意，String 在 JVM 中也是一个 Zobject，通过 key 获取到的不应该是一个 java 中的 String，而应该是 JVM 中的 Zobject。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解各种字符编码</title>
      <link href="/2018/01/15/%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2018/01/15/%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>我们平时使用文本编辑器像 sublime，notepad++ 等，或者使用 IDE 写代码，都会发现其右下角有一个<code>Encoding</code>的标签，其值为<code>Unicode</code>,<code>UTF-8</code>,<code>GBK2312</code>等。那么这些编码有什么区别呢？要说清楚不同编码之间的区别和联系，就要从计算机的发展史来讲起了，本文设计到的关键内容如下：</p><ul><li>ASCII</li><li>GRB2312</li><li>GBK</li><li>ANSI</li><li>Unicode</li><li>UTF-8</li></ul><a id="more"></a><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>计算机是美国人发明的，英语单词使用 26 个字母组合就可以表达了，在加上其对应的大写字母，<code>0~9</code>的数组，以及一些运算符号，只需 100 个左右的字符就就可以完全的表达说英语的国家的需求了，所以美国在设计的时候使用了 1 个 byte，也就是 8bit 的后 7 位，最高位恒为 0，这样就可以用<code>0~127</code>的序号与 128 个字符一一对应了，这就是标准的 ASCII(American Standard Code for Information Interchange，美国信息交换标准代码)</p><p>本来使用标准的 ASCII 字符编码就已经能够满足美国人的需求了。但是随着计算机的普及，欧洲的一些发达国家也开始使用计算机了。这就出现了一个问题，像德国，法国等这些国家的文字很多字符是 ASCII 中没有的，而像基本的数字，标点符号等这些通用的，又已经存在于 ASCII 中，也是他们所需要的，这时有人想出了一个方法，就是扩展 ASCII，因为美国人只使用了一个字节的后 7 位，如果现在把最高位也用上，那么可表示的范围就从 0<del>127 扩展为 0</del>255 了，整整多出了 128 个字符。而之前<code>0~127</code>依然保持原来的含义，在<code>128~255</code>中，加入这些国家的所需的字符，就可以满足他们的需求了。但是注意：此时扩展后的 ASCII 已经不再是标准 ASCII 字符集了，而称为扩展 ASCII 字符集。扩展 ASCII 字符集并不是一个国际通用的标准，而是一个各自国家使用的标准，比如：编码为 130 的字符，在法语编码中代表了<code>é</code>，在希伯来语编码中却代表了字母<code>ג</code>等。当然<code>0~127</code>所表示的含义还是标准 ASCII 中定义的。只不过扩展 ASCII 编码成为了当时一些国家自己的标准。在一段时间内，大家都各自做各自的工作，相安无事。</p><h1 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h1><p>终于，计算机普及到中国了，我们中国人都是用汉字来交流的，而不是使用拼音，所以我们也需要一套自己的编码机制。但是此时标准的 ASCII 编码完全不能满足我们的需求，因为没有汉字。当然已有的扩展 ASCII 字符集也没有哪一个可以满足我们的需求。如果我们也学西方国家一样，扩展 ASCII 字符集，形成我们自己的字符集可以吗？不行。因为汉字实在太多了，即使扩展 ASCII 编码，也只是多出来 128 个汉字，所以这个方案也走不通。</p><p>注意，我们此时面临的情况是：刚刚引入了 PC，人们需要在电脑上使用中文交流，而不是英文。同时在标准 ASCII 中定义的字符，因为太基础了，所以这些本不属于汉字的符号，我们也要保留下来。带着这个需求，聪明的中国人想出了这样的解决方法：读取文件时一个字符一个字符的判断，如果该字符的值小于 128，那么表明该字符是标准 ASCII 中 的字符，直接显示即可。但是如果读取到第一个大于 128 的字符，那么我们此时不能直接翻译(也翻译不了，此时表明一个汉字的前半个字节)，要再读入下一个字符（注意，汉字的后半个字节也是大于 128 的，这就是 GB2312 定制的标准），将此时读到的这两个字符用来表示一个汉字（前一个表示高位，后一个表示低位，所凑成的数字，我们做一个一对一的映射，使用该数字表示一个汉字），这样我们就能表示大约 6000 个汉字了，这在当时可是极大的解决了人们的需求，因为即便中文汉字多达数万之很多，但是我们平时交流所常用的汉字也就几千个而已。我们把这种编码称为 GB2312。</p><p>注意：在 GB2312 中，如果表示的是一个汉字，使用两个字节表示，而且高字节的范围是：<code>A1~F7</code>,低字节的范围是： <code>A1~FE</code>。</p><h1 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h1><p>但是，随着计算机在中国的普及，使用计算机的人也越来越多，又出现了一个问题，之前用 GB2312 满足不了人们的使用需求了，因为有些很偏的姓氏并不在 GB2312 编码中，这就尴尬了，如果连自己的名字都显示不了，当然是不行的。所以需要一个包含更多汉字的编码方式。</p><p>此时我们的需求是：包含尽可能更多的汉字，同时还要完全兼容 GB23121(因为 GB2312 已经开始使用了，如果完全抛弃 GB2312，推出一个全新的编码，那么在新电脑上打开别人之前用 GB2312 编码的文件，显示的就是乱码！)</p><p>带着这个需求，我们推出了 GBK 编码：照旧一个字符一个字符的判断，如果当前是一个小于 128 的，还是按照标准 ASCII 来显示。如果此时读到一个大于 128 的字符，那么肯定是一个汉字了，但是此时不再想像 GB2312 那样，要求低字节也大于 128 了，从而扩充了编码范围，同时也实现了上面的需求。</p><p>此时的 GBK，如果表示汉字，同样是两个字节，高字节的范围是： <code>81~FE</code>，低字节的范围是： <code>40~FE</code>。</p><h1 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h1><p>随着计算机在整个世界的普及，同时每个国家的文字都有各自的特点，所以各个国家也像中国那样，指定自己国家的编码方式，例如日本也定制了自己的编码方式：Shift_JIS 编码。</p><p>我们使用的计算机都是要安装操作系统的，以微软的 Windows 操作系统为例，相信大家在安装操作系统时，都会遇到选择语言那一栏，例如我们中国人安装时一般选择简体中文，这样我们进入界面后看到的就是中文版本。而 ANSI 编码就是在这时候确定的，具体来说，ANSI 并不是一个具体的编码，而是一种代指，如果你的操作系统选择的语言是简体中文，那么在该系统中，ANSI 所代表的就是 GBK 编码，如果你选择的语言环境是日文，那么 ANSI 代表的就是 Shift_JIS 编码。</p><p>而且 ANSI 这个词值在 Windows 系统中出现，Mac 上并没有这种叫法，如果在 Windows 上一个文件被保存为 ANSI 编码，将该文件发送到 Mac 上，打开该文件时，就要使用该文件真正的编码方式，例如中文的 windows 系统，就使用 GBK 编码在 Mac 上打开该文件。</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>像之前所描述的，各个国家都有了能显示自己语言的编码方式，如果一个国家不与外界交流(像朝鲜)，自己关起门来玩，是完全没有问题的。但是在全球化的背景下，一个团队可能分散在世界的各个国家，他们使用的语言是不同的，但又需要交流，如果还按照其所在国家的编码方式相互传送文件，那么对方收到后，就必须知道发送方所发文件的编码格式，只有使用正确的编码打开文件才能看到正确的内容，否则打开一定是乱码。所以此时急切需要一个全球统一的编码方式，该编码要包含这个世界上所有的文字！<br>于是一种包含了世界各地绝大部分文字字符的通用字符集就应运而生了——Unicode 字符集，也叫做万国码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 的最新版本包括一百多万个字符。</p><p>同时：Unicode 是兼容标准 ASCII 编码的，也就是说 Unicode 编码的<code>0~127</code>对应的字符依然和标准 ASCII 是一样的！</p><p>但是要注意的是：Unicode 只是一个字符集，它只是定义了一百多万个一一对应的映射关系。哪个字符使用哪个编码都是唯一确定的。但是其并没有规定字符所对应的编码的二进制数据如何保存在文件中。eg：汉字<code>张</code>的 Unicode 是十六进制数 0x5F20，转换成二进制数为：101111100100000，有 15 位，但是并没有规定这个汉字是保存为 2 个字节，还是 3 个字节高位补零，这些在 Unicode 中都没有定义。</p><p>如果直接按照 Unicode 对应的最短字节来保存，像上例中 15 位用 2byte 保存，这样可以吗？不可以，因为无法区分两个字符的边界，因为有的字的编码可能需要 20 位，那就需要 3 个字节来保存，从不同的字节处截断并解析，就可能得到不同的显示结果。</p><p>而我们在 Windows 中使用记事本这样的文字编辑器保存时，可选的编码格式中却有 Unicode ，不是说 Unicdoe 没有规定存储形式吗，那为什么还要能保存为 Unicode 的形式，这里说的保存为 Unicode，其保存形式是 <code>UCS-2</code> 编码方式（即直接用两个字节存入字符的 Unicode 码，不足 16bit 的，高位补零）。使用两个字节很明显是无法表示所有国家的语言的，这只是 Unicode 的一个子集，其所表示字符是有限的，万幸的是在中文环境中保存为 Unicode 编码方式(其实是 USC-2 编码)，是可以表示大多数中文的。</p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p>上述 Unicode 编码已经确定了所有字符的一个映射关系，但是并没有规定其存储形式，因此出现了众多基于 Unicode 编码的存储实现方案，例如 UTF-8,UTF-16,UTF-32 等。其中使用最广房的还是 UTF-8。<br><strong>这里再强调一遍：UTF-8 是 Unicode 的一种实现方式！</strong></p><p>UTF-8 的定义的存储规则不是简单的存储对应的二进制数据，高位补零的形式，而是将二进制数据拆分到不同的字节中，其具体定义为：</p><ol><li>对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li><li>对于 n 字节的符号（n &gt; 1），第一个字节的前 n 位都设为 1，第 n + 1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li><li>针对上一点中未提及的 bit，将字符的 Unicode 二进制从低位向高位取出二进制数字，每次取 6 位，从后面的字节中填充，直到上面定义的第一个字节中，如果不能刚好填满，则在 1··0 后补 0。</li></ol><table><thead><tr><th>Unicode 符号范围</th><th>UTF-8 编码方式</th></tr></thead><tbody><tr><td>0000 0000-0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080-0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800-0000 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>那么在解读 UTF-8 时，也非常简单，如果一个字节的第一位是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。</p><p>如果上面的描述不是很明白的话，接下来补充一个例子，就能直观的理解 UTF-8 编码的实现了。<br>这里依然以<code>张</code>为例，其 Unicode 对应的 16 进制数为：0x5F20，二进制数位是：101111100100000<br>参考上面的表格，根据其所在的范围，发现其需要 3 个字节来存储，那么其对应格式是<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从<code>张</code>的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，<code>张</code>的 UTF-8 编码是<code>11100101 10111100 10100000</code>，转换成十六进制就是 0x5F20</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从计算机的普及历史，阐述了各个国家因为要表达自己语言的需求，而各自定义自己的编码。随后又在不同文字国家之间的的交流中出现了互不兼容的情况，最终生成了一个统一个编码 Unicode。并且目前使用最广泛的是 UTF-8 的编码，其实 Unicode 编码的具体实现方案。其实，扩展 ASCII，GB2312，GBK，Unicode。。。不管哪种编码方案，其都是兼容标准 ASCII 编码的，因为其定义的大多数字符都是世界通用的。</p><p>同时，文件存储在硬盘中，我们看到的是真实的文字，但是实际存储在硬盘中的都是 0 和 1，相同的文字用不同的编码解析，所显示的内容完全不一样，当然很多时候是乱码。可是有时候我们用文本编辑器打开一个文件，并没有指定打开的编码方式，很多时候也能正确的显示内容，难道这么凑巧，这些文件都恰好是我们的文本编辑器默认打开文件的格式吗？其实并不是凑巧，而是我们所保存的文件，其真正存储的二进制形式，在前面几个字节都有标识位，来标识这是什么编码，文字编辑器在读取文件时，会先查看其开头的标示字节，根据不同的标示，使用对应的编码格式进行解码。<br>eg:</p><ul><li>UTF-8 文件开头的标示字节为：EF BB BF</li><li>Unicode 文件(其实为 UCS-2)，开头的标示字节为：FF FE，这表明是小端存储，首先明确这是两字节的 Unicode 精简版的存储，按照正常的思维，两个字节就按照顺序存储就可以了，但是小端是对每一个字符所对应的两个字节，是按照相反的顺序来存储的，例如我们用记事本中输入<code>张</code>字，然后保存为 Unicode 编码。那么查看其文件中的二进制，发现其所包含的内容为：FF FE 20 5F，前两个字节就表示是 Unicode 的小端存储，后两个字节表示的是一个汉字，但是要反过来才能表示真正的汉字，因为<code>张</code> 的 Unicode 16 进制为：0x5F20。Unicode 默认是小端存储的。</li><li>既然有小端存储，那么就有对应的大端存储，我们同样可以将文件保存为：<code>Unicode big endian</code>，这样的话，文件开头的标示符就是：FE FF，同样保存一个 <code>张</code> 的汉字，那么文件实际的内容为：FE FF 5F 20</li><li>而对于像 GBK，GB2312 这样的文件，其开头是没有标示头的，直接保存的就是文件的内容。</li></ul><p>在开发中，建议各个团队都使用 UTF-8 编码，这样在发送数据，接收数据时，免去解决乱码的时间，IDE 都设置为 UTF-8 应该开发人员的一个共识吧。同时常用的文本编辑器(sublime，notepad，Atom 等)最好也设置为 UTF-8。</p><p>GBK 编码存在的必要性：前面说了那么多 UTF-8 编码解决了乱码的问题，使得各个国家之间的交流无障碍，那为什么我们看到好多文件还是以 GBK 的形式存在呢？我想是因为 UTF-8 编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 编码也可以，主要还是面向非开发人员吧。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">Unicode 和 UTF-8 有何区别？</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 理解计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(14)-数组的实现</title>
      <link href="/2018/01/12/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-14-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/01/12/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-14-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>前面介绍了<a href="https://zachaxy.github.io/2018/01/04/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">类加载器的实现</a>，目前我们已经可以加载普通的类，并创建该类的对象了，但是目前我们的 JVM 还不支持数组。数组类虽然也是类，但是其加载方式和之前所讲的通过 class 文件的形式加载是完全不同的，本节将介绍 JVM 中数组的实现，并完善我们的类加载器，使其可以加载数组。</p><a id="more"></a><h1 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h1><ul><li>基本数组类型：数组中的元素类型是基本类型</li><li>引用数组类型：数组中的元素类型是引用类型</li></ul><p>数组类也是类，其父类同样也是 Object，但是其又和普通的类有一些差异：</p><ul><li>普通的类从 class 文件中加载,而数组类则是 JVM 在运行时生成的.</li><li>创建普通对象和创建数组所用的指令是不同的;前者用 new,后者用 newarray 等指令。</li><li>访问对象的成员变量和数组的元素不同，前者使用的是 getfield 指令，后者使用的是 aload 指令。</li><li>数组的类名和其它类也不同，数组的类名是用左括号+数组元素的类型描述符。同时，数组的类名和数组的类型描述符是一样的。eg：int[]的类名为：[I；int[][] 的类名为：[[I；String[][] 的类名为： [[java/lang/String；</li></ul><h1 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h1><p>普通类和数组类的创建方式不同,但是其归根结底还是 Object 的子类。所以要在之前的 Zclass 中添加额外的针对创建数组 class 的方法。同样由数组的 class 创建的数组 Object 和普通 Object 不同。所以还要在 Object 中添加额外的方法来创建数组 Object。可是不管数组类和普通类有什么区别，整体的流程都是一样的，凡是创建对象,都是使用 newXXX 的指令,通过对应的指令先创建其对应的 class,然后用该 class 来创建 object。<br>接下来依次从加载数组类，然后根据数组类创建数组对象的流程，讲解数组的创建过程。</p><h2 id="加载数组类"><a href="#加载数组类" class="headerlink" title="加载数组类"></a>加载数组类</h2><p>加载数组类和加载普通类的时机都是一样的，如果在 java 代码中显式的 new 了一个数组，那么势必会触发对应数组类的加载，而创建数组类的指令有三个：</p><ul><li>newarray：用于创建基本类型的一维数组，其操作数为一字节，该字节用来表示对应的基本类型</li><li>anewarray：用于创建引用类型的一维数组，其操作数为 2 字节，指向运行时常量池的一个类引用，该引用的类型就是引用类型数组中的元素类型</li><li>multianewarray：用于创建多维数组，其操作数为 3 字节，前两个字节同 anewarray，后一个字节用来表示多维数组的纬度，由此也可以看出我们在 Java 中创建多维数组最大纬度为 255。</li></ul><p>这里以 newarray 指令为例，查看其数组类加载的过程：<br>前面也说了 newarray 所创建的基本类型在指令后的字节中，JVM 为基本类型设置了对应的值，我们可以根据值来加载对应的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_BOOLEAN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_CHAR = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_FLOAT = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_DOUBLE = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_BYTE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_SHORT = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_INT = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_LONG = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.index) &#123;</span><br><span class="line">    <span class="keyword">case</span> AT_BOOLEAN:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[Z"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_BYTE:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[B"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_CHAR:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[C"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_SHORT:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[S"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_INT:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[I"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_LONG:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[J"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_FLOAT:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[F"</span>);</span><br><span class="line">    <span class="keyword">case</span> AT_DOUBLE:</span><br><span class="line">        <span class="keyword">return</span> loader.loadClass(<span class="string">"[D"</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Invalid atype!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用类加载器去加载对应的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Zclass <span class="title">loadClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zclass clazz;</span><br><span class="line">    <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">        clazz = loadArrayClass(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clazz = loadNonArrayClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建数组类"><a href="#创建数组类" class="headerlink" title="创建数组类"></a>创建数组类</h2><p>在加载对应的基本类型数组的时候，并不是从字节码文件中读取，然后转换为对应的 Class 对象，而是根据基本数组类型，直接创建对应的 class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Zclass <span class="title">loadArrayClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Zclass clazz = <span class="keyword">new</span> Zclass(AccessFlag.ACC_PUBLIC, name, <span class="keyword">this</span>, <span class="keyword">true</span>,</span><br><span class="line">            loadClass(<span class="string">"java/lang/Object"</span>),</span><br><span class="line">            <span class="keyword">new</span> Zclass[]&#123;loadClass(<span class="string">"java/lang/Cloneable"</span>), loadClass(<span class="string">"java/io/Serializable"</span>)&#125;);</span><br><span class="line">    map.put(name, clazz);</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Zclass ，我们之前创建 class 对象都是根据 class 文件，通过传入一个 ClassFile 对象构造 Class 对象的，而对于数组类型，我们为其添加一个构造方法，用来直接创建数组类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Zclass</span><span class="params">(<span class="keyword">int</span> accessFlags, String thisClassName, ZclassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">boolean</span> initStarted, Zclass superClass, Zclass[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.accessFlags = accessFlags;</span><br><span class="line">    <span class="keyword">this</span>.thisClassName = thisClassName;</span><br><span class="line">    <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    <span class="keyword">this</span>.initStarted = initStarted;</span><br><span class="line">    <span class="keyword">this</span>.superClass = superClass;</span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>上面创建的数组类型的 class 对象，那么接下来就该利用该 class 对象创建数组对象了，在 Zclass.java 中添加 newArray 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Zobject <span class="title">newArray</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArray()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not array class: "</span> + thisClassName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (thisClassName) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[Z"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[B"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[C"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">char</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[S"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">short</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[I"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">int</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[J"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">long</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[F"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">float</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"[D"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="keyword">double</span>[count], <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Zobject(<span class="keyword">this</span>, <span class="keyword">new</span> Zobject[count], <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法需要得到数组的大小，在 java 中所创建的数组时是需要确定其具体大小的，该值保存在执行创建数组的 frame 中的操作数栈中。同时在创建对象时，根据 thisClassName 确定具体的类型，然后创建具体的 obj。</p><p>同时注意到我们在创建 obj 对象时，是将创建好的数组赋值给了 Zobject 的 data 成员。该 data 成员在还没有介绍数组之前，是一个 slot[] 类型,用来保存非数组对象中的非静态成员变量,包含父类+ 自己的，现在引入了数组类型，需要将 Zobject 中的 data 类型做一个修改，这里直接改为 Object 类型，就可以做到既能盛放 slot，又能盛放数组对象。只不过在对普通对象和数组对象做元素存取的时候还要再进行强制类型转换，才能得到正确的值。其实我们可以这样理解，数组对象也是一个对象，只不过其内部的成员变量就是其数组的所有元素而已。</p><h2 id="创建基本类型数组的指令-newarray-执行过程"><a href="#创建基本类型数组的指令-newarray-执行过程" class="headerlink" title="创建基本类型数组的指令 newarray 执行过程"></a>创建基本类型数组的指令 newarray 执行过程</h2><p>其实前面已经将基本类型数组对象的创建过程进行了一次描述了，这里只是贴出该指令执行的代码，作为回顾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NEW_ARRAY</span> <span class="keyword">extends</span> <span class="title">Index8Instruction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Array Type  atype</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_BOOLEAN = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_CHAR = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_FLOAT = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_DOUBLE = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_BYTE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_SHORT = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_INT = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_LONG = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        OperandStack operandStack = frame.getOperandStack();</span><br><span class="line">        <span class="comment">//从栈中获取数组的大小</span></span><br><span class="line">        <span class="keyword">int</span> count = operandStack.popInt();</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NegativeArraySizeException(<span class="string">""</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">        ZclassLoader loader = frame.getMethod().getClazz().getLoader();</span><br><span class="line">        Zclass arrClazz = getPrimitiveArrayClass(loader);</span><br><span class="line">        Zobject arr = arrClazz.newArray(count);</span><br><span class="line">        operandStack.pushRef(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取基本类型数组的 class;如果没有加载过,需要加载进 JVM</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Zclass <span class="title">getPrimitiveArrayClass</span><span class="params">(ZclassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从字节码中获取到的 index 表明的是哪种类型的数组</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.index) &#123;</span><br><span class="line">            <span class="keyword">case</span> AT_BOOLEAN:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[Z"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_BYTE:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[B"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_CHAR:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[C"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_SHORT:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[S"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_INT:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[I"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_LONG:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[J"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_FLOAT:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[F"</span>);</span><br><span class="line">            <span class="keyword">case</span> AT_DOUBLE:</span><br><span class="line">                <span class="keyword">return</span> loader.loadClass(<span class="string">"[D"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Invalid atype!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完善数组相关的其它指令"><a href="#完善数组相关的其它指令" class="headerlink" title="完善数组相关的其它指令"></a>完善数组相关的其它指令</h1><p>前面介绍了创建基本类型的数组指令 newarray，其实还有其它和数组相关的指令，这里做一个概述，具体实现请参考<a href="https://github.com/zachaxy/JVM/tree/master/Java/src/instructions/references" target="_blank" rel="noopener">instructions/references 包下的源码</a></p><h2 id="anewarray"><a href="#anewarray" class="headerlink" title="anewarray"></a>anewarray</h2><p>创建引用类型的一维数组。其过程和创建基本类型的一维数组是类似的，只不过该数组的元素是引用类型，所以我们要先获取到数组元素的引用类型。由 anewarray 指令后的操作数获取，其操作数为 2 字节，指向运行时常量池的一个类引用，该引用的类型就是引用类型数组中的元素类型。我们在获取到该类引用之后，先将其转换为直接引用(若还为加载过该类，则需要先加载到方法区)。接下来根据类型名，创建其一维数组名，eg：数组元素为 String，那么其一维数组类型名就是：[java/lang/String；接下来创建引用类型的一维数组的过程就和创建基本类型的一维数组过程就一样了。</p><h2 id="arraylength"><a href="#arraylength" class="headerlink" title="arraylength"></a>arraylength</h2><p>获取数组的长度，在 java 中也是很常用的，其实现也很简单，我们之间在创建数组对象的时候，将数组放到了 Zobject 的 data 变量中，我们可以通过 data 的 class 来获取原本数组类型名，根据类型名将 data 进行相应的类型转换，得到具体的数组之后，在获取其长度。</p><h2 id="aload-和-astore"><a href="#aload-和-astore" class="headerlink" title="aload 和 astore"></a><t>aload 和 <t>astore</t></t></h2><p>分别用来读取和写入数组元素，功能和之前介绍的 load，store 指令相似，只不过需要从操作数栈获取数组的索引，然后在对数组中对应的操作。比较简单，直接看代码，这里不再赘述了。<br>其实现分别在<code>instructions.loads.loadxarr</code>包下和<code>instructions.stores.storexarr</code>包下。</p><h2 id="multianewarray"><a href="#multianewarray" class="headerlink" title="multianewarray"></a>multianewarray</h2><p>这里以<code>new int[3][4][5]</code>为例，讲解多维数组的创建过程，具体实现过程，请参考<a href="https://github.com/zachaxy/JVM/tree/master/Java/src/instructions/references/MULTI_ANEW_ARRAY.java" target="_blank" rel="noopener">MULTI_ANEW_ARRAY.java</a><br>代码 <code>int[][][] arr = new int[3][4][5];</code><br>其产生的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iconst_3</span><br><span class="line">iconst_4</span><br><span class="line">iconst_5</span><br><span class="line">multianewarray #5 ([[[I,3)</span><br></pre></td></tr></table></figure><p>首先将三维数组各个维度压入操作数栈，栈顶向下一次为： 5，4，3，然后执行 multianewarray 指令，其操作数有两个，第一个 index 表示运行时常量池的类符号引用，其类名为[[[I<br>接着获取第二个操作数 3，表明这是一个三维数组。<br>接下来开始执行 multianewarray 指令：首先将获取到的类符号引用转为直接引用：转换依然是用 classloader，因为是数组类，所以不用从 class 文件中读取字节流，而是直接创建一个 class，该 class 将类名指定为 [[[I，这一创建 Class 对象的过程和创建一维数组是一样的；接下来依次从操作数栈中弹出三个整数，表示该多维数组每一维的大小；然后开始创建该多维数组的对象</p><p>多维数组对象的创建过程：此时拿到的类名是：[[[I，各个维的大小是 3，4，5；<br>首先利用数组类[[[I,创建第一维 arr1 ，大小为 3，（多维数组对外表现的就是一维数组，只不过该数组中的元素依然是数组。）<br>接下来创建 arr1 中的每一个元素，其元素也是数组，我们称之为第 2 维，arr2（arr1 中的三个元素都是 arr2）<br>arr2 此时的类型为 [[I，依然需要用 classloader 进行加载，然后创建；<br>接下来创建 arr2 中的每一个元素，其元素还是数组，我们称之为第 3 维，arr3（arr2 中的三个元素都是 arr3）<br>arr3 此时的类型为 [I,依然需要用 classloader 进行加载，然后创建；<br>最终将创建好的 arr1，压入操作数栈，结束！</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>本节的测试代码在(TestNewArray09.java 中)[<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestNewArray09.java]。" target="_blank" rel="noopener">https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestNewArray09.java]。</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNI开发流程</title>
      <link href="/2018/01/10/JNI%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/01/10/JNI%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面已经介绍了在 <a href="https://zachaxy.github.io/2018/01/10/JNI%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/">Windows 上快速的搭建 JNI 开发环境</a>本节将会实现一个简单的 hello world 版的程序，目的是掌握 JNI 开发的流程，具体的实现细节会在后续进行介绍。</p></blockquote><h1 id="JNI-开发流程梳理："><a href="#JNI-开发流程梳理：" class="headerlink" title="JNI 开发流程梳理："></a>JNI 开发流程梳理：</h1><ol><li>在 java 文件，这里的 java 文件我们以 HelloJNI.java 举例。在其中定义 native 方法</li><li>使用 javah HelloJNI 命令生成 HelloJNI.h 头文件(注意该命令后只跟文件名，不要带.java 后缀)</li><li>使用 codeblocks 创建动态链接库工程，并将 HelloJNI.h 添加到该工程 </li><li>实现 HelloJNI.h 中声明的方法</li><li>使用 codeblocks build 该工程，得到 HelloJNI.dll 动态链接库</li><li>将 HelloJNI.dll 拷贝到 java 工程中，直接使用即可。</li></ol><a id="more"></a><p>接下来对每一个步骤进行详细介绍。</p><h1 id="定义-native-方法"><a href="#定义-native-方法" class="headerlink" title="定义 native 方法"></a>定义 native 方法</h1><p>首先我们创建一个 Java 工程，并创建一个 java 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">sGetStr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只需定义方法即可，和普通方法类似，只不过前面多了一个 native 的关键字。可以看到我们定义了两个方法，一个非静态方法，一个静态方法，二者都是从 c 代码中获取一个字符串。</p><h1 id="生成-HelloJNI-h-头文件"><a href="#生成-HelloJNI-h-头文件" class="headerlink" title="生成 HelloJNI.h 头文件"></a>生成 HelloJNI.h 头文件</h1><p>进入命令行，定位到 HelloJNI.java 所在的路径，使用<code>javah HelloJNI</code>命令生成 HelloJNI.h 头文件(注意该命令后只跟文件名，不要带.java 后缀)</p><p>其实这个 javah 命令会读取目标文件，这里就是 HelloJNI.java，然后扫名里面的 native 方法，拿到 native 方法的签名，而对于其它非 native 的方法，javah 则不关心。</p><h1 id="使用-codeblocks-创建动态链接库工程"><a href="#使用-codeblocks-创建动态链接库工程" class="headerlink" title="使用 codeblocks 创建动态链接库工程"></a>使用 codeblocks 创建动态链接库工程</h1><p>打开 codeblocks，创建工程，选择工程类型为：Dynamic Link Library，然后起一个工程名，这个名字随意，但是最后生成的 dll 文件的名字是和工程名是一样的。</p><p>新创建的工程会默认有一个 main.cpp 和 main.h 文件，但我们用不到，忽略它或者删除它。<br>然后把上一步得到的 HelloJNI.h 文件拷贝到当前工程下，不过只拷贝当前工程的目录下，当前工程也不能识别，我们还需要在当前工程右键，add files，选择我们刚刚复制过来的 HelloJNI.h 文件，这样才会被 codeblocks 纳入到当前工程。</p><p>但是此时还要再做一步，注意看生成的 HelloJNI.h 文件的内容是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class HelloJNI */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_HelloJNI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_HelloJNI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJNI</span></span><br><span class="line"><span class="comment"> * Method:    getStr</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_HelloJNI_getStr</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJNI</span></span><br><span class="line"><span class="comment"> * Method:    sGetStr</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_HelloJNI_sGetStr</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到其首先就包含了<code>jni.h</code>文件，如果我们不做任何配置的话，codeblocks 在编译代码时是找不到这个头文件的。那么这个<code>jni.h</code>文件在哪里呢？</p><p>首先明确一点：你的 windows 上安装了 JDK，因为<code>jni.h</code>就在 JDK 的安装路径的 include 目录下，eg：我的电脑上的路径为：<code>D:\Program Files\Java\jdk1.8.0_20\include\</code>，同时<code>jni.h</code> 文件中还引入了 <code>jni_md.h</code> 文件，所以还要找到 <code>jni_md.h</code> 文件，其位于本机 jdk 的 <code>include\win32</code> 文件夹下：<code>D:\Program Files\Java\jdk1.8.0_20\include\win32\</code></p><p>明确了要准备的两个 h 文件的路径，接下来就要让 codeblocks 在编译时能找到对应的头文件。</p><p>我们将这两个头文件都拷贝到当前动态链接库工程的代码文件夹下，同样的，使用 add files，将这两个文件添加到工程中。同时要注意，此时要将 HelloJNI.h 中的<code>#include &lt;jni.h&gt;</code>改为<code>#include &quot;jni.h&quot;</code></p><h1 id="实现-native-方法"><a href="#实现-native-方法" class="headerlink" title="实现 native 方法"></a>实现 native 方法</h1><p>接下来就要真正用 c 来实现之前定义的方法了，实现如下，现在可以先不用管具体的语法，只要有一个感性的认识即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HelloJNI.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJNI</span></span><br><span class="line"><span class="comment"> * Method:    getStr</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_HelloJNI_getStr</span><span class="params">(JNIEnv *env, jobject obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJNI</span></span><br><span class="line"><span class="comment"> * Method:    sGetStr</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_HelloJNI_sGetStr</span><span class="params">(JNIEnv * env, jclass clazz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成-dll-文件"><a href="#生成-dll-文件" class="headerlink" title="生成 dll 文件"></a>生成 dll 文件</h1><p>在 codeblocks 左侧列表，鼠标当前 project 右键 选择 build，生成对应的 dll 文件，其路径为当前 project 路径下的：<code>bin\debug</code>中。</p><h1 id="在-Java-工程中使用-dll"><a href="#在-Java-工程中使用-dll" class="headerlink" title="在 Java 工程中使用 dll"></a>在 Java 工程中使用 dll</h1><p>将上一步生成的 dll 文件拷贝到目标 java 工程的根路径，不需其它配置，在 java 文件的<strong>静态代码块</strong>中加载对应的动态链接库，不需要 dll 后缀。然后运行该 java 程序，即可看到对应结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">sGetStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"HelloJNI"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> HelloJNI().getStr());</span><br><span class="line">        System.out.println(sGetStr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>在上一步中，直接把 dll 拷贝到 java 工程目录下了，但是这样有一个问题，那就是你每改动一点 c 的代码，都要重新生成 dll，然后在把该 dll 拷贝到 java 工程目录下，这样是很麻烦的。</p><p>这里的 java 代码所用的 ide 是 idea，我们可以在 idea 中为当前工程设置一个环境变量， 让该变量直接定位到 codeblocks 工程生成 dll 的路径，这样就免去了不断拷贝 dll 文件的麻烦。具体做法是：在 idea 中点击<code>Run &gt; Edit Configurations</code>，将需要加载dll文件的Java文件的 在<code>VM options</code>选项中加入<code>java.library.path</code>，即 dll（或so）文件所在的目录，比如本文中 dll 放在 codeblocks 项目目录中的 <code>E:\Csrc\HelloJNI\bin\Debug</code> 中，<br><img src="http://img.blog.csdn.net/20180110211542880?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWmFjaGF4eQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="idea设置librarypath"></p><p>同时注意到：按照如图的配置，只能是为<code>AccessMethod.java</code>文件配置了路径，也就是说在其它文件要使用 dll 文件时，依然找不到 dll。所以要为每一个需要使用 dll 的 java 文件都配置<code>VM options</code>，虽然还是有些麻烦，但是已经比我们修改 c 代码后，不断的拷贝 dll 文件方便多了。我们的目的还是说快速的了解 JNI 的开发，真正使用 Android Studio 进行 NDK 开发时，就不需要老配置环境了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows配置JNI开发环境</title>
      <link href="/2018/01/10/Windows%E9%85%8D%E7%BD%AEJNI%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/01/10/Windows%E9%85%8D%E7%BD%AEJNI%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="JNI-简介"><a href="#JNI-简介" class="headerlink" title="JNI 简介"></a>JNI 简介</h1><p>JNI：Java Native Interface。<br>当 JDK 所提供的 API 无法满足当前应用的需求时,就要调用 native interface。我们知道 Java 程序跨平台是有前提的，其并不是直接运行时操作系统上的，而是运行在 Java 虚拟机上的，我们平时调用的 JDK 中的 api 是基于 JVM 实现的,但是有一些情况下,这些 api 不能满足我们对性能的要求，那么就需要调用更为底层的语言来解决效率问题。所谓底层语言，一般是说 c/c++，这类语言是可以直接和操作系统的内存做交互的，所以在效率上更加高效。</p><a id="more"></a><p>为了能都调用 c/c++这些底层的语言的接口，Java 提供了 JNI 机制,用来调用动态链接库。我们只需要在对应平台上将 c/c++打包成动态链接库，上层的 Java 就可以通过 JNI 调用动态链接库中的接口了。<br>不同操作系统上，动态链接库的表现形式也是不同的，</p><ul><li>window：dll 文件</li><li>linux：so 文件</li><li>mac：framework 文件</li></ul><p>原始的 c 文件都是相同的，只不过由于平台不同，其打包成的动态链接库文件的格式也是不同的。</p><p>我们的目的是尽快熟悉 JNI 开发流程，而并不关心动态链接库的内部，同时，我们也不想花大把时间在配置上，所以在 window 平台上，下面所提供的方法是最简单省事的，记住我们的目标学习 JNI，不要在其它事情上花费太多时间。其实在 linux 平台上，都不需要搭建这些环境的。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>前提是你的电脑必须是 windows-64bit，否则下面的配置并不适合你！（现在应该没有开发还用 32bit 了吧）</p><h2 id="下载所需的软件"><a href="#下载所需的软件" class="headerlink" title="下载所需的软件"></a>下载所需的软件</h2><ol><li><a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="noopener">codeblocks-16.01mingw-setup.exe</a>，版本号无所谓，但是一定要带 mingw 版本的，因为这样就不用我们自己配置编译器了</li><li><a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="noopener">mingw64</a></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>对于 codeblocks，一路 next 安装即可。<br>对于 mingw64，在安装时则需要特别注意，弹出安装界面后，会有一个设置界面：</p><table><thead><tr><th>Settings</th><th></th></tr></thead><tbody><tr><td>Version</td><td>…</td></tr><tr><td>Architecture</td><td>X86_64</td></tr><tr><td>Thread</td><td>posix</td></tr><tr><td>Exception</td><td>seh</td></tr><tr><td>Build version</td><td>…</td></tr></tbody></table><p>注意这里的 Architecture 一定要选 X86_64，其它默认就好。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开 codeblocks，点击菜单中 settings-&gt;compiler，在这个窗口中，选择 toolchain excutables，在 compiler’s installation directory 一栏选择前面 mingw64 的安装路径。下面的 program files 的选择依照图示即可。</p><p><img src="http://img.blog.csdn.net/20180105175637924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWmFjaGF4eQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="codeblocks 配置 compiler"></p><p>图示的配置是一种可行的方法，同时可以尝试如下配置：<br>| program files           |                               |<br>| ———————– | —————————– |<br>| C compiler              | x86_64-w64-mingw32-gcc.exe    |<br>| C++ compiler            | x86_64-w64-mingw32-g++.exe    |<br>| Linker for dynamic libs | x86_64-w64-mingw32-g++.exe    |<br>| Linker for static libs  | x86_64-w64-mingw32-gcc-ar.exe |<br>| Debuger                 | default                       |<br>| Resource compile        | windres.exe                   |<br>| make programe           | mingw32-maker.exe             |</p><h2 id="设置调试器"><a href="#设置调试器" class="headerlink" title="设置调试器"></a>设置调试器</h2><p>这一步并不是必须的，但是如果你写的 c 代码出了问题，那么就需要调试了。</p><p>打开 codeblocks，点击菜单中 settings-&gt;debugger，点击窗口左边的 gdb/cdb debugger，然后选择 create congfig，新建一个 mingw64 的 debugger ，这个 debugger 是我们自定义的，自己取个名字好了，同时将 debugger type 设置为 GDB，并指定该 debugger 的路径，将 executable path 设置到上面安装的 mingw64 的 bin 目录里的 gdb.exe 。点 OK 然后回到 compiler 设置菜单里，把 debugger 设置为新建的 gdb 。</p><p>至此，window 下 JNI 的开发环境就搭建成功了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(13)-方法调用机制</title>
      <link href="/2018/01/04/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-13-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/04/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-13-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们知道一个程序的运行的逻辑就是在一个代码块中不断的调用方法，将这些方法的调用堆砌好之后就形成的程序的逻辑。有了前面介绍的知识基础，接下来就来介绍下方法的执行过程。本节的代码主要是在<a href="https://github.com/zachaxy/JVM/tree/master/Java/src/instructions/references" target="_blank" rel="noopener">instructions-references包下的 invokeXXX 指令</a>。同时也可以配合<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/test/TestInvokeMethod08.java" target="_blank" rel="noopener">测试用例TestInvokeMethod08</a>加深了解。</p></blockquote><h1 id="方法的调用机制"><a href="#方法的调用机制" class="headerlink" title="方法的调用机制"></a>方法的调用机制</h1><p>注:方法的调用不等同与方法的执行,方法的调用阶段只是用来确定被调用的是哪一个方法，拿到具体的方法之后，就可以拿到其字节码指令，从而执行程序了。</p><p>JVM 中方法调用的指令有以下五条：</p><ul><li>invokestatic:调用静态方法</li><li>invokespecial:调用实例构造器<code>&lt;init&gt;</code>方法,私有方法和父类方法</li><li>invokevirtual:调用所有的虚方法</li><li>invokeinterfae:调用接口方法(在运行时确定实现了此接口的一个具体对象)</li><li>invokenative:本地方法的调用</li></ul><p>前两个在解析阶段就可以确定唯一的调用版本，而后两个需要在调用时寻找真正的 method。</p><a id="more"></a><h1 id="方法调用执行流程概述"><a href="#方法调用执行流程概述" class="headerlink" title="方法调用执行流程概述"></a>方法调用执行流程概述</h1><p>本地方法的执行不在本节讨论之内！<br>invokeXXX 指令的执行：<br>(1)首先该系列的指针的操作数是指向运行时常量池的一个索引，由该索引从运行时常量池获取一个方法引用，再将该方法引用转为直接引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RuntimeConstantPool runtimeConstantPool = frame.getMethod().getClazz().getRuntimeConstantPool();</span><br><span class="line"><span class="comment">//通过index,拿到方法符号引用</span></span><br><span class="line">MethodRef methodRef = (MethodRef) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line"><span class="comment">//将 methodRef 转换为 Method</span></span><br><span class="line">Zmethod resolvedMethod = methodRef.resolvedMethod();</span><br></pre></td></tr></table></figure><p>(2)获取到resolvedMethod方法之后，需要进行一定的权限验证，例如：invokestatic 就要验证 resolvedMethod 是否是 static 的；还有 resolvedMethod 方法是否可以在外部访问（private，protect）的情况等，如果权限验证不通过，则抛出 IllegalAccessError 异常。</p><p>(3)为新方法创建栈帧 newFrame，每个方法的执行都是在自己的 Frame 中，只是创建栈帧，并不压栈，当前栈帧的栈顶依然是调用该方法的栈帧-invokerFrame。</p><p>(4)为即将要调用的方法传递参数，这也是方法执行中很重要的一部分，待执行的方法所需的参数由 invokerFrame 的操作数栈提供，此时需要将 invokerFrame 的操作数栈的弹出对应的操作数，放到 newFrame 的本地变量表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Zthread thread = invokerFrame.getThread();</span><br><span class="line">Zframe newFrame = thread.createFrame(method);</span><br><span class="line">thread.pushFrame(newFrame);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> argSlotCount = method.getArgSlotCount();</span><br><span class="line"><span class="keyword">if</span> (argSlotCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = argSlotCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Slot slot = invokerFrame.getOperandStack().popSlot();</span><br><span class="line">        newFrame.getLocalVars().setSlot(i, slot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要思考的一个问题是：如果确定方法所需的参数的数量？答案就是根据方法的描述符来确定，同时如果方法是非静态方法，那么其第一个参数就是调用该方法的引用自身，虽然我们并没有在代码中显式的写，但是 Java 编译器在编译成字节码时，帮我们做了。</p><p>(5)将 newFrame 压栈，由解释器具体执行具体的方法。</p><h1 id="多态调用的本质。"><a href="#多态调用的本质。" class="headerlink" title="多态调用的本质。"></a>多态调用的本质。</h1><p>通过 invokevirtual 指令调用来进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Parent p = <span class="keyword">new</span> Child();</span><br><span class="line">    p.f1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 main 方法对应的字节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #3 &lt;Child&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #4 &lt;Child.&lt;init&gt;&gt;</span><br><span class="line"> 7 astore_1</span><br><span class="line"> 8 aload_1</span><br><span class="line"> 9 invokevirtual #5 &lt;Parent.f1&gt;</span><br><span class="line">12 return</span><br></pre></td></tr></table></figure><p>假设 main 方法所在的栈帧的 frame1，</p><ol><li>执行指令 new，该指令后跟一个运行时常量池的索引，通过该索引，获取到一个 ClassRef，其名字是 Child，那么接下来就加载 child 类，并创建该类的一个对象p，并将 p 对象放在 frame1的操作数栈上</li><li>执行指令 dup，该指令是将操作数栈顶的slot 复制一份，所以此时 frame1的操作数栈有两个 p 的引用，同时要注意的是这两个 p 指向的是同一块内存的对象。</li><li>执行指令 invokespecial，因为上一步 new 只是为 child 对象申请了空间，该对象的各个字段都是类零值，那么下面就要对该对象进行初始化赋值了。特别要注意的是:该 init 方法也是普通的方法，虽然不是我们自己写的，非静态方法在执行时实际的第一个参数是自身，所需的参数从哪里来呢？答案就是 frame1的操作数栈，因为执行init 方法需要参数（该方法没有其它的参数，只有一个隐式的 this），所以从 frame1的操作数弹出一个引用，那么此时 frame1 的操作数栈就只剩下一个 p 的引用了。</li><li>接下来创建 frame2 执行 init 方法，由该方法初始化传入的 p 所指向的内存对象，大家不要忘记之前 dup 指令是的 frame1 的操作数栈中有两个 p，这只是引用，指向的同一块内存，所以在 frame2 中将对 p 初始化好之后，frame2被弹栈，此时回到 frame1，其操作数栈的 p 所指向的内存就是被 init 方法初始化好的。</li><li>执行指令 astore_1，将操作数栈顶的元素弹出，保存到 frame1的本地变量表，索引为1</li><li>执行指令 aload_1，将 frame1的本地变量表索引为1的元素压入操作数栈。此时 frame1的操作数栈为 p ，额。。。</li><li>执行指令 invokevirtual，该指令后跟一个运行时常量池索引，通过该索引，获取到一个 methodRef，注意该 methodRef 是 Parent 的，而不是 Child 的，虽然该方法实际上应该就是 child 的，先不管这些。拿到 methodRef 之后，将其转换为 method，然后进行权限验证。通过后寻找真正的 method，从哪里寻找？我们看到这个方法依然是非静态方法，所以依然需要一个 this 的引用，依然需要从 frame1 的操作数栈顶 pop 一个引用，这个引用就是 p，但是我们注意看 p 在第一步时创建的类型是 child，所以接下从 this （也就是 p）中重新寻找 method，得到真正的 method，自然就是 child 的 f1 方法了。这就是多态的本质。</li><li>最终执行 return 指令，结束 main 方法的执行。</li></ol><p>invoke_virtual 指令的执行过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">INVOKE_VIRTUAL</span> <span class="keyword">extends</span> <span class="title">Index16Instruction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用该方法所在的类</span></span><br><span class="line">        Zclass currentClass = frame.getMethod().getClazz();</span><br><span class="line">        RuntimeConstantPool runtimeConstantPool = currentClass.getRuntimeConstantPool();</span><br><span class="line">        <span class="comment">//通过index,拿到方法符号引用,虚方法(用到了多态),这个方法引用指向的其实是父类的</span></span><br><span class="line">        MethodRef methodRef = (MethodRef) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">        <span class="comment">//将方法引用转换为方法</span></span><br><span class="line">        <span class="comment">//这一步拿到解析后的resolvedMethod主要是用来做下面权限的验证;</span></span><br><span class="line">        <span class="comment">//而真正的resolvedMethod是在下面拿到真正的调用者,再次解析到的methodToBeInvoked</span></span><br><span class="line">        Zmethod resolvedMethod = methodRef.resolvedMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从操作数栈中获取调用该非静态方法的引用;参数的传递是从当前frame的操作数栈中根据参数个数,完整的拷贝到调用frame的本地变量表中;</span></span><br><span class="line">        Zobject ref = frame.getOperandStack().getRefFromTop(resolvedMethod.getArgSlotCount() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"called "</span> + resolvedMethod.getName() + <span class="string">" on a null reference!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相对于invokespecial,本指令还多了这一步,因为ref才是真正的调用者</span></span><br><span class="line">        <span class="comment">//而这次解析到的才是真正的method,这是多态的核心!</span></span><br><span class="line">        Zmethod methodToBeInvoked = MethodLookup.lookupMethodInClass(ref.getClazz(),</span><br><span class="line">                methodRef.getName(), methodRef.getDescriptor());</span><br><span class="line">        <span class="keyword">if</span> (methodToBeInvoked == <span class="keyword">null</span> || methodToBeInvoked.isAbstract()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AbstractMethodError(methodToBeInvoked.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Zthread thread = invokerFrame.getThread();</span><br><span class="line">        Zframe newFrame = thread.createFrame(method);</span><br><span class="line">        thread.pushFrame(newFrame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> argSlotCount = method.getArgSlotCount();</span><br><span class="line">        <span class="keyword">if</span> (argSlotCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = argSlotCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                Slot slot = invokerFrame.getOperandStack().popSlot();</span><br><span class="line">                newFrame.getLocalVars().setSlot(i, slot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法的返回"><a href="#方法的返回" class="headerlink" title="方法的返回"></a>方法的返回</h1><p>方法的返回是有 xreturn 指令实现的。其中 x 表示返回值的类型，有基本类型和引用类型，当然也有 void 类型。</p><p>void 类型的返回是最简单的，直接将当前方法所在的 frame 弹出栈帧即可。<br>而对于有返回值的return 指令，返回时，返回值在 执行方法的frame 的操作数栈顶，此时需要拿到该返回值 value ，然后弹出当前 frame，回到方法调用的 frame，将 value 放到方法调用 frame 的操作数栈。</p><p>以 areturn 指令的执行做一个说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Zthread thread = frame.getThread();</span><br><span class="line">Zframe currentFrame = thread.popFrame();</span><br><span class="line">Zframe invokerFrame = thread.getCurrentFrame();</span><br><span class="line">Zobject val = currentFrame.getOperandStack().popRef();</span><br><span class="line">invokerFrame.getOperandStack().pushRef(val);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(12)-类加载器的实现</title>
      <link href="/2018/01/04/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/01/04/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过之前的文章，我们了解了 Class 文件存储格式的具体细节，在 Class 文件中描述的各种信息,最终都需要加载到虚拟机中之后才能运行和使用。之前我们已经可以将 Class 文件的字节码读取到内存中了，这其实就是类加载器中 的加载过程，属于类加载器的一部分功能，除此之外，类加载器还有其它功能需要完善，这一节将对类加载的过程做一个详细的介绍。<br>本节的代码集中在 <a href="https://github.com/zachaxy/JVM/tree/master/Java/src/runtimedata/heap" target="_blank" rel="noopener">heap</a> 包下。</p></blockquote><h1 id="类加载的生命周期"><a href="#类加载的生命周期" class="headerlink" title="类加载的生命周期"></a>类加载的生命周期</h1><p>类从被加载到虚拟机开始，到卸载出内存，其整个生命周期包括：</p><ol><li>加载</li><li>验证—-|</li><li>准备—-|—&gt;连接</li><li>解析—-|</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>其中：验证，准备，解析3个阶段统称为连接阶段。C语言需要在编译时进行连接工作，但是Java不同，其“连接”的工作全都推迟到运行期来做，这虽然会增加一些性能上的开销，但是却为java应用程序提供高度的灵活性.</p><p>其生命周期的 加载，验证，准备，初始化，卸载这五个阶段顺序是确定的，而类的解析阶段，正常情况下是在初始化之前的，但是遇到多态，则在初始化之后开始。这也充分体现了Java的灵活性。<br>我们重点要掌握的是加载，验证，准备，解析,初始化这五个阶段。</p><a id="more"></a><p>虚拟机规范严格规定有且只有以下5种情况必须立即对类进行初始化:（前提是该类还未进行过初始化，以下5个条件任何一个都会触发其初始化动作；如果已经进行过初始化，会从 <strong>方法区</strong> 中直接读取）</p><ol><li>遇到new，getstatic，putstatic，invokestatic这四条字节码指令时；其分别对应Java语法中的使用new关键字实例化对象，读写一个类的静态变量时（若是读的static final 的基本类型或者字符串，那么其值是在字段的ConstantValue属性中就初始化好的，并不需要对类进行初始化），调用类的静态方法时；</li><li>使用反射对类进行调用时</li><li>初始化一个类的时候，发现其父类还未初始化，那么先触发其父类的初始化</li><li>启动虚拟机时，需要制定一个包含main方法的类，虚拟机会先初始化该类</li><li>如果一个<code>MethodHandle</code>实例最后的解析结果是 <code>REF_getStatic</code>,<code>REF_putStatic</code>,<code>REF_invokeStatic</code> 的方法的句柄时，会触发对应的 REF 类加载。</li></ol><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>加载阶段，虚拟机需要完成2件事：</p><ol><li>通过类的全限定名来获取该类的二进制字节流，对应我们之前讲的搜寻类所在的路径，并读取 class 文件，将其映射为 <a href="https://github.com/zachaxy/JVM/blob/master/Java/src/classfile/ClassFile.java" target="_blank" rel="noopener">ClassFile</a> 对象</li><li>将这个字节流所代表的静态存储初结构转换为方法区的运行时数据结构，将 ClassFile 转换为 <a href="https://github.com/zachaxy/JVM/blob/master/Java/src/runtimedata/heap/Zclass.java" target="_blank" rel="noopener">Zclass</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取 class 文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] readClass(String name) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = classPath.readClass(name);</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面读取的到字节码转换为最终的 Zclass</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Zclass <span class="title">paraseClass</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    ClassFile cf = <span class="keyword">new</span> ClassFile(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Zclass(cf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>这一阶段的目的是确保Class文件中的字节流包含的信息符合当前虚拟机的要求。该阶段需要接受四小阶段的验证动作：</p><ol><li>文件格式验证：是否按照Class字节码的格式组织的，同时对索引的访问是否越界等</li><li>元数据验证：对字节码（Code中的属性）描述的信息进行语义分析，以保证其符合Java语言规范</li><li>字节码验证：对数据流和控制流分析，确定程序语义是合法的，而不会在运行时危害虚拟机安全</li><li>符号引用验证：在解析阶段发生，主要是验证符号引用转换为直接引用的时候。若无法通过符号引用验证，那么将抛出IncompatibleClassChangeError的子类。符号引用验证在转换为直接引用的时候，还要判断当前类是都对转换的直接引用有访问权限，如果没有，则抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol><p>注意：这个阶段并不是必须的，如果是我们自己写的代码，后者大量验证了第三方库的代码是无害的，那么完全可以取消验证阶段，以提高类加载的效率。<code>可使用 -Xverify:none 参数来关闭验证</code></p><p>而在本 JVM 中并没有对其进行验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在执行类的任何代码之前要对类进行严格的检验,这里忽略检验过程,,作为空实现;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备阶段是为类的<strong>静态变量</strong>分配内存，并设置初值的阶段，这里要注意的是，<strong>设置初值指的是类型的零值</strong>。<br>例如类中有如下语句：<code>public static int i = 123;</code>，那么i在初始化阶段过后的值为0，而不是123，赋值为123的阶段是在后面的初始化阶段。<br>但是如果是同时被final修饰变量，<code>public static final int i = 123;</code>那么会为该变量生成ConstantValue属性，并在准备阶段将其值设为123。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给类变量分配空间并赋予初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">    calcInstanceFieldSlotIds(clazz);</span><br><span class="line">    calcStaticFieldSlotIds(clazz);</span><br><span class="line">    allocAndInitStaticVars(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算new一个对象所需的空间,单位是clazz.instanceSlotCount,主要包含了类的非静态成员变量(包含父类的)</span></span><br><span class="line"><span class="comment">// 但是这里并没有真正的申请空间，只是计算大小，同时为每个非静态变量关联 slotId</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcInstanceFieldSlotIds</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slotId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (clazz.superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slotId = clazz.superClass.instanceSlotCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Zfield field : clazz.fileds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!field.isStatic()) &#123;</span><br><span class="line">            field.slotId = slotId;</span><br><span class="line">            slotId++;</span><br><span class="line">            <span class="keyword">if</span> (field.isLongOrDouble()) &#123;</span><br><span class="line">                slotId++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clazz.instanceSlotCount = slotId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算类的静态成员变量所需的空间，不包含父类，同样也只是计算和分配 slotId，不申请空间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcStaticFieldSlotIds</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slotId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Zfield field : clazz.fileds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.isStatic()) &#123;</span><br><span class="line">            field.slotId = slotId;</span><br><span class="line">            slotId++;</span><br><span class="line">            <span class="keyword">if</span> (field.isLongOrDouble()) &#123;</span><br><span class="line">                slotId++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clazz.staticSlotCount = slotId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为静态变量申请空间,注意:这个申请空间的过程,就是将所有的静态变量赋值为0或者null;</span></span><br><span class="line"><span class="comment">// 如果是 static final 的基本类型或者 String，其值会保存在ConstantValueAttribute属性中</span></span><br><span class="line"><span class="comment">// 而ConstantValueAttribute属性中保存的值又是在常量池中！</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocAndInitStaticVars</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">    clazz.staticVars = <span class="keyword">new</span> Slots(clazz.staticSlotCount);</span><br><span class="line">    <span class="keyword">for</span> (Zfield field : clazz.fileds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.isStatic() &amp;&amp; field.isFinal()) &#123;</span><br><span class="line">            initStaticFinalVar(clazz, field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为static final 修饰的成员赋值,这种类型的成员是ConstantXXXInfo类型的,该info中包含真正的值在运行时常量池中;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initStaticFinalVar</span><span class="params">(Zclass clazz, Zfield zfield)</span> </span>&#123;</span><br><span class="line">    Slots staticVars = clazz.staticVars;</span><br><span class="line">    RuntimeConstantPool runtimeConstantPool = clazz.getRuntimeConstantPool();</span><br><span class="line">    <span class="keyword">int</span> index = zfield.constValueIndex;</span><br><span class="line">    <span class="keyword">int</span> slotId = zfield.slotId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (zfield.getDescriptor()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Z"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"S"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"I"</span>:</span><br><span class="line">                <span class="keyword">int</span> intValue = (<span class="keyword">int</span>) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">                staticVars.setInt(slotId, intValue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"J"</span>:</span><br><span class="line">                <span class="keyword">long</span> longValue = (<span class="keyword">long</span>) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">                staticVars.setLong(slotId, longValue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"F"</span>:</span><br><span class="line">                <span class="keyword">float</span> floatValue = (<span class="keyword">float</span>) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">                staticVars.setFloat(slotId, floatValue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">                <span class="keyword">double</span> doubleValue = (<span class="keyword">double</span>) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">                staticVars.setDouble(slotId, doubleValue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Ljava/lang/String;"</span>:</span><br><span class="line">                String stringValue = (String) runtimeConstantPool.getRuntimeConstant(index).getValue();</span><br><span class="line">                Zobject jStr = StringPool.jString(clazz.getLoader(), stringValue);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>解析阶段在<a href="https://zachaxy.github.io/2018/01/03/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-11-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE/#%E6%80%BB%E7%BB%93">上一节</a>分析过概念，而接下会通过代码进行解释。该阶段是将class文件中常量池的符号引用替换为直接引用的过程，符号引用指的是在class文件中的<code>Constant_Class_info</code>,<code>Constant_Fieldref_info</code>,<code>Constant_Methodref_info</code>,<code>Constant_InterfaceMethodref_info</code>这四个常量。以及<code>Constant_MethodType_info</code>，<code>Constant_MethodHandle_info</code>，<code>Constant_Invokedynamic_info</code>。而这三种常量类型与JDK1.7新增的动态语言支持相关，这里暂时不涉及。</p><p>符号引用vs直接引用<br>在class文件中，是一堆数据，这四个常量类型是以字符串来描述的，符号引用与虚拟机中的内存布局无关，因此成为符号引用。而直接引用则是直接指向虚拟机内存中目标的指针。</p><p>上述四种常量类型可分为三类：</p><ul><li>类或接口</li><li>字段</li><li>方法<br>接下来对这三种类型的解析过程做一个介绍</li></ul><h2 id="类或接口类型的解析"><a href="#类或接口类型的解析" class="headerlink" title="类或接口类型的解析"></a>类或接口类型的解析</h2><p>当前类d，以及其class文件中的常量池，解析其中的<code>Constant_Class_info</code>，根据该常量，可以获取其对应的全限定名，然后将全限定名传给d的类加载器，去接在目标类c，中途出现任何异常，都将终止整个解析过程。将c加载出来后，还要判断当前类d对c是否具有访问权限(该过程属于符号引用验证阶段)，如果没有访问权限，则抛出<code>java.lang.IllegalAccessError</code>异常。</p><h2 id="字段的解析"><a href="#字段的解析" class="headerlink" title="字段的解析"></a>字段的解析</h2><p>当前类d，以及其class文件中的常量池，解析其中的<code>Constant_Fieldref_info</code>，根据该常量，首先获取其classIndex索引，获取到常量池中<code>Constant_Class_info</code>，对其进行解析，如果目标类c解析成功，接下来进行后续的字段搜索。</p><ol><li>如果c中包含了该目标字段(简单名称和字段描述符都能匹配)，则返回该字段的直接引用。</li><li>否则，如果c实现了接口，会按照继承关系，从下向上递归搜索接口和父接口，如果能找到，则返回该字段的引用</li><li>否则，按照类继承关系，从下向上递归搜索父类，直到顶级父类Object，如果能找到，则返回该字段的引用</li><li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li></ol><p>如果查找过程中成功返回了引用，则将对目标字段进行权限验证，如果没有访问权限，则抛出<code>java.lang.IllegalAccessError</code>异常。</p><h2 id="类方法的解析"><a href="#类方法的解析" class="headerlink" title="类方法的解析"></a>类方法的解析</h2><p>当前类d，以及其class文件中的常量池，解析其中的<code>Constant_Methodref_info</code>，根据该常量，首先获取其classIndex索引，获取到常量池中<code>Constant_Class_info</code>，对其进行解析，如果目标类c解析成功，接下来进行后续的方法搜索。</p><ol><li>首先明确这是类方法，而不是接口方法。如果在类方法中发现classIndex索引的c是个接口，那么直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常</li><li>如果通过第1步，在c中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回该方法的直接引用</li><li>否则，按照类继承关系，从下向上递归搜索父类，直到顶级父类Object，如果能找到，则返回该方法的引用</li><li>否则，在c实现的接口和其父接口中递归查找简单名称和描述符都与目标匹配的方法，如果有，说明c是一个抽象类，抛出<code>java.lang.AbstractMethodError</code>异常</li><li>否则，查找失败，抛出<code>java.lang.NoSuchMethodError</code></li></ol><p>如果查找过程成功返回了引用，则将对目标方法进行权限验证，如果没有访问权限，则抛出<code>java.lang.IllegalAccessError</code>异常。</p><h2 id="接口方法的解析"><a href="#接口方法的解析" class="headerlink" title="接口方法的解析"></a>接口方法的解析</h2><p>当前类d，以及其class文件中的常量池，解析其中的<code>Constant_InterfaceMethodref_info</code>，根据该常量，首先获取其classIndex索引，获取到常量池中<code>Constant_Class_info</code>，对其进行解析，如果目标接口 c解析成功，接下来进行后续的方法搜索。</p><ol><li>首先明确这是接口方法，而不是类方法。如果在接口方法中发现classIndex索引的c是个类，那么直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常</li><li>如果通过第1步，在c中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回该方法的直接引用</li><li>否则，按照接口继承关系，从下向上递归搜索父接口，直到顶级父类Object(接口的顶级父类也是Object)，如果能找到，则返回该方法的引用</li><li>否则，查找失败，抛出<code>java.lang.NoSuchMethodError</code></li></ol><p>接口中的方法默认都是public的，所以不存在访问权限问题。</p><h2 id="以类引用的解析为例"><a href="#以类引用的解析为例" class="headerlink" title="以类引用的解析为例"></a>以类引用的解析为例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SymRef &#123;</span><br><span class="line">    RuntimeConstantPool runtimeConstantPool;   //存放符号引用所在的运行时常量池指针,可以通过符号引用访问到运行时常量池，进一步又可以访问到类数据</span><br><span class="line">    String className;   //存放类的完全限定名</span><br><span class="line">    Zclass clazz;       //上述运行时常量池的宿主类中的符号引用的真正类,在外面访问时，根据 clazz 是否为 null 来决定是否执行 loadClass</span><br><span class="line"></span><br><span class="line">    public SymRef(RuntimeConstantPool runtimeConstantPool) &#123;</span><br><span class="line">        this.runtimeConstantPool = runtimeConstantPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类引用转直接引用</span><br><span class="line">    public Zclass resolvedClass() &#123;</span><br><span class="line">        if (clazz == null) &#123;</span><br><span class="line">            resolvedClassRef();</span><br><span class="line">        &#125;</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前类(runtimeConstantPool的宿主类)d中,如果引用了类c,那么就将c加载进来</span><br><span class="line">    private void resolvedClassRef() &#123;</span><br><span class="line">        Zclass d = runtimeConstantPool.clazz;</span><br><span class="line">        Zclass c = d.loader.loadClass(className);</span><br><span class="line">        //在这里判断下 d 能否访问 c</span><br><span class="line">        if (!c.isAccessibleTo(d)) &#123;</span><br><span class="line">            throw new IllegalAccessError(d.thisClassName + &quot; can&apos;t access &quot; + c.thisClassName);</span><br><span class="line">        &#125;</span><br><span class="line">        clazz = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 SymRef 代表类引用，其核心方法就是resolvedClassRef方法。该方法是在什么情况下使用呢？</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化阶段才是真正执行类中定义的Java程序代码(字节码)。<br>在前面的准备阶段，已经对类的静态变量进行过一次赋值了(0或者final定义的值)。而在初始化阶段，则根据程序员通过程序制定的代码去初始化类静态变量。其实，初始化阶段就是执行类构造器 <code>&lt;clinit&gt;</code>方法的过程。</p><p><code>&lt;clinit&gt;</code>方法由编译器自动收集类中所有静态变量的赋值语句和静态代码块的语句，按照其在源文件中出现的顺序融到<code>&lt;clinit&gt;</code>中。同时，虚拟机会保证在执行子类的<code>&lt;clinit&gt;</code>方法之前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。所以虚拟机中第一个被执行的<code>&lt;clinit&gt;</code>方法一定是Object类的。</p><p>注意：只有当类中存在静态变量赋值语句或者静态代码块时，才会产生<code>&lt;clinit&gt;</code>方法，如果没有这些，那么虚拟机也就没有必要去创建<code>&lt;clinit&gt;</code>方法。</p><p>接口中虽然不能包含静态代码块，但是可以包含变量的赋值，而且接口中的变量默认是<code>public static final</code> 的。因此接口中也可以有<code>&lt;clinit&gt;</code>方法，但是执行接口的<code>&lt;clinit&gt;</code>方法并不要求父接口的<code>&lt;clinit&gt;</code>先执行。</p><p>初始化阶段执行的<code>&lt;clinit&gt;</code>方法我们当做一个普通的方法来执行就可以了，如果有的话，其在 class 文件中会产生对应的字节码。但是唯一要注意的是，<code>&lt;clinit&gt;</code>方法同一个类只能执行一次。因此在 Zclass 类中，添加了一个布尔类型的 initStarted 字段判断类是否已经初始化，执行了类的<code>&lt;clinit&gt;</code>方法。</p><p>回想文章一开始介绍的类加载的时机，是在遇到new，getstatic，putstatic，invokestatic这四条字节码指令时，那么我们就在这四个指令的执行过程中去判断一个 class 是否已经被初始化，如果没有执行过，那么先执行其类初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断其Class是否已经加载过,如果还未加载,那么调用其类的&lt;clinit&gt;方法压栈</span></span><br><span class="line"><span class="keyword">if</span> (!clazz.isInitStarted()) &#123;</span><br><span class="line">    <span class="comment">//当前指令已经是在执行new了,但是类还没有加载,所以当前帧先回退,让类初始化的帧入栈,等类初始化完成后,重新执行new;</span></span><br><span class="line">    frame.revertNextPC();</span><br><span class="line">    ClassInitLogic.initClass(frame.getThread(), clazz);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类加载器的实现"><a href="#类加载器的实现" class="headerlink" title="类加载器的实现"></a>类加载器的实现</h1><p>具体源码请参考<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/runtimedata/heap/ZclassLoader.java" target="_blank" rel="noopener">ZclassLoader</a>，这里简述下其大体流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZclassLoader</span> </span>&#123;</span><br><span class="line">    ClassPath classPath;</span><br><span class="line">    <span class="comment">//作为缓存，之前加载过这个类，那么就将其class引用保存到map中，后面再用到这个类的时候，直接用map中取；</span></span><br><span class="line">    HashMap&lt;String, Zclass&gt; map;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZclassLoader</span><span class="params">(ClassPath classPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;String, Zclass&gt;();</span><br><span class="line"></span><br><span class="line">        loadBasicClasses();</span><br><span class="line">        loadPrimitiveClasses();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Zclass <span class="title">loadClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Zclass clazz;</span><br><span class="line">        <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">            clazz = loadArrayClass(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clazz = loadNonArrayClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Zclass <span class="title">loadNonArrayClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = readClass(name);</span><br><span class="line">        Zclass clazz = defineClass(data);</span><br><span class="line">        link(clazz);</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClass(String name) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = classPath.readClass(name);</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(<span class="string">"class name: "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Zclass <span class="title">defineClass</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        Zclass clazz = parseClass(data);</span><br><span class="line">        clazz.loader = <span class="keyword">this</span>;</span><br><span class="line">        resolveSuperClass(clazz);</span><br><span class="line">        resolveInterfaces(clazz);</span><br><span class="line">        map.put(clazz.thisClassName, clazz);</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">        verify(clazz);</span><br><span class="line">        prepare(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在执行类的任何代码之前要对类进行严格的检验,这里忽略检验过程,作为空实现;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给类变量分配空间并赋予初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Zclass clazz)</span> </span>&#123;</span><br><span class="line">        calcInstanceFieldSlotIds(clazz);</span><br><span class="line">        calcStaticFieldSlotIds(clazz);</span><br><span class="line">        allocAndInitStaticVars(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(11)-线程共享的运行时数据</title>
      <link href="/2018/01/03/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-11-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/01/03/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-11-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面已经初步实现了线程私有的运行时数据区，主要包括操作数栈和局部变量表。接下来将继续丰富运行时数据区的内容——线程共享的运行时数据区，包括方法区和运行时常量池。本节的代码集中在 <a href="https://github.com/zachaxy/JVM/tree/master/Java/src/runtimedata/heap" target="_blank" rel="noopener">heap</a> 包下。同时也会对一些概念做出解释。因为自己之前在这些概念上的错误认识，走了很多弯路。</p></blockquote><a id="more"></a><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>之前我们已经可以找到 class 文件，并把其内容加载到内存中，对其解析成一个 ClassFile 的结构，但是 ClassFile 中的内容仍然无法直接在方法区使用，还需要进一步的转换。其实转换的内容不多，我们通过代码来直观的对已一下 ClassFile 和 Zclass 中的区别。(为避免和 JDK 中已有的类名冲突，这里将我们自定义的 <code>class</code>，<code>method</code>，<code>field</code> 等前面都加一个 <code>z</code> 以作区分。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zclass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accessFlags;        <span class="comment">// 表示当前类的访问标志</span></span><br><span class="line">    <span class="keyword">public</span> String thisClassName;   <span class="comment">//当前类名字(完全限定名)</span></span><br><span class="line">    <span class="keyword">public</span> String superClassName;  <span class="comment">//父类名字(完全限定名)</span></span><br><span class="line">    <span class="keyword">public</span> String[] interfaceNames;<span class="comment">//接口名字(完全限定名,不可以为null,若为实现接口,数组大小为0)</span></span><br><span class="line">    <span class="keyword">private</span> RuntimeConstantPool runtimeConstantPool;<span class="comment">//运行时常量池,注意和class文件中常量池区别;</span></span><br><span class="line">    Zfield[] fileds;        <span class="comment">//字段表,包括静态和非静态，此时并不分配 slotId；下面的staticVars 是其子集</span></span><br><span class="line">    Zmethod[] methods;      <span class="comment">//方法表，包括静态和非静态</span></span><br><span class="line">    ZclassLoader loader;    <span class="comment">//类加载器</span></span><br><span class="line">    Zclass superClass;      <span class="comment">//当前类的父类class,由类加载时,给父类赋值;</span></span><br><span class="line">    Zclass[] interfaces;    <span class="comment">//当前类的接口class,由类加载时,给父类赋值;</span></span><br><span class="line">    <span class="keyword">int</span> instanceSlotCount;  <span class="comment">//非静态变量占用slot大小,这里只是统计个数(从顶级父类Object开始算起)</span></span><br><span class="line">    <span class="keyword">int</span> staticSlotCount;    <span class="comment">// 静态变量所占空间大小</span></span><br><span class="line">    Slots staticVars;      <span class="comment">// 存放静态变量</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minorVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> majorVersion;</span><br><span class="line">    <span class="keyword">public</span> ConstantPool constantPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> superClass;         <span class="comment">//同 thisClass 的索引值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] interfaces;     <span class="comment">//存放所实现的接口在常量池中的索引。同 thisClass 的索引值。</span></span><br><span class="line">    <span class="keyword">private</span> MemberInfo[] fields;    <span class="comment">//存放类中所有的字段，包括静态的非静态的；不同的属性通过字段的访问修饰符来读取；</span></span><br><span class="line">    <span class="keyword">private</span> MemberInfo[] methods;   <span class="comment">//存放类中所有的方法，包括静态的非静态的；不同的属性通过方法的访问修饰符来读取；</span></span><br><span class="line">    <span class="keyword">private</span> AttributeInfo[] attributes; <span class="comment">//属性表，存放类的属性；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比由 ClassFile -&gt; Zclass 的转换可以发现：eg：ClassFile 中  superClass 的值是一个 int 的索引值，其指向常量池的一个常量，该常量由通过一个索引指向常量池中的 utf8-constant，从而用来表示当前 class 的父类的名字(字符串)。而在 Zclass 中，可以看到有一个 superClass 的成员变量，其类型为 Zclass 类型，而不再是简单的字符串。再来看在类中定义的成员变量，在 ClassFile 中成员变量是保存在MemberInfo 中，这也是简单的字符描述(变量类型，变量名字),在 Zclass 中保存的是新定义的 Zfield 类型的变量，这些都是需要转换的地方。</p><p>所以转换的本质是什么：<br>** class 文件中全是字符串，而现在加载到内存中了，就不能简单的用一个字符串来描述了，而是一个指向内存的一个实体**</p><p>所以针对于 ClassFile 到 Zclass 的转换，具体要转换的有三部分：</p><ul><li>类信息本身，这里定义为 Zclass</li><li>字段信息，这里定义为 Zfield，表示在类中定义的变量(静态+非静态)，Zfield 中有一个成员变量 Zclass，表明当前字段属于哪个类</li><li>方法信息，这里定义为 Zmethod，表示在类中定义的方法(静态+非静态)，Zmethod 中有一个成员变量 Zclass，表明当前方法属于哪个类</li></ul><p>而转换为 Zclass 的类，就是放在方法区的，其实叫方法区是有干扰的，让人以为方法区只是存放类中的方法的，并不是这样的。方法区存放的是一个 class 文件的描述，包括该类的权限，该类实现了哪些接口，该类的父类是谁，该类有哪些字段，以及字段的权限，该类有哪些方法，以及方法的权限等。<br>在本 JVM 中，方法区的实现是使用了一个 HashMap，其中 key 的 class 的全限定名，value 为加载进来的 zclass 对象。</p><p>读完上面的描述，你可能还是一头雾水，暂时先放到一边，因为单将方法区无法将清楚，其还要配合下面的运行时常量，才能查看其全貌。</p><h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>常量池，这个概念之前就遇到过，那是在解析 class 文件时，class 文件中就有一个常量池的概念，现在又遇到了常量池，不过不是一回事。</p><p>这里再次解释一下 class 文件中的常量池的概念。我们将 java 代码通过 javac 编译为 class 文件，接下来再运行 java 程序的时候就完全不需要 java 文件了，只需要 class 文件即可，但是 class 文件是保存在本地磁盘上的文件，里面全是0101的字节码，或者说是字符串，那各个字符串之间如何产生联系呢？那就是通过常量池，并给常量池安排了序号，每个序号都对应一个常量(字符串)，然后 class 文件规定了一个格式，每个 class 文件都要按照一定的次序排放，类名，访问权限，成员变量，成员方法等(具体可回顾<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-4-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6/">分析class文件</a>)。如何描述类名，成员变量，成员方法？就是在 class 文件中对应的位置保存一个整数，用来指向 class 文件中另一块区域——常量池中的一个常量(字符串)，用字符串来描述这是什么。<br>在强调一遍：class 文件是在本地磁盘上的文件，其内部是死的。</p><p>那么接下来将 class 文件读到内存中，其常量池也要进行相应的转换。如果是基本类型的常量那么原封不动，但如果表示的是一个类的引用，在 class 文件中使用的还是字符串，用来说明是哪个类，而在运行期间，就要真正的加载这个类(保存在方法区)，然后指向加载的这个类，而不是之前简单的字符串了。</p><p>到这里，应该对两个常量池的作用有一个清楚的了解，自己之前就是把两个常量池当成一个，直接拿来用了！所以在描述常量池时，我会用 <code>class 文件中的常量池</code> 和 <code>运行时常量池</code> 来做区分。</p><p>所以，相对于 class 文件中的常量池，运行时常量池是在内存中的，是活的。由 class 文件中的常量池向运行时常量池的转换如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要作用是将class文件中的常量池转换为运行时常量池;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RuntimeConstantPool</span><span class="params">(Zclass clazz, ConstantPool classFileConstantPool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    ConstantInfo[] classFileConstantInfos = classFileConstantPool.getInfos();</span><br><span class="line">    <span class="keyword">int</span> len = classFileConstantInfos.length;</span><br><span class="line">    <span class="keyword">this</span>.infos = <span class="keyword">new</span> RuntimeConstantInfo[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ConstantInfo classFileConstantInfo = classFileConstantInfos[i];</span><br><span class="line">        <span class="keyword">switch</span> (classFileConstantInfo.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Integer:</span><br><span class="line">                ConstantIntegerInfo intInfo = (ConstantIntegerInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;Integer&gt;(intInfo.getVal(), ConstantInfo.CONSTANT_Integer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Float:</span><br><span class="line">                ConstantFloatInfo floatInfo = (ConstantFloatInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;Float&gt;(floatInfo.getVal(), ConstantInfo.CONSTANT_Float);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Long:</span><br><span class="line">                <span class="comment">//Long 和 Double 在转换结束之后，都要进行 i++,以适配 class 文件中常量池的索引</span></span><br><span class="line">                ConstantLongInfo longInfo = (ConstantLongInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;Long&gt;(longInfo.getVal(), ConstantInfo.CONSTANT_Long);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Double:</span><br><span class="line">                ConstantDoubleInfo doubleInfo = (ConstantDoubleInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;Double&gt;(doubleInfo.getVal(), ConstantInfo.CONSTANT_Double);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_String:</span><br><span class="line">                <span class="comment">//在对字符串引用进行转换的时候，转为字符串直接引用</span></span><br><span class="line">                ConstantStringInfo stringInfo = (ConstantStringInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;String&gt;(stringInfo.getString(), ConstantInfo.CONSTANT_String);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Class:</span><br><span class="line">                ConstantClassInfo classInfo = (ConstantClassInfo) classFileConstantInfo;</span><br><span class="line">                <span class="comment">//ref 类中真正需要的是 传入上面的 clazz</span></span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;ClassRef&gt;(<span class="keyword">new</span> ClassRef(<span class="keyword">this</span>, classInfo), ConstantInfo.CONSTANT_Class);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Fieldref:</span><br><span class="line">                ConstantFieldRefInfo fieldRefInfo = (ConstantFieldRefInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;FieldRef&gt;(<span class="keyword">new</span> FieldRef(<span class="keyword">this</span>, fieldRefInfo), ConstantInfo.CONSTANT_Fieldref);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_Methodref:</span><br><span class="line">                ConstantMethodRefInfo methodRefInfo = (ConstantMethodRefInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;MethodRef&gt;(<span class="keyword">new</span> MethodRef(<span class="keyword">this</span>, methodRefInfo), ConstantInfo.CONSTANT_Methodref);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ConstantInfo.CONSTANT_InterfaceMethodref:</span><br><span class="line">                ConstantInterfaceMethodRefInfo interfaceMethodRefInfo = (ConstantInterfaceMethodRefInfo) classFileConstantInfo;</span><br><span class="line">                <span class="keyword">this</span>.infos[i] = <span class="keyword">new</span> RuntimeConstantInfo&lt;InterfaceMethodRef&gt;(<span class="keyword">new</span> InterfaceMethodRef(<span class="keyword">this</span>, interfaceMethodRefInfo), ConstantInfo.CONSTANT_InterfaceMethodref);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">//还有一些jdk1.7才开始支持的动态属性,不在本虚拟机的实现范围内</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是对以下四种常量进行转换：</p><ul><li>类符号引用</li><li>字段符号引用</li><li>方法符号引用</li><li>接口方法符号引用</li></ul><p>这里再区分一个概念，拿字段符号引用来说，什么是字段符号引用，和上面讲到的方法区中要转换的字段又有什么关系？<br>以下面一个简单的例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中 str 就是之前方法区要转换的字段。System.out 是字段符号引用,因为该 out 字段并非类 A 中定义的，而是在 System 类中定义的。</p><p>二者相同点：都是字段，那么是字段就要有字段名，类型，所在的类</p><p>不同的是：<br>方法区要转换的字段，是在当前类声明的成员变量，所以其所在的类就是当前类。<br>字段引用：FieldRef 类没有直接的一个字段指向其所在的类，而是有一个所在类的名字，那么在使用字段引用(FieldRef)时这就需要以下两步解决：</p><ul><li>用类加载器根据类名将对应的类加载进来</li><li>在从上一步加载到的类中，查找其定义的对应的字段，从而获取到真正的字段</li></ul><p>是在方法中的 code 属性中用到的。f 方法对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #2 &lt;java/lang/System.out&gt;</span><br><span class="line">3 invokevirtual #3 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">6 return</span><br></pre></td></tr></table></figure><p>其中的 getstatic 指令，后跟的索引2，指向的就是运行时常量池中的一个字段引用。那么 getstatic 指令要做的是从运行时常量池获取到一个 FieldRef，然后根据其类名加载类——System，因为 out 是类 System 中定义的一个变量，所以从 System 的 filed[] 数组中根据字段名找到对应的字段 field，<br>最后将该 field 压入操作数栈。</p><p>在上面的 invokevirtual 指令中，其后跟的索引3指向的是运行时常量池中的一个方法引用(MethodRef)，其方法名为println，该方法在 java/io/PrintStream 中定义，也就是 System.out 的类型。和字段引用解析类似，也是先加载其所在的类java/io/PrintStream到方法区，然后根据方法名找到对应的方法，最重要的是拿到方法中的 code 字节码，从而进行该方法的调用！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一节主要介绍了线程共享的运行时数据区，该数据区包含两个重要的概念：方法区和运行时常量池。同时还着重强调了两组概念：</p><ul><li>class 文件中的常量池 和 运行时常量池</li><li>类中定义的字段、方法 和 字段引用，方法引用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy与DSL</title>
      <link href="/2017/12/13/Groovy%E4%B8%8EDSL/"/>
      <url>/2017/12/13/Groovy%E4%B8%8EDSL/</url>
      
        <content type="html"><![CDATA[<p>DSL：领域特定语言。常用于聚焦指定的领域或问题，这就要求 DSL 具备强大的表现力，同时在使用起来要简单。由于其使用简单的特性，DSL 通常不会像 Java，C++等语言将其应用于一般性的编程任务。</p><p>由语言的难易程度，做一个简单的排序：配置文件 &lt; DSL &lt; 编程语言(eg:Java,C++…)</p><ul><li>配置文件是最简单的一种，常见的有用 xml 来进行配置项目，这需要预先定义好一些规范，只有按照预先定义好的规范书写配置文件，才能得到正确的解析。解析其实也是使用编程语言，通过读文件的形式，按照预先定义的规范，得到相应的配置。</li><li>编程语言是最高级的，其本身可以实现条件判断，循环等这样的逻辑，这是配置文件很难实现的。但是很少有用编程语言来直接表述一项任务的，因为其缺乏像配置文件那样简介的语义。</li><li>DSL 则介于两者之间，即有像配置文件那样清晰的语义，即很强的语义表现力，同时自身也具备一定的逻辑。</li></ul><p>然而 DSL 的应用领域非常有限，没有必要单独为其开发一款语言。就像 xml 中的配置文件是通过高级语言解析而来，我们也可以用高级语言解析 DSL 文件，执行相关的逻辑。但是与 xml 配置文件不同的是，xml 配置文件需要预先定义规范。而 DSL 不需要定义规范，其语法受到现有语言的约束，不用使用任何解析器，而是巧妙的讲语法映射到底层语言中的方法和属性，这样使得用户在使用起来可能意识不到自己正在使用的是一门更广泛的语言的语法。</p><p>DSL 的两个显著特点：</p><ul><li>上下文相关</li><li>流畅的调用</li></ul><p>鉴于 Groovy 动态特性和元编程能力，其很适合作为 DSL 底层的解析语言。接下来探讨在 Groovy 的基础上构建 DSL。</p><p>对于 Groovy 来说，一个伟大的 DSL 产物就是新一代构建工具——Gradle。</p><a id="more"></a><h1 id="利用闭包实现上下文相关性"><a href="#利用闭包实现上下文相关性" class="headerlink" title="利用闭包实现上下文相关性"></a>利用闭包实现上下文相关性</h1><p>上下文：就是一个特定的语境，在这个语境下，大家没有必要一直重申这一语境前提，而是所有的逻辑都在这个前提下执行。<br>看如下 Groovy 代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">list.add(<span class="number">3</span>)</span><br><span class="line">list.add(<span class="number">4</span>)</span><br><span class="line">println list.size()</span><br></pre></td></tr></table></figure><p>在上面的代码中，每条语句都是针对 list 的，但是每条语句都重复声明了 list 的语境，未免有些啰嗦，于是 groovy 提供了 with()方法，用来设置上下文，上面的代码可以修改为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">list.with&#123;</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">4</span>)</span><br><span class="line">println size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了闭包，将闭包中的语句的上下文路由到 list。原因是 with 中的闭包将其 delegate 设置到了调用 with 的对象上。</p><p>同时注意到这里 with 的原型是 <code>with(closure)</code>，当一个方法的最后一个参数是闭包，同时我们传入的是一个匿名闭包时，那么其调用的方式就是上述 with 的形式，这不是方法的定义，而是方法的调用，只不过后面的闭包是作为方法的最后一个参数，单独拿出来了。单独拿出来比写在括号内，语法更加简洁。因为花括号后面在跟一个右括号总感觉破坏了代码的优美性。</p><p>受到 Groovy 所提供的 with 的启发，我们也可以仿照 with 的实现方式，提供类似的上下文执行环境，实现我们的 DSL。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> addList(closure)&#123;</span><br><span class="line">list = []</span><br><span class="line">closure.delegate = list</span><br><span class="line">closure()</span><br><span class="line">list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 addList 提供的上下文特性，想 list 中添加元素</span></span><br><span class="line">list = addList()&#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">3</span>)</span><br><span class="line">    size()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println list</span><br></pre></td></tr></table></figure><p>通过将闭包的代理进行配置，自然就提供了一个统一的上下文环境，这样我们在闭包中调用的任何方法，都是基于之前设置的代理的，这一方法在 gradle 中是很常见的。</p><h1 id="Groovy-针对流畅性的先天优势"><a href="#Groovy-针对流畅性的先天优势" class="headerlink" title="Groovy 针对流畅性的先天优势"></a>Groovy 针对流畅性的先天优势</h1><p>流畅性可以提高代码的可读性，使代码自然流动。</p><p>Groovy 所具备的天然的优势有：</p><ul><li>动态类型和可选类型</li><li>动态加载，操作和执行脚本的灵活性</li><li>分类和 ExpandoMetaClass 可以扩展已有类的功能</li><li>闭包为执行提供很好的上下文</li><li>操作符的重载可以使我们自由的定义操作符</li></ul><h2 id="灵活的方法调用语法"><a href="#灵活的方法调用语法" class="headerlink" title="灵活的方法调用语法"></a>灵活的方法调用语法</h2><p>如果方法是<strong>有返回值</strong>的，那么在调用时可以不使用点符号(.) 而是用空格将调用者和方法分开，就能在返回的这个实例上进行连续的调用</p><h2 id="灵活的括号语法"><a href="#灵活的括号语法" class="headerlink" title="灵活的括号语法"></a>灵活的括号语法</h2><p>当调用的方法需要参数时，Groovy 不要求使用括号，若有多个参数，那么参数之间依然使用逗号分隔；如果不需要参数，那么方法的调用必须显示的使用括号。</p><h2 id="让无参数的方法调用也不需要括号"><a href="#让无参数的方法调用也不需要括号" class="headerlink" title="让无参数的方法调用也不需要括号"></a>让无参数的方法调用也不需要括号</h2><p>为了和有参数的方法调用时不使用括号的语法，统一风格，我们设法让无参数的方法调用也不需要括号。当然这个功能是 Groovy 自身不支持的。直接这样调用，Groovy 会认为这是在访问一个属性，那么我们结合 Groovy 中对属性的访问就是对 getXXX 的访问，将无参数的方法名改成 getXXX 的形式，即可实现“调用无参数的方法不需要括号”的语法！</p><p>结合刚刚提到的三点，我们设计一个 DSL 计算器：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> getClear() &#123; value = <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">def</span> add(number) &#123; value += number &#125;</span><br><span class="line"><span class="keyword">def</span> getTotal() &#123; println <span class="string">"Total is #value"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来开始使用这一简介的 DSL</span></span><br><span class="line">clear</span><br><span class="line">add <span class="number">2</span></span><br><span class="line">add <span class="number">5</span></span><br><span class="line">total</span><br></pre></td></tr></table></figure><p>由上面的 groovy 创建的简易加法器的 DSL，可以感受到其强大的流畅性。我们在调用时，甚至都可能意识不到这是代码，而是一些配置文件或者普通的文字描述，但这确实是 Groovy 代码。</p><p>接下来提供一组这样的数据，进一步解读 DSL。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump fast,forward turn right move ahead</span><br></pre></td></tr></table></figure><p>上面的依旧是 Groovy 代码，首先是 jump 方法的调用，其接受两个参数 fast 和 forward，该方法的返回值类型上有一个 turn 方法，其接受一个 right 参数，同时方法的返回值类型上有一个 move 方法，其接受一个 ahead 参数。这就是 DSL 强大的表现力。其底层就可以用之前讲到的 Groovy 特性提供技术支持。</p><h2 id="MOP-与-DSL"><a href="#MOP-与-DSL" class="headerlink" title="MOP 与 DSL"></a>MOP 与 DSL</h2><p>接下来使用 MOP 中的方法合成</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">detailInfo = [:]</span><br><span class="line"><span class="keyword">def</span> methodMissing(String name,args)&#123;</span><br><span class="line">    detailInfo[name] = args</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> introduce(closure)&#123;</span><br><span class="line">    closure.delegate = <span class="keyword">this</span></span><br><span class="line">    closure()</span><br><span class="line">    println <span class="string">"hello,everyone"</span></span><br><span class="line">    detailInfo.each&#123;</span><br><span class="line">        key,value -&gt;</span><br><span class="line">            println <span class="string">"My $key is $value"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">introduce&#123;</span><br><span class="line">    name <span class="string">"zx"</span></span><br><span class="line">    age <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，利用 Groovy 的 MOP 能力，设计与执行 DSL 将变得非常容易。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOP总结</title>
      <link href="/2017/12/12/MOP%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/12/MOP%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>之前介绍了基于 MOP的技术：</p><ul><li><a href="https://zachaxy.github.io/2017/12/09/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/">MOP——方法拦截</a></li><li><a href="https://zachaxy.github.io/2017/12/10/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5/">MOP——方法注入</a></li><li><a href="https://zachaxy.github.io/2017/12/11/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E5%90%88%E6%88%90/">MOP——方法合成</a></li></ul><p>接下来对 MOP 的这三种技术的使用做一个汇总</p><a id="more"></a><h1 id="在运行时创建类。"><a href="#在运行时创建类。" class="headerlink" title="在运行时创建类。"></a>在运行时创建类。</h1><p>经过之前的讲解，我们可以发现，正是 MOP 的出现，使得 Groovy 变得非常灵活，可以改变已有类的结构，拦截或添加方法等，这为我们的开发工作提供了极大的便利性。既然可以扩展已有的类，那么我们也可以借助 MOP 来动态的创建一个类。这里需要借助 MOP 为我们提供的而一个类——Expando 类。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">man = <span class="keyword">new</span> Expando()</span><br><span class="line">man.name = <span class="string">'zx'</span></span><br><span class="line">man.age = <span class="number">18</span></span><br><span class="line">man.work = &#123; <span class="string">"working"</span> &#125;</span><br><span class="line"></span><br><span class="line">println man</span><br><span class="line">println man.work()</span><br></pre></td></tr></table></figure><p>Expando 像是一个可以容纳任何属性的类，我们可以为其添加任意的属性，任意的方法(以闭包的形式)，其实无论是属性，还是闭包，都被保存在 Expand 中的 Map 中，key 对应属性\闭包名，value 对应属性值，或者闭包体</p><h1 id="关于拦截-注入-合成"><a href="#关于拦截-注入-合成" class="headerlink" title="关于拦截/注入/合成"></a>关于拦截/注入/合成</h1><p>经过之前三篇的学习，我们了解到，无论是拦截，注入，还是合成。每种技术都有若干实现方式。但是都不可避免的用到 MetaClass 这个类。拦截时，向其中注入了 invokeMethod 方法；合成时，向其中注入了 methodMissing 方法。注入的都是闭包，但是调用时如果找不到对应的方法，那么就会从闭包中找对应的名字，同时闭包的参数要和对应的方法相同。</p><ul><li>对于拦截，如果我们能修改类，就实现 GroovyInterceptable 接口，并实现 invokeMethod 方法；否则就在 ClassName.metaClass 上注入 invokeMethod</li><li>对于合成，如果我们能修改类，就在类中重写 methodMissing 方法；否则就在 ClassName.metaClass 上注入 methodMissing</li><li>对于注入，如果注入的方法在之前的类中已经实现过了，同时又在 ClassName.metaClass 上进行了注入，那么 metaClass 上的方法会优先执行。</li></ul><p>相信到这里在看这幅图应该更容易理解：<br><img src="http://docs.groovy-lang.org/next/html/documentation/assets/img/xGroovyInterceptions.png.pagespeed.ic.lQZRl0FSbC.webp" alt="Groovy interception mechanism"></p><h1 id="一个综合应用"><a href="#一个综合应用" class="headerlink" title="一个综合应用"></a>一个综合应用</h1><p>之前将的 MOP 的三大技术是分开来讲的，现在把这三个技术融合起来，实现这样一个场景，对于一个类，我们调用其方法，如果存在，就执行其本身的方法，如果不存在就进行方法合成。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> &#123;</span></span><br><span class="line"><span class="keyword">def</span> work()&#123;</span><br><span class="line"><span class="string">"I can work"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.metaClass.invokeMethod = &#123;</span><br><span class="line">String name,args -&gt;</span><br><span class="line"><span class="keyword">def</span> method = Man.metaClass.getMetaClass(name,args)</span><br><span class="line"><span class="keyword">if</span>(method)&#123;</span><br><span class="line">method.invoke(delegate,args)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Man.metaClass.invokeMissingMethod(delegate,name,args)</span><br><span class="line"><span class="comment">//或者执行下面的方法，metaClass 中如果没有 invokeMethod 方法，那么会调用 metaClass 中的 methodMissing 方法，但是不如上面直接调用来的直观</span></span><br><span class="line"><span class="comment">//Man.metaClass.invokeMethod(delegate,name,args)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.metaClass.methodMissing = &#123;</span><br><span class="line">String name,args -&gt;</span><br><span class="line">    <span class="keyword">def</span> skills = [<span class="string">"run"</span>,<span class="string">"sing"</span>,<span class="string">"dance"</span>,<span class="string">"talk"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skills.contains(name))&#123;</span><br><span class="line">    <span class="keyword">def</span> impl = &#123;</span><br><span class="line">    Object[] vars -&gt;</span><br><span class="line">         <span class="string">"I can "</span> + name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Man.metaClass.<span class="string">"$name"</span> = impl</span><br><span class="line"></span><br><span class="line">    impl(args)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MissingMethodException(name,Man.<span class="keyword">class</span>,args)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，首先使用拦截技术，将所有的方法调用拦截住(MetaClass 注入 invokeMethod 方法)，然后分析本类是否可以执行该方法，如果可以路由给原本的方法，如果不可以那么执行合成(MetaClass 注入 methodMissing 方法)。</p><p>这里注意到一个细节：我们在方法合成之后，先将合成的方法注入到 MetaClass 中，这样在第二次调用的时候，就不会在此合成了，而是直接调用，大大提高的执行效率</p>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOP——方法合成</title>
      <link href="/2017/12/11/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E5%90%88%E6%88%90/"/>
      <url>/2017/12/11/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E5%90%88%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>前面<a href="https://zachaxy.github.io/2017/12/10/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5/">MOP——方法注入</a>介绍了利用 MOP 对方法的调用进行注入，接下来要介绍利用 MOP 实现方法的合成。</p><p>合成：在运行期，根据输入状态的不同，动态的生成一个方法。<br>这里要注意的是：方法合成，在运行时动态的生成方法，看起来很智能，但是合成是有前提的，就是调用的方法的方法名必须要符合预先定义好的规范，才能生成。</p><p>同样，这里要和前面的方法注入区分开：<br>方法的合成和注入看起来似乎相同，都是向类中添加方法，以扩展类的功能，但这里也是有区别的：</p><ul><li>注入是已经知道要注入的方法名了，是发生在编译期的。</li><li>合成是在编译期还不知道方法名，只有在调用的时候，发现并没有对应的方法，所以动态的生成该方法，然后并调用。<br>合成强调的是在运行时，注入强调的是在编译期；</li></ul><p>实现方法合成有以下两种方式：</p><ul><li>使用 methodMissing 合成方法</li><li>使用 ExpandoMetaClass 合成方法</li></ul><a id="more"></a><h1 id="使用-methodMissing-合成方法"><a href="#使用-methodMissing-合成方法" class="headerlink" title="使用 methodMissing 合成方法"></a>使用 methodMissing 合成方法</h1><p>首先明确以下方法合成的使用场景：其发生在对象调用了一个自身并不存在的方法，正常情况下会抛出异常，但是我们想根据调用的方法动态去生成一个对应的方法并执行。那么生成对应的方法这个步骤需要首先汇总到一个方法中——methodMissing，然后在该方法中，实现我们合成方法的逻辑。还是要注意，不是随意调用一个方法都能合成的，没有那么只能，必须符合预先设定好的规则。例如我们预先为一个人设定好其技能列表，但是不生成具体的方法，因为不知道外界会不会调用这些方法，如果全部实现一遍，到时候又可能用不到，所以需要在运行时，动态生成。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> skills = [<span class="string">"run"</span>,<span class="string">"sing"</span>,<span class="string">"dance"</span>,<span class="string">"talk"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> methodMissing(String name,args)&#123;</span><br><span class="line">        <span class="keyword">if</span> (skills.contains(name))&#123;</span><br><span class="line">            println <span class="string">"I can "</span> + name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">man = <span class="keyword">new</span> Man()</span><br><span class="line">man.dance()</span><br></pre></td></tr></table></figure><h1 id="使用-ExpandoMetaClass-合成方法"><a href="#使用-ExpandoMetaClass-合成方法" class="headerlink" title="使用 ExpandoMetaClass 合成方法"></a>使用 ExpandoMetaClass 合成方法</h1><p>当我们无法编辑类的源文件，那么就无法使用上面的方法了，对于这类情况，依然可以使用 ExpandoMetaClass 来合成方法，在<a href="https://zachaxy.github.io/2017/12/10/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5/">MOP——方法注入</a>中有提到过向 ExpandoMetaClass 中来注入方法，这里我们依然可以将 methodMissing 方法注入到 ExpandoMetaClass，从而实现方法合成。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.metaClass.methodMissing = &#123; String name,args -&gt;</span><br><span class="line">    <span class="keyword">def</span> skills = [<span class="string">"run"</span>,<span class="string">"sing"</span>,<span class="string">"dance"</span>,<span class="string">"talk"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skills.contains(name))&#123;</span><br><span class="line">        println <span class="string">"I can "</span> + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man = <span class="keyword">new</span> Man()</span><br><span class="line">man.dance()</span><br></pre></td></tr></table></figure><h1 id="为具体实例合成方法"><a href="#为具体实例合成方法" class="headerlink" title="为具体实例合成方法"></a>为具体实例合成方法</h1><p>就像为具体实例注入方法一样，我们也可以为具体实例合成方法，其代码也是类似的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> emc = <span class="keyword">new</span> ExpandoMetaClass(Man)</span><br><span class="line">emc.methodMissing = &#123; String name,args -&gt;</span><br><span class="line">    <span class="keyword">def</span> skills = [<span class="string">"run"</span>,<span class="string">"sing"</span>,<span class="string">"dance"</span>,<span class="string">"talk"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skills.contains(name))&#123;</span><br><span class="line">        println <span class="string">"I can "</span> + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">emc.initialize()</span><br><span class="line"><span class="keyword">def</span> mike = <span class="keyword">new</span> Man()</span><br><span class="line">mike.metaClass = emc</span><br><span class="line">mike.sing()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOP——方法注入</title>
      <link href="/2017/12/10/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5/"/>
      <url>/2017/12/10/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>前面<a href="https://zachaxy.github.io/2017/12/09/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/">MOP——方法拦截</a>介绍了利用 MOP 对方法的调用进行拦截，接下来要介绍利用 MOP 实现方法的注入。</p><h1 id="方法拦截和方法注入的区别"><a href="#方法拦截和方法注入的区别" class="headerlink" title="方法拦截和方法注入的区别"></a>方法拦截和方法注入的区别</h1><p>拦截：侧重对于<strong>已有的方法</strong>的调用进行拦截<br>注入：对一个已有的类<strong>添加新方法</strong>，以拓展该类的功能。</p><p>eg：Java 中提供了 String 的类，如果我们想扩展该类，为其提供一个字符串加密方法。在 Java 中，最常见的做法是提供一个接口，内有 encrypt() 方法，让目标类实现该接口；或者继承该类，然后添加一个 encrypt() 方法。但是这里存在的问题是：我们未必可以修改想要扩展的类，就像 String，还是 final 的，只能用，不能改。</p><p>不过使用 Groovy，就可以方便的为任何类扩展方法，同时在使用起来，给人的感觉就好像注入的类是该类本身就有的。</p><p>MOP 的注入有四种实现方式：</p><ol><li>分类(Category)</li><li>ExpandoMetaClass</li><li>Minxin</li><li>trait</li></ol><a id="more"></a><h1 id="使用分类进行方法注入"><a href="#使用分类进行方法注入" class="headerlink" title="使用分类进行方法注入"></a>使用分类进行方法注入</h1><p>第一次接触 Category 的概念是在学习 Objective-C 的时候，只要自定义一个和目标类相同的类，然后在自定义类中添加方法，那么在方法调用时，会先从自定义的类中查找，找不到后再去原本的类中查找。这样一来不仅可以扩展类的方法，同时还可以覆盖原有类的方法。Objective-C 中 Category 感觉是最优雅的方式了。而 Groovy 中的 Category 就逊色的多，接下来看一下 Groovy 中 Category 的使用方法，这里以向 String 中添加一个 encrypt 方法为例。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> encrypt(String self) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] arr = self.bytes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="number">127</span> - arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(arr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerUtils</span>&#123;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> add(Integer a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use(StringUtils,IntegerUtils) &#123;</span><br><span class="line">    String str = <span class="string">"hello"</span></span><br><span class="line">    s = str.encrypt()</span><br><span class="line">    println <span class="number">1.</span>add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先定义了一个的类，其中定义了一个方法 encrypt(),要想要该类成为 String 的分类，需要注意以下几点：</p><ol><li>其内部定义的方法必须为 <code>static</code></li><li>方法的第一个参数必须定位为目标类的类型(eg：这里定义的 String，当然你可以不写类型，这样就有可能让多个类都是用该方法了),如果该方法还需要参数，那么就从第二个形参开始声明。</li><li>第一个参数如果声明类型，必须为包装类的类型，eg：如果我们想为整数提供方法，即使用到了 <code>1.add(2)</code> 这样的调用方式，但这是 groovy 提供的语法糖，其本质任为 Integer，因此在定义分类的方法时，第一个参数必须是包装类型</li></ol><p>在使用时，其必须在 use 所定义的代码块中，出了代码块就无法使用分类中的方法了，否则报找不到方法的错误。在 use 后面必须注明要注入的方法所在的类，eg：use(StringUtils)，use 中可以注入多个类，如果多个分类中有重复的方法定义，那么以最后一个分类中方法为准。</p><h1 id="使用-ExpandoMetaClass-进行方法注入"><a href="#使用-ExpandoMetaClass-进行方法注入" class="headerlink" title="使用 ExpandoMetaClass 进行方法注入"></a>使用 ExpandoMetaClass 进行方法注入</h1><h2 id="注入概述"><a href="#注入概述" class="headerlink" title="注入概述"></a>注入概述</h2><p>之前其实我们已经见到过使用 ExpandoMetaClass 注入方法的示例了，就是使用<a href>MetaClass 进行方法拦截</a>，这本质就是方法的注入，只不过注入的方法名(invokeMethod)比较特殊，成为了方法拦截。同样，我们也可以用 ExpandoMetaClass 对类进行其它方法的注入，还拿上面 Integer 的加法的例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer.metaClass.add = &#123;</span><br><span class="line">    <span class="keyword">int</span> i -&gt;</span><br><span class="line">        delegate + i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println <span class="number">1.</span>add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="注入的种类"><a href="#注入的种类" class="headerlink" title="注入的种类"></a>注入的种类</h2><p>使用 ExpandoMetaClass 方法注入，可以对以下三种方法进行注入：</p><ul><li>非静态方法</li><li>静态方法</li><li>构造器</li><li>属性</li></ul><p>接下来一一介绍如何注入：</p><ol><li><p>非静态方法注入<br>这在前面已经见到过了，也是最常用的注入，使用方法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo.metaClass.bar = &#123;&#125;</span><br><span class="line">foo.bar()</span><br></pre></td></tr></table></figure><p>Groovy 的设计理念就是让程序的编写更加流程，因此在 DSL 中，可能更常见的一种形式是在调用方法时不写括号，即<code>foo.bar</code>但是没有括号调用时，会将方法的调用当成属性，所以需要对之前的注入进行修改。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo.metaClass.getBar = &#123;&#125;</span><br><span class="line">foo.bar</span><br></pre></td></tr></table></figure><p>这样的调用方式是否更加优雅呢，在后面的 DSL 中，还会进一步讲解 groovy 的语法糖，让编程更加优雅。</p></li><li><p>静态方法注入<br>需要使用 <code>&#39;static&#39;</code> 的特殊字面量注入静态方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo.metaClass.<span class="string">'static'</span>.bar = &#123;&#125;</span><br><span class="line">Foo.bar()</span><br></pre></td></tr></table></figure></li><li><p>注入构造器<br>使用 <code>constructor</code> 属性注入构造器<br>添加一个构造器 &lt;&lt;<br>替换一个构造器 =</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo.metaClass.constructor &lt;&lt; &#123; </span><br><span class="line"><span class="keyword">int</span> i -&gt; </span><br><span class="line">Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.i = i</span><br><span class="line">foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法注入特别要注意的是，要确保没有递归调用自身，否则栈溢出。因为我们是想定义构造器，肯定会借助现有的构造器，然后进行属性的改造，但是不要产生递归。如果是想覆盖构造器的话，那么只能在内部使用反射</p></li><li><p>注入属性<br>类似以闭包的方式注入方法，属性注入也是支持的，只要在后面 = 具体值 即可。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo.metaClass.bar = <span class="number">1</span></span><br><span class="line">println foo.bar</span><br></pre></td></tr></table></figure></li><li><p>一次注入多个方法<br>Groovy 提供了使用<code>ClassName.metaClass.method = { ... }</code>这样的语法向 metaClass 中添加，既简单又方便，但如果想添加一堆方法，这样的声明就会感觉很费劲。groovy 提供了更简洁的语法，用来减少噪音！！这种方式也是在 DSL 中常见到的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Foo.metaClass = &#123;</span><br><span class="line">bar1 = &#123;&#125;</span><br><span class="line">bar2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'static'</span>&#123;</span><br><span class="line">bar3 = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//针对于不管是覆盖还是注入，在这种语法环境下，都应该使用 = </span></span><br><span class="line">constructor = &#123;</span><br><span class="line"><span class="keyword">int</span> i - &gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constructor = &#123;</span><br><span class="line"><span class="keyword">int</span> i,<span class="keyword">int</span> j -&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>再次重申：使用 ExpandoMetaClass 注入的闭包中，delegate 指的是调用该方法的对象，在此基础上，闭包中使用类原本的成员变量，或者方法也是可以的。</strong></p><h2 id="向单个实例中注入方法"><a href="#向单个实例中注入方法" class="headerlink" title="向单个实例中注入方法"></a>向单个实例中注入方法</h2><p>前面介绍的是向整个类中注入方法，那么基于该类的所有对象都可以使用闭包中的方法。如果只是想扩展该类的某一个对象的方法，而不影响该类的其它对象，该如何处理呢？<br>其实不单是 Class，每个具体的对象也包含一个 metaClass，我们可将创建一个具体的 ExpandoMetaClass 实例，并将制定方法加入其中，然后将其赋给对应的具体对象，也可以将方法直接注入到具体的对象的 metaClass 上。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>&#123;</span></span><br><span class="line"><span class="keyword">def</span> talk()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> emc = <span class="keyword">new</span> ExpandoMetaClass(Man)</span><br><span class="line">emc.sing = &#123; -&gt; ... &#125;</span><br><span class="line">emc.initialize()</span><br><span class="line"><span class="keyword">def</span> mike = <span class="keyword">new</span> Man()</span><br><span class="line">mile.metaClass = emc</span><br><span class="line">mike.sing()</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式 2</span></span><br><span class="line">mike.metaClass.dance = &#123; -&gt; ...&#125;</span><br><span class="line">mike.dance()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载之前注入的方法</span></span><br><span class="line">mike.metaClass = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>很明显方式 2 是最为优雅的，因此推荐使用方式 2。同时，当我们为一个对象注入了方法，在使用了一段时间不想使用后，那么很方便的卸载之前注入的方法。</p><h2 id="ExpandoMetaClass-小结"><a href="#ExpandoMetaClass-小结" class="headerlink" title="ExpandoMetaClass 小结"></a>ExpandoMetaClass 小结</h2><p>使用 ExpandoMetaClass，无论是注入方法，还是调用方法，都比 Category 要优雅的多。因此推荐使用该方法。<br>但是要注意的是，如果对象想使用注入的方法，必须要先进行注入。如果在已经有对象产生之后再向类中注入方法，那么该对象无法调用注入的方法！！<br>因此使用 ExpandoMetaClass 进行注入，最好是在整个应用初始化时进行。</p><p>同时方法注入具有继承性。如果向 Object 注入了方法，那么所有的类都可以使用该方法。</p><h1 id="使用-Minxin，trait-进行方法注入"><a href="#使用-Minxin，trait-进行方法注入" class="headerlink" title="使用 Minxin，trait 进行方法注入"></a>使用 Minxin，trait 进行方法注入</h1><p>这两种方式更像是开头提到的定义接口的实现方式。<br>个人感觉最为强大的方式是 Mixin 的方式。可以为类注入多个 Mixin，就好想让类实现了多个接口，同时接口中相同的方法，以后面加入的为准。<br>这里不再重点展开了。<br><a href="http://blog.csdn.net/chennai1101/article/details/56282305" target="_blank" rel="noopener">Groovy Mixin 注入</a><br><a href="https://www.mscharhag.com/groovy/groovy-introduces-traits" target="_blank" rel="noopener">Groovy 2.3 introduces traits</a><br><a href="https://www.ibm.com/developerworks/library/j-jn8/index.html" target="_blank" rel="noopener">Mixins and traits</a></p><h1 id="实现方式的优劣对比"><a href="#实现方式的优劣对比" class="headerlink" title="实现方式的优劣对比"></a>实现方式的优劣对比</h1><ul><li><p>Category 存在的问题:其作用被限定在 use()块内，所以也就限定于当前执行的线程。进入该 use()块内的代码会在当前线程创建一个栈帧，并压入到当前线程的栈上，而当 use 代码块结束后，当前线程的栈会将刚刚压入的栈帧弹栈。但是如果频繁的调用 use 代码块，势必会对性能造成一定的影响。</p><p>凡事都有两面性，Categoty 的使用 use 块，提供了更好的隔离性，我们可以再不同的地方，使用不同的分类，这也为类的扩展提供了灵活性。</p></li><li><p>trait：缺点是在有类的修改权的情况下才能使用，类似接口。</p></li><li><p>Mixin：其实是最强大的方式，但需要对其有进一步的了解，以防走火。。</p></li></ul><p>这里推荐使用 <strong>ExpandoMetaClass。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOP——方法拦截</title>
      <link href="/2017/12/09/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/"/>
      <url>/2017/12/09/MOP%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<p>前面<a href="https://zachaxy.github.io/2017/12/08/Groovy%E5%AF%B9%E8%B1%A1%E5%92%8CMOP/">Groovy 对象和 MOP</a>简单了介绍了 Groovy 所提供的 MOP 机制。<br>接下来要介绍利用 MOP 实现方法的拦截。<br>拦截：在对方法进行调用时，我们可能有一些其它的要求，eg：日志的记录，执行时间的记录等，在 Java 可以 AOP 对方法的调用进行拦截，插入我们想执行的方法。而 Groovy 提供的 MOP 机制可以更为轻松的实现对方法的拦截。</p><p>MOP 的拦截有两种实现方式：</p><ol><li>实现 GroovyInterceptable 接口进行拦截</li><li>利用 MetaClass 进行拦截</li></ol><a id="more"></a><h2 id="实现-GroovyInterceptable-接口进行拦截"><a href="#实现-GroovyInterceptable-接口进行拦截" class="headerlink" title="实现 GroovyInterceptable 接口进行拦截"></a>实现 GroovyInterceptable 接口进行拦截</h2><p>对于一个想要拦截方法的 Groovy 对象，要先实现 GroovyInterceptable 接口，然后务必重写其中的 invokeMethod()方法。我们拦截处理的逻辑都在这个方法中实现。<br>接下来在调用该类的<strong>任何方法</strong>的时候，都会被路由到 invokeMethod 方法中。我们可以在 invokeMethod 方法中，根据被拦截的方法名，来加入我们要记录的内容，然后将方法在路由到具体实际的方法中。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">GroovyInterceptable</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> talk() &#123;</span><br><span class="line">        System.out.println <span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> run() &#123;</span><br><span class="line">        System.out.println <span class="string">"running"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> invokeMethod(String name, args) &#123;</span><br><span class="line">        System.out.println(<span class="string">"start call method: "</span> + name);</span><br><span class="line">        <span class="keyword">def</span> targetMethod = Man.metaClass.getMetaMethod(name, args)</span><br><span class="line">        targetMethod.invoke(<span class="keyword">this</span>,args)</span><br><span class="line">        System.out.println(<span class="string">"end call method: "</span> + name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">man = <span class="keyword">new</span> Man()</span><br><span class="line"></span><br><span class="line">man.talk()</span><br><span class="line">man.run()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start call method: talk</span><br><span class="line">hello</span><br><span class="line">end call method: talk</span><br><span class="line">start call method: run</span><br><span class="line">running</span><br><span class="line">end call method: run</span><br></pre></td></tr></table></figure><p>man 调用的所有方法都被拦截到了 invokeMethod 方法中。</p><p>这里要注意的有两点：</p><ol><li>不仅我们调用的方法会被拦截，方法内使用的 Groovy 上的方法(eg：<code>println()</code>方法)同样也会被拦截。所以这里使用了<code>System.out.println()</code>方法，因为其是 Java 上的方法，不会受到拦截的影响，我们这个例子很简单，如果拦截的方法内部使用了 Groovy 中的方法，那么很可能会产生递归调用，导致栈溢出。</li><li>在 invokeMethod 方法中，利用类似反射的手段，根据方法名找到对应的方法，其返回值在 Groovy 中是 MetaMethod，其类型和 Java 中的 Method 类型相似，这里用 targetMethod 表示返回值，但是这里必须显示的使用 def 定义 targetMethod,否则报错<code>groovy.lang.MissingPropertyException: No such property: targetMethod for class: Man</code> 原因可参考<a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank" rel="noopener">深入理解 Android（一）：Gradle 详解</a>中<code>脚本中的变量和作用域</code>一节的讲解。</li></ol><p>额(⊙o⊙)…坑好多</p><h2 id="利用-MetaClass-进行拦截"><a href="#利用-MetaClass-进行拦截" class="headerlink" title="利用 MetaClass 进行拦截"></a>利用 MetaClass 进行拦截</h2><p>使用 MetaClass 重写上述的方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> talk() &#123;</span><br><span class="line">        System.out.println <span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> run() &#123;</span><br><span class="line">        System.out.println <span class="string">"running"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Man.metaClass.invokeMethod = &#123;</span><br><span class="line">    String name, args -&gt;</span><br><span class="line">        System.out.println(<span class="string">"start call method: "</span> + name);</span><br><span class="line">        targetMethod = Man.metaClass.getMetaMethod(name, args)</span><br><span class="line">        targetMethod.invoke(delegate, args)</span><br><span class="line">        System.out.println(<span class="string">"end call method: "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">man = <span class="keyword">new</span> Man()</span><br><span class="line"></span><br><span class="line">man.talk()</span><br><span class="line">man.run()</span><br></pre></td></tr></table></figure><p>其结果和实现 GroovyInterceptable 接口的结果相同</p><p>这里要注意的是：</p><ol><li>这里将一个闭包赋给了 Man.metaClass 的 invokeMethod，也就是间接的实现了 invokeMethod 方法。因为 groovy 中调用方法时，如果找不到对应的方法名，会从该类的闭包中查找是否有相同的名字，若该闭包的参数也符合，那么就会直接调用该闭包。如果你一时接受不了这种方式，你可以重新创建一个 MetaClass 的实例，重写 invokeMethod 方法，然后将自己实现 metaClass 赋给 Man.metaClass，两种方式是等价的，但是明显前者的方式更简洁。</li><li>实现的闭包中一定注意其有两个参数。否则依然无法实现拦截</li><li>在闭包中，不用为 targetMethod 加 def 的定义</li><li>执行方法时，调用 invoke 方法，第一个参数要传 delegate。因为这是在闭包中。</li></ol><p><strong>所有形如 Foo.metaClass.bar = { delegate } 的闭包中出现的 delegate，该 delegate 代表的就是调用 bar 方法的 Foo 实例对象</strong></p><h2 id="两种拦截方法的使用场景"><a href="#两种拦截方法的使用场景" class="headerlink" title="两种拦截方法的使用场景"></a>两种拦截方法的使用场景</h2><p>第一种需要实习接口，这就需要我们可以修改该类的源码才能让该类实现接口，否则只能使用第二种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy对象和MOP</title>
      <link href="/2017/12/08/Groovy%E5%AF%B9%E8%B1%A1%E5%92%8CMOP/"/>
      <url>/2017/12/08/Groovy%E5%AF%B9%E8%B1%A1%E5%92%8CMOP/</url>
      
        <content type="html"><![CDATA[<h1 id="Groovy-对象"><a href="#Groovy-对象" class="headerlink" title="Groovy 对象"></a>Groovy 对象</h1><p>Groovy 中的对象其实本质也是 Java 对象，只不过比 Java 对象附加了一些其它的功能。在 Groovy 中的对象，其顶级父类也是 <code>java.lang.Object</code>，同时其也实现了 <code>groovy.lang.GroovyObject</code> 接口。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyObject</span> &#123;</span></span><br><span class="line">    Object invokeMethod(String name, Object args);</span><br><span class="line"></span><br><span class="line">    Object getProperty(String propertyName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setProperty(String propertyName, Object newValue);</span><br><span class="line"></span><br><span class="line">    MetaClass getMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setMetaClass(MetaClass metaClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 Groovy 中的对象是可以直接调用 GroovyObject 接口中的方法，然而我们定义的 Groovy 类中没有自己实现过该接口中的任何方法，因此其必定有一个类帮我们实现好了这些方法。现在还未得到证实，但是我猜测是 GroovyObjectSupport 这个类提供的实现，并且在运行时注入到了我们的 Groovy 类中，所以我们才能调用这些方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyObjectSupport</span> <span class="keyword">implements</span> <span class="title">GroovyObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// never persist the MetaClass</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> MetaClass metaClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GroovyObjectSupport() &#123;</span><br><span class="line">        <span class="keyword">this</span>.metaClass = InvokerHelper.getMetaClass(<span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object getProperty(String property) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMetaClass().getProperty(<span class="keyword">this</span>, property);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setProperty(String property, Object newValue) &#123;</span><br><span class="line">        getMetaClass().setProperty(<span class="keyword">this</span>, property, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object invokeMethod(String name, Object args) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMetaClass().invokeMethod(<span class="keyword">this</span>, name, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MetaClass getMetaClass() &#123;</span><br><span class="line">        <span class="keyword">if</span> (metaClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            metaClass = InvokerHelper.getMetaClass(getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> metaClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setMetaClass(MetaClass metaClass) &#123;</span><br><span class="line">        <span class="keyword">this</span>.metaClass = metaClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点关注一个对象 MetaClass。在 Groovy 的世界中，每个对象(不管是 Groovy 对象还是 Java 对象)都包含一个 MetaClass 对象，该 MetaClass 对象持有其所依附的对象的所有信息(包括属性和方法)，每当我们调用一个对象的方法时，都是由该 MetaClass 对象负责路由对方法的调用。我们知道一旦一个类被加载进 JVM，那么这个类就无法修改了，但是我们可以修改这个类的 MetaClass 对象，从而实现对类动态的添加方法和行为。</p><p>Groovy 中还有一种特殊的对象——实现了 GroovyInterceptable 接口的类，GroovyInterceptable 接口是一个标记接口，其扩展了 GroovyObject，对于实现了该接口的对象而言，只要调用该对象上的任何方法，都会被 invokeMethod 方法拦截。(要实现拦截，不仅要在类的定义中声明实现该接口，同时还要重写其 invokeMethod 方法，才会有拦截的效果)</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyInterceptable</span> <span class="keyword">extends</span> <span class="title">GroovyObject</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Groovy-中的方法调用机制"><a href="#Groovy-中的方法调用机制" class="headerlink" title="Groovy 中的方法调用机制"></a>Groovy 中的方法调用机制</h2><p><img src="http://docs.groovy-lang.org/next/html/documentation/assets/img/xGroovyInterceptions.png.pagespeed.ic.lQZRl0FSbC.webp" alt="Groovy interception mechanism"></p><p>该图描述了 Groovy 中方法调用的路由机制。这里做以下补充：</p><ol><li>invokeMethod 方法是 GroovyObject 接口中的方法，所有的 Groovy 类都默认实现了该方法。而 GroovyInterceptable 只是一个标记接口，该接口的作用是将 invokeMethod 方法的调用时机提前到了最前面，也就是所有的方法调用都会先统一路由到 invokeMethod 方法中，若为实现 GroovyInterceptable 接口，那么 invokeMethod 方法只有最后才有机会执行。</li><li>若在类的定义中声明了 GroovyInterceptable 接口，但是在类中没有覆盖 invokeMethod 方法，则等同于没有实现 GroovyInterceptable 接口，路由转向左侧。</li><li>若未实现 GroovyInterceptable 接口，而一个类的外部直接调用了 invokeMethod 方法，那么就是方法的直接调用了，不存在拦不拦截的问题，但是如果该类中又没有覆盖 invokeMethod 方法，那么会调用 methodMissing 方法(如果有的话)</li><li>若向一个类的 metaClass 中添加了 invokeMethod 方法或者 methodMissing 方法，在外部调用一个不存在的方法时，会路由到该 invokeMethod 方法上，如果没有实现 invokeMethod 方法，那么会路由到 metaClass 上的 methodMissing 方法上(如果有的话)</li></ol><p>提供一个例子直观的感受下 groovy 的方法路由机制</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMethodInvocation</span> <span class="keyword">extends</span> <span class="title">GroovyTestCase</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> testInterceptedMethodCallonPOJO() &#123;</span><br><span class="line">        <span class="keyword">def</span> val = <span class="keyword">new</span> Integer(<span class="number">3</span>)</span><br><span class="line">        Integer.metaClass.toString = &#123; -&gt; <span class="string">'intercepted'</span> &#125;</span><br><span class="line"></span><br><span class="line">        assertEquals <span class="string">"intercepted"</span>, val.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现了 GroovyInterceptable 接口,复写 invokeMethod,那么所有的方法调用,都会被路由到 invokeMethod 中</span></span><br><span class="line">    <span class="keyword">void</span> testInterceptableCalled() &#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> AnInterceptable()</span><br><span class="line">        assertEquals <span class="string">'intercepted'</span>, obj.existingMethod()</span><br><span class="line">        assertEquals <span class="string">'intercepted'</span>, obj.nonExistingMethod()</span><br><span class="line">        assertEquals <span class="string">'intercepted'</span>, obj.invokeMethod(<span class="string">"existingMethod"</span>, <span class="literal">null</span>)</span><br><span class="line">        assertEquals <span class="string">'intercepted'</span>, obj.invokeMethod(<span class="string">"nonExistingMethod"</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testInterceptedExistingMethodCalled() &#123;</span><br><span class="line">        <span class="comment">//将原有的 ex2 方法覆盖了</span></span><br><span class="line">        AGroovyObject.metaClass.existingMethod2 = &#123; -&gt; <span class="string">'intercepted'</span> &#125;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> AGroovyObject()</span><br><span class="line">        assertEquals <span class="string">'intercepted'</span>, obj.existingMethod2()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testUnInterceptedExistingMethodCalled() &#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> AGroovyObject()</span><br><span class="line">        assertEquals <span class="string">'existingMethod'</span>, obj.existingMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testPropertyThatIsClosureCalled() &#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> AGroovyObject()</span><br><span class="line">        assertEquals <span class="string">'closure called'</span>, obj.closureProp()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testMethodMissingCalledOnlyForNonExistent() &#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> ClassWithInvokeAndMissingMethod()</span><br><span class="line">        assertEquals <span class="string">'existingMethod'</span>, obj.existingMethod()</span><br><span class="line">        assertEquals <span class="string">'missing called'</span>, obj.nonExistingMethod()</span><br><span class="line">        assertEquals <span class="string">'invoke called'</span>, obj.invokeMethod(<span class="string">"haha"</span>, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testInvokeMethodCalledForOnlyNonExistent() &#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> ClassWithInvokeOnly()</span><br><span class="line">        assertEquals <span class="string">'existingMethod'</span>, obj.existingMethod()</span><br><span class="line">        assertEquals <span class="string">'invoke called'</span>, obj.nonExistingMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> testClassWithMethodMissingOnly()&#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> ClassWithMethodMissingOnly()</span><br><span class="line">        assertEquals <span class="string">'existingMethod'</span>, obj.existingMethod()</span><br><span class="line">        assertEquals <span class="string">'missing called'</span>, obj.nonExistingMethod()</span><br><span class="line">        assertEquals <span class="string">'missing called'</span>, obj.invokeMethod(<span class="string">"haha"</span>,<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> testMethodFailsOnNonExistent() &#123;</span><br><span class="line">        <span class="keyword">def</span> obj = <span class="keyword">new</span> TestMethodInvocation()</span><br><span class="line">        shouldFail(MissingMethodException) &#123; obj.nonExistingMethod() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 GroovyInterceptable 接口,复写 invokeMethod,那么所有的方法调用,都会被路由到 invokeMethod 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnInterceptable</span> <span class="keyword">implements</span> <span class="title">GroovyInterceptable</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> existingMethod() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> invokeMethod(String name, args) &#123; <span class="string">'intercepted'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的 Groovy 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AGroovyObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> existingMethod() &#123; <span class="string">'existingMethod'</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> existingMethod2() &#123; <span class="string">'existingMethod2'</span> &#125;</span><br><span class="line">    <span class="keyword">def</span> closureProp = &#123; <span class="string">'closure called'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的 Groovy 类,并实现 invokeMethod 和 methodMissing 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithInvokeAndMissingMethod</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> existingMethod() &#123; <span class="string">'existingMethod'</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> invokeMethod(String name, args) &#123; <span class="string">'invoke called'</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> methodMissing(String name, args) &#123; <span class="string">'missing called'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的 Groovy 类,并实现 invokeMethod</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithInvokeOnly</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> existingMethod() &#123; <span class="string">'existingMethod'</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> invokeMethod(String name, args) &#123; <span class="string">'invoke called'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassWithMethodMissingOnly</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> existingMethod() &#123; <span class="string">'existingMethod'</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> methodMissing(String name, args) &#123; <span class="string">'missing called'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MOP-MetaObject-Protocol"><a href="#MOP-MetaObject-Protocol" class="headerlink" title="MOP(MetaObject Protocol)"></a>MOP(MetaObject Protocol)</h1><p>MOP：元对象协议。由 Groovy 语言中的一种协议。该协议的出现为元编程提供了优雅的解决方案。而 MOP 机制的核心就是 MetaClass。<br>元编程：编写能够操作程序的程序，也包括操作程序自身。</p><p>正是 Groovy 提供了 MOP 的机制，才使得 Groovy 对象更加灵活，我们可以根据对象的 metaClass，动态的查询对象的方法和属性。这里所属的动态指的是在运行时，根据所提供的方法或者属性的字符串，即可得到<br>有点类似于 Java 中的反射，但是在使用上却比 Java 中的反射简单的多。</p><h2 id="动态访问方法"><a href="#动态访问方法" class="headerlink" title="动态访问方法"></a>动态访问方法</h2><p>常用的方法有:</p><ul><li>getMetaMethod()</li><li>resondsTo()</li><li>hasProperty()</li><li>……  </li></ul><p>在使用了 getMetaMethod 方法得到一个 MetaMethod 后，可以调用其 invoke 方法执行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'hello'</span></span><br><span class="line">targetMethod = str.metaClass.getMetaMethod(<span class="string">'toUpperCase'</span>)</span><br><span class="line">targetMethod.invoke(str)</span><br></pre></td></tr></table></figure><h2 id="动态访问方法或属性——Groovy-的语法糖"><a href="#动态访问方法或属性——Groovy-的语法糖" class="headerlink" title="动态访问方法或属性——Groovy 的语法糖"></a>动态访问方法或属性——Groovy 的语法糖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> bar</span><br><span class="line"><span class="keyword">def</span> func1()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line">String propertyName = <span class="string">'bar'</span></span><br><span class="line">String methodName = <span class="string">'func1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问属性</span></span><br><span class="line">foo[propertyName]</span><br><span class="line">foo.<span class="string">"$propertyName"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方法</span></span><br><span class="line">foo.<span class="string">"$methodName"</span>()</span><br><span class="line">foo.invokeMethod(methodName,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下Android Studio快速上手</title>
      <link href="/2017/12/07/mac%E4%B8%8BAndroid-Studio%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2017/12/07/mac%E4%B8%8BAndroid-Studio%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>深度搜索</td><td>shift + shift</td></tr><tr><td>查找类</td><td>cmd + o</td></tr><tr><td>查找当前方法</td><td>cmd + fn + f12</td></tr><tr><td>查找当前单词</td><td>cmd + f</td></tr><tr><td>全局搜索</td><td>cmd + shift + f</td></tr><tr><td></td><td></td></tr><tr><td>格式化代码</td><td>cmd + opt + l</td></tr><tr><td></td><td></td></tr><tr><td>快速插入下一行</td><td>shift + enter</td></tr><tr><td>快速补全行末分号</td><td>cmd + shift + enter</td></tr><tr><td>基础代码补全</td><td>ctl + space</td></tr><tr><td>万能键(导入包，自动修改等)</td><td>alt + enter</td></tr><tr><td>删除不用的 import 包</td><td>ctl + opt + o</td></tr><tr><td></td><td></td></tr><tr><td>快速移动一行</td><td>cmd + shift + 上下方向键</td></tr><tr><td>选中单词</td><td>opt + 方向键上</td></tr><tr><td>列编辑</td><td>opt + 鼠标选择</td></tr><tr><td>快速移动到错误处</td><td>fn + f2</td></tr><tr><td>快速回到上一个浏览界面</td><td>cmd + opt + &lt;-/-&gt;</td></tr><tr><td></td><td></td></tr><tr><td>重写方法</td><td>ctl + o</td></tr><tr><td>创建构造方法</td><td>cmd + n</td></tr><tr><td>显示当前类的层次结构</td><td>crl + h</td></tr><tr><td></td><td></td></tr><tr><td>翻译(需要安装ECTranslation插件)</td><td>ctl + l</td></tr></tbody></table><p><a href="http://blog.csdn.net/qq_35246620/article/details/53992312" target="_blank" rel="noopener">win 和 mac 在 idea 中快捷键的对比</a></p><h1 id="书签功能"><a href="#书签功能" class="headerlink" title="书签功能"></a>书签功能</h1><p>每当我们查看工程较大的源码时,难免会在数十个个文件中跳来跳去,一会就跳晕了,好在 Android Studio 提供了书签功能,相信熟练了该用法后,肯定就离不开了.</p><p>两种书签：</p><ul><li>匿名书签：无限个</li><li>具名书签：署签名为0<del>9或者A</del>Z间的一个字符作为助记符，因此数量有限</li></ul><h2 id="win-环境"><a href="#win-环境" class="headerlink" title="win 环境"></a>win 环境</h2><p><strong>添加书签</strong>: 鼠标所在行，按 <code>F11</code>，则添加一个匿名书签，在按<code>F11</code>，取消；如果想添加具名书签，则在光标所在行按<code>ctrl + F11</code>，然后会弹出<code>0~9</code>或者<code>A~Z</code>的<strong>助记符</strong>选项，点击即可</p><p><strong>显示所有书签</strong>:<code>shift + F11</code></p><p><strong>书签之间的切换</strong>:</p><p>如果是匿名书签，只能点 <code>shift + F11</code> 查看所有书签，然后选择</p><p>如果是具名书签，那么只需要 <code>ctrl + 助记符</code>则直接跳转到对应书签</p><h2 id="mac-环境"><a href="#mac-环境" class="headerlink" title="mac 环境"></a>mac 环境</h2><p><strong>添加书签</strong>：鼠标所在行，按 <code>Fn + F3</code>，则添加一个匿名书签，再按<code>Fn + F3</code>，取消；如果想添加具名书签，则在光标所在行按 <code>opt + Fn + F3</code>，然后会弹出<code>0~9</code>或者<code>A~Z</code>的<strong>助记符</strong>选项，点击即可</p><p><strong>显示所有书签</strong>:<code>cmd + Fn + F3</code></p><p><strong>书签之间的切换</strong>:</p><p>如果是匿名书签，只能点 <code>cmd + Fn + F3</code> 查看所有书签，然后选择</p><p>如果是具名书签，那么只需要 <code>ctrl + 助记符</code>则直接跳转到对应书签</p><h1 id="新建文件时的注释模板配置"><a href="#新建文件时的注释模板配置" class="headerlink" title="新建文件时的注释模板配置"></a>新建文件时的注释模板配置</h1><p><code>File–&gt;Settings–&gt;Editor–&gt;File and code Template</code></p><p>选择右侧的 include 标签 ,打开 File Header , 按照提示添加对应的注释.</p><p>上面只是为新建的 Java 文件添加头部的注释,关于作者,创建时间, copyright 等,还有一种使用场景是新添加方法时的注释.可以参考<a href="http://www.jianshu.com/p/a85062562cd7" target="_blank" rel="noopener">Android Studio 配置系列（一）：自定义代码注释</a></p><h1 id="常用的几个插件"><a href="#常用的几个插件" class="headerlink" title="常用的几个插件"></a>常用的几个插件</h1><ul><li>Alibaba Java Coding Guidelines:代码规范检查</li><li>CodeGlance: 右侧显示代码大纲</li><li>ECTranslation: 取词翻译,安装后建议在快捷键设置中搜索 translation, 然后修改快捷键,mac 中使用的是 <code>ctr + l</code></li></ul><h1 id="关闭-instance-run"><a href="#关闭-instance-run" class="headerlink" title="关闭 instance run"></a>关闭 instance run</h1><p>貌似目前问题还比较多,在  <code>preference -&gt; Build,Execution -&gt; instance run</code> 下关闭即可.</p><h1 id="mac-连接真机调试"><a href="#mac-连接真机调试" class="headerlink" title="mac 连接真机调试"></a>mac 连接真机调试</h1><ol><li>配置 adb 环境变量，找到 Android SDK 的位置，一般在：<code>~/Library/Android/sdk/</code><br>将下面两个路径添加到当前 shell 的配置文件的末尾，因为我将当前的 shell 换成了 zsh，因此我的配置文件时 ~/.zshrc</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:~/Library/Android/sdk/platform-tools</span><br><span class="line">export PATH=$&#123;PATH&#125;:~/Library/Android/sdk/tools</span><br></pre></td></tr></table></figure><p>记得 source ~/.zshrc<br>然后通过 adb version 命名查看是否配置成功！</p><ol start="2"><li>将手机连接到 mac 上，在终端输入 <code>system_profiler SPUSBDataType</code>，查看手机的信息；<br>对应的输出可能有很多，我们只需要找包含 <code>Serial Number</code> 的那一组数据，找到该组数据的 <code>Product ID</code>对应的16进制数。<br>然后打开 <code>~/.android/adb_usb.ini</code>，如果没有，则先创建该文件，并将<code>Product ID</code>对应的16进制数据写入该文件即可。</li></ol><ol start="3"><li><p>重启 adb<br><code>adbkill-server</code></p></li><li><p>重新连接手机即可使用</p></li><li><p>经过以上配置，以后如果还想调试其它手机，那么只需要将该手机的 <code>Product ID</code> 写入到 adb_usb.ini 文件中即可。</p></li></ol><h1 id="adb-server无法启动"><a href="#adb-server无法启动" class="headerlink" title="adb server无法启动"></a>adb server无法启动</h1><p>在使用<code>adb shell</code>命令时，可能会遇到端口占用，无法启动adb server的问题。adb server使用的端口是5037，所以这时候可以列出使用5.07端口的进程，，然后杀掉占用5037端口的进程，再重新启动adb server</p><ol><li><code>netstat -ano | findstr &quot;5037&quot;</code>,eg:找到的端口号是xxxx</li><li><code>TASKLIST | findstr &quot;xxxx&quot;</code></li><li><code>adb shell</code></li></ol><p>目前已知会占用5037的服务有：金山毒霸，酷狗音乐，qq音乐等，这些软件有一个共同的特点：手机连接上电脑时，这些软件都会监听到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解闭包中的委托</title>
      <link href="/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98/"/>
      <url>/2017/12/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>关于闭包的使用在<a href="http://groovy-lang.org/closures.html" target="_blank" rel="noopener">官方文档</a>中已经说明的很清楚了，这里再对闭包的委托机制进行说明，该机制对于 Groovy 开发，gradle 脚本编写非常重要！</p><p>要理解闭包，那么就必须要了解闭包中的三个属性，该属性仅在闭包中可以使用！</p><ol><li>this：该属性指向定义闭包的类的实例对象</li><li>owner：该属性和 this 类似，但是闭包中也可以定义闭包的，如果闭包 A 内定义了闭包 B，那么闭包 B 的 owner 指向的是其外部的闭包 A</li><li>delegate：该值初始化时是和 owner 相同的，但是该值可以通过接口将其它对象赋值给 delegate，来实现方法的委托功能，这正是 groovy 精彩之处！</li></ol><a id="more"></a><p>接下来以一组简单的示例了解一下这三个属性，以验证上面的说明</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Enclosing</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">def</span> whatIsThisObject = &#123; getThisObject() &#125;    <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">assert</span> whatIsThisObject() == <span class="keyword">this</span>             <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">def</span> whatIsThis = &#123; <span class="keyword">this</span> &#125;                     <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">assert</span> whatIsThis() == <span class="keyword">this</span>                   <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> whatIsOwnerMethod = &#123; getOwner() &#125;      <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">assert</span> whatIsOwnerMethod() == <span class="keyword">this</span>          <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">def</span> whatIsOwner = &#123; owner &#125;                 <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">assert</span> whatIsOwner() == <span class="keyword">this</span>                <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnclosedInInnerClass</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span></span><br><span class="line">        Closure c_this = &#123; <span class="keyword">this</span> &#125;                         <span class="comment">//5</span></span><br><span class="line">        Closure c_owner = &#123; owner &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">def</span> inner = <span class="keyword">new</span> Inner()</span><br><span class="line">        <span class="keyword">assert</span> inner.c_this() == inner                    <span class="comment">//6</span></span><br><span class="line">        <span class="keyword">assert</span> inner.c_owner() == inner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包嵌套定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClosures</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">def</span> nestedClosures_this = &#123;</span><br><span class="line">            <span class="keyword">def</span> c_this = &#123; <span class="keyword">this</span> &#125;                         <span class="comment">//7</span></span><br><span class="line">            c_this()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> nestedClosures_this() == <span class="keyword">this</span>               <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> nestedClosures_owner = &#123;</span><br><span class="line">            <span class="keyword">def</span> c_owner = &#123; owner &#125;                      <span class="comment">//7</span></span><br><span class="line">            c_owner()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//owner 对应闭包，这就是 owner 和 this 的不同!!</span></span><br><span class="line">        <span class="keyword">assert</span> nestedClosures_owner() == nestedClosures_owner   <span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Enclosing().run()</span><br><span class="line"><span class="keyword">new</span> EnclosedInInnerClass().run()</span><br><span class="line"><span class="keyword">new</span> NestedClosures().run()</span><br></pre></td></tr></table></figure><p>通过上边了示例，我们应该对闭包中的这三个属性有了一个大致的了解，并且知道了在不同的情况下，这些属性指向的对象是什么。<br>之前在理解闭包的时候，看到了讲解都在说你可以把闭包理解成匿名函数 Lambdas，但是如果闭包仅仅是 Lambdas，那么有何必另起一个 Closure 的名称，而不直接叫 Lambdas 呢？<br>而且 Lambdas 中并不存在 this，owner，delegate 的概念，所以要记住 Closure 并不仅仅是 Lambdas，其还有比 Lambdas 更酷的功能。而这些所谓的酷功能正是由 this，owner，delegate 来实现的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">  String myString1 = <span class="string">"111"</span></span><br><span class="line">  <span class="keyword">def</span> outerClosure = &#123;</span><br><span class="line">  <span class="keyword">def</span> myString2 = <span class="string">"222"</span>;</span><br><span class="line">    println myString1;     <span class="comment">// outputs 111</span></span><br><span class="line">    <span class="keyword">def</span> nestedClosure = &#123;</span><br><span class="line">       println myString1;  <span class="comment">// outputs 111</span></span><br><span class="line">       println myString2;  <span class="comment">// outputs 222</span></span><br><span class="line">    &#125;</span><br><span class="line">    nestedClosure()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass()</span><br><span class="line"><span class="keyword">def</span> closure = <span class="keyword">new</span> MyClass().outerClosure</span><br><span class="line">closure()</span><br></pre></td></tr></table></figure><p>运行上面程序，可以发现，闭包内的 this 指向的定义该闭包的类的实例对象（即：上下文）。在闭包内引用的变量和方法都会绑定到 this，其负责处理任何方法调用，以及对任何属性的访问。如果 this 无法处理，则转向 owner，最后在转给 delegate，如果再找不到，那么就会抛出异常。这就是 groovy 提供的默认的策略 <code>this -&gt; owner -&gt; delegate</code></p><p>当然该顺序也是可以改变的,可以通过闭包的 resolveStrategy 属性，指定不同的策略。</p><ul><li>Closure.OWNER_FIRST 是默认策略。如果属性或者方法存在于 owner 内，那么他可以被 owner 调用，如果不存在，则会尝试在 delegate 类中查找</li><li>Closure.DELEGATE_FIRST 颠倒了默认逻辑：delegate 是第一优先级，其次才是 owner</li><li>Closure.OWNER_ONLY 将仅仅在 owner 查找需要的属性或者方法：delegate 会被忽略</li><li>Closure.DELEGATE_ONLY 将仅仅在 delegate 查找需要的属性或者方法：owner 会被忽略</li><li>Closure.TO_SELF 可以被用于当开发人员需要使用先进的元数据编程技术和希望实现一个自定义的选择策略时：这个选择将不是 owner 或者 delegate,而仅仅是 closure 类自己。当我们实现了自己的 Closure 子类时，他才是有意义的。</li></ul><p>下面简单介绍一下其使用方法，以及效果</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> x = <span class="number">300</span></span><br><span class="line">    <span class="keyword">def</span> y = <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> run() &#123;</span><br><span class="line">        <span class="keyword">def</span> data = [<span class="string">x:</span> <span class="number">10</span>, <span class="string">y:</span> <span class="number">20</span>]</span><br><span class="line">        <span class="keyword">def</span> cl = &#123; y = x + y &#125;</span><br><span class="line">        cl.delegate = data</span><br><span class="line">        cl()</span><br><span class="line">        println x</span><br><span class="line">        println y</span><br><span class="line">        println data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Test().run()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">300</span><br><span class="line">700</span><br><span class="line">[x:10, y:20]</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> x = <span class="number">300</span></span><br><span class="line">    <span class="keyword">def</span> y = <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> run() &#123;</span><br><span class="line">        <span class="keyword">def</span> data = [<span class="string">x:</span> <span class="number">10</span>, <span class="string">y:</span> <span class="number">20</span>]</span><br><span class="line">        <span class="keyword">def</span> cl = &#123; y = x + y &#125;</span><br><span class="line">        cl.delegate = data</span><br><span class="line">        cl.resolveStrategy = Closure.DELEGATE_FIRST</span><br><span class="line">        cl()</span><br><span class="line">        println x <span class="comment">//这里不是在闭包中，访问的 x 当然还是成员变量了</span></span><br><span class="line">        println y</span><br><span class="line">        println data <span class="comment">// 主要是 data，在闭包中期访问的 x 和 y 均是 data 中，所以其 y 变成了 10+20；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Test().run()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">300</span><br><span class="line">400</span><br><span class="line">[x:10, y:30]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy 相对 Java 的一些新玩意</title>
      <link href="/2017/12/05/Groovy-%E7%9B%B8%E5%AF%B9-Java-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%8E%A9%E6%84%8F/"/>
      <url>/2017/12/05/Groovy-%E7%9B%B8%E5%AF%B9-Java-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%8E%A9%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Groovy-是轻量级的-Java"><a href="#Groovy-是轻量级的-Java" class="headerlink" title="Groovy 是轻量级的 Java"></a>Groovy 是轻量级的 Java</h1><ul><li>方法，闭包中 return 语句是可选的，如果没有 return，则默认返回方法、闭包的最后一条语句的值</li><li>方法和类默认的修饰符都是 public</li><li>Groovy 不强迫我们捕获自己不关系的异常，这些异常会被传递给方法的调用者</li><li>静态方法中也可以使用 this 来引用当前的静态类 Class 对象。</li><li>提供安全导航操作符 <code>.?</code> 来避免对象非空的判断<a id="more"></a><h1 id="GDK-一瞥"><a href="#GDK-一瞥" class="headerlink" title="GDK 一瞥"></a>GDK 一瞥</h1>Java 平台的核心优势是其 Java 开发包(JDK)。Groovy 并没有抛开 Java 单独做一套新的类和库，而是在以后的 JDK 的各种类中添加便捷的方法，这些拓展成为<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/overview-summary.html" target="_blank" rel="noopener">GDK</a>。<br>其中有一些常用的类，均有不错的扩充</li><li>String</li><li>Integer</li><li>File</li><li>List</li><li>Map</li><li>……</li></ul><h1 id="实现循环的集中方式"><a href="#实现循环的集中方式" class="headerlink" title="实现循环的集中方式"></a>实现循环的集中方式</h1><p>以下均以实现打印 0~9 的循环为例</p><ol><li>for(i in 0..9) { println i }</li><li>0.upto(9) { println “$it” }</li><li>10.times { println “$it” }</li></ol><h1 id="更为简洁的-JavaBean"><a href="#更为简洁的-JavaBean" class="headerlink" title="更为简洁的 JavaBean"></a>更为简洁的 JavaBean</h1><p>在 groovy 的 bean 对象中，定义的属性当然可以用 <code>foo.bar</code>的方式来访问，但是这样的访问方式并不是直接访问的 bar 这个变量，而是访问的 getBar/setBar 方法。<br>只要在类中声明了一个属性，groovy 就会默默地为我们生成对应的 get 和 set 方法，如果该属性是 final 类型，那么只有 get 方法。我们当然也可以自己手动去实现对应的 get/set 方法来实现更丰富的内容。</p><p>在<code>foo.bar</code>访问属性的情况下，将 bar 的修饰符改为 private，其实是没有什么意义的，因为这里并不直接访问该变量，因此要对 bar 变量进行一定的保护，手动覆盖对应 getBar/setBar 方法，修改该方法的权限，已达到保护属性的目的。</p><p>我们甚至可以不定义属性。假如类中包含一个 getBar()的方法，那么我们在调用该方法时可以使用 <code>foo.bar</code>，但是注意，仅仅实现了 get 方法，只能读取，不能用该方式赋值，如果要进行形如 <code>foo.bar = xxx</code>形式的赋值，那么类中必须要对应一个 setBar() 方法。</p><h1 id="使用具名参数对-JavaBean-初始化"><a href="#使用具名参数对-JavaBean-初始化" class="headerlink" title="使用具名参数对 JavaBean 初始化"></a>使用具名参数对 JavaBean 初始化</h1><p>如果一个 Bean 对象中含有多个属性，对其属性不同的赋值可能需要提供多种不同参数组合的构造方法，而在 groovy 中却可以便捷的实现。<br>前提：该类必须有一个无参构造器(没有定义构造器，当然会自动生成一个无参构造器)。如果定义了一个有参构造器，那么编译器便不会提供无参构造器了，需要我们手动提供一个无参构造器。<br>使用：new Foo(property1:value1,property2:value2,property3:value3);<br>只需以键值对的方式传入你想赋值的属性的名称和值即可。该语句会在执行完无参构造器之后，对传入的属性依次执行 set 操作。</p><h1 id="灵活的方法参数规则"><a href="#灵活的方法参数规则" class="headerlink" title="灵活的方法参数规则"></a>灵活的方法参数规则</h1><h2 id="规则一：方法的第一个形参默认可能是-map"><a href="#规则一：方法的第一个形参默认可能是-map" class="headerlink" title="规则一：方法的第一个形参默认可能是 map"></a>规则一：方法的第一个形参默认可能是 map</h2><p>对于以下的方法定义：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> bar(a,b,c)&#123;</span><br><span class="line">println <span class="string">"received $a $b $c"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 groovy 的动态类型的语言，在定义方法时可以不指定形参类型，而在使用时动态推断。该方法会调用该对象的 toString 方法。<br>那么在使用该方法时，如果传入的参数个数多于 3，而且多出的实现是键值对，那么 Groovy 会假设该方法的第一个形参是 map 类型，然后将实参列表中的所有键值对都放到一个 map 中，作为第一个参数传入，然后将剩下的参数按照形参一一对应，进行传参。</p><p>这里要注意的问题有两个：</p><ol><li>该规则会把所有的键值对都收集起来，即使键值对可能在实参传入的时候，并不是连续的，也没有关系，groovy 依然能识别。然后在将其余的实参依次对应第二个，第三个…形参</li><li>按照该规则，可能将键值对全部收集之后，剩下的参数可能与方法定义的参数个数就不匹配了，因为我们在传参时，本想将第二个参数也传入键值对的 map 的，但是不可以。因此在方法定义和使用时应多注意。</li></ol><h2 id="规则二：可选形参"><a href="#规则二：可选形参" class="headerlink" title="规则二：可选形参"></a>规则二：可选形参</h2><p>一个简单的例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> bar(a,b=<span class="number">10</span>)&#123;</span><br><span class="line">println a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> bar(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> bar(<span class="number">1</span>) == <span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="规则三：变长参数"><a href="#规则三：变长参数" class="headerlink" title="规则三：变长参数"></a>规则三：变长参数</h2><p>groovy 中有两种形式支持方法的变长参数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ... 这也是 Java 本身支持的一种形式</span></span><br><span class="line"><span class="keyword">def</span> bar(<span class="keyword">int</span> a,<span class="keyword">int</span> ... b)&#123;</span><br><span class="line">println <span class="string">"$a and $b"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果形参的最后一个参数为数组，那么除了第一个参数被赋值给 a 之外，后面的实参均被当做变长参数的实参传入到 b 数组中</span></span><br><span class="line"><span class="keyword">def</span> bar(<span class="keyword">int</span> a,<span class="keyword">int</span> b[])&#123;</span><br><span class="line">println <span class="string">"$a and $b"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是：如果在调用该方法时，想发送数组而不是离散值时，要注意：groovy 会把形如 [1,2,3] 这种形式的数组当做 List，而不是数组，因此在传入时需要显式的传入 <code>[1,2,3] as int[]</code></p><h1 id="方法可以返回多个值"><a href="#方法可以返回多个值" class="headerlink" title="方法可以返回多个值"></a>方法可以返回多个值</h1><p>Java 中，方法至多可以返回一个值，但是 groovy 中可以返回多个值。因为 groovy 的动态性，可以将多个返回值放到数组中，而不用去管具体类型(Java 中数组中的值类型必须一致)。</p><p>那么接下来要解决方法的返回值接收的问题。groovy 是这样处理的：将多个变量以逗号分隔，放在圆括号中，置于方法返回的左侧即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> f2()&#123;</span><br><span class="line">    [<span class="string">'abc'</span>,<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">(name,age) = f2()</span><br></pre></td></tr></table></figure><p>当()中变量与返回值的数量不一致时：如果有多余的变量，那么被置为 null；如果有多余的值，那么多余的值被丢弃。</p><h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>groovy 中的操作符是可以重载的，groovy 已经将操作符和预设的方法进行了<a href="http://docs.groovy-lang.org/latest/html/documentation/#Operator-Overloading" target="_blank" rel="noopener">绑定</a>，只要我们的类中实现了对应的方法（不用实现任何借口），该类的对象就可以调用对应的操作符了。</p><p>因此在给类中的方法起名时还是谨慎的好，以免恰好对应了操作符映射的方法名，产生不必要的麻烦。</p><p>在 gradle 中比较常用的操作符是 <code>&lt;&lt;</code>，其对应的方法名为 leftShift，其含义类似于 <code>append</code>，向对象中追加成员。</p><h1 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h1><p>在 groovy2.0 之前，基本类型都被当做对象处理。<br>在 groovy2.0 之后，基本类型只有在必要时才会被看做对象，eg：调用 Integer 的方法，将基本类型传递给对象引用。除此之外，Groovy 会在字节码级别将其保留为基本类型，已达到提升性能的目的。</p><h1 id="使用-groovy-代码生成变换"><a href="#使用-groovy-代码生成变换" class="headerlink" title="使用 groovy 代码生成变换"></a>使用 groovy 代码生成变换</h1><p>groovy 中提供了很多注解帮助我们生成对应代码，简化我们的开发流程。这里简单提一下最常用的 <code>@Immutable</code> 注解，该注解用来修饰类<br>一旦用该注解标记了一个类，那么该类的所有字段都将自动标记为 final，并额外为我们创建一个唯一构造器，其参数就是类中声明字段的顺序。</p><h1 id="groovy-的缺陷"><a href="#groovy-的缺陷" class="headerlink" title="groovy 的缺陷"></a>groovy 的缺陷</h1><ol><li><p>groovy 的<code>==</code>等价于 Java 的 equals 方法，如果想比较两个引用是否相同，groovy 中提供的方法是 <code>is()</code></p></li><li><p>Java 中可以在方法内部用<code>{}</code>包起一块代码，用来定义一个新的作用域，而这样的语法在 groovy 中被认为是在定义闭包，导致编译无法通过</p></li><li><p>分号并不总是可选的！<br>看下面这样一个例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">def</span> bar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">println <span class="string">"I'am instance initializer"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本想在 Foo 类中定义一个对象的初始代码块，但是这样的结构被认为是依附在属性上的一部分，因为前面的 bar 在定义结束后并没有加分号，因此如果遇到这种情况，需要在 bar 定义结束后以分号结尾。<br>当然，如果是静态代码块就不会有这个问题了。</p></li></ol><h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p>更多内容请参考<a href="http://docs.groovy-lang.org/latest/html/documentation/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建改良</title>
      <link href="/2017/12/05/hexo%E6%90%AD%E5%BB%BA%E6%94%B9%E8%89%AF/"/>
      <url>/2017/12/05/hexo%E6%90%AD%E5%BB%BA%E6%94%B9%E8%89%AF/</url>
      
        <content type="html"><![CDATA[<p>hexo 搭建改良<br>之前使用<a href="https://zachaxy.github.io/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/">hexo 搭建博客过程全纪录</a>已经可以成功的搭建一个 hexo 的博客了，使用了一段时间之后，发现了一个问题，就是博客只能在当前的这台 pc 上发布，但是有时候想在家也写写博客并立即发布，之前的博客只能基于单终端的发布。因此在多个端上进行 hexo 的同步成为当前需要解决的问题，为此，我这里进行了三次改进。通过不断的改良，也使我对 hexo 有了进一步的了解。</p><a id="more"></a><h1 id="GitPage-Hexo"><a href="#GitPage-Hexo" class="headerlink" title="GitPage + Hexo"></a>GitPage + Hexo</h1><p>相信大家刚开始用 hexo 搭建博客的时，搜索出现最多的关键词就是 GitPage + Hexo 了<br>这里用大白话说一下二者的基本原理：</p><p>不知道大家想过这个问题没，就是如果我们想做一个博客，还想让外网的其他人也看到，需要哪些准备条件：</p><ol><li>首先，我们肯定需要一个服务器，来保存我们的博客。这样外网才能访问的到。</li><li>其次，我们在浏览器浏览的博客都是 html 的网页，因此我们的博客页面在服务器上必须保存的是 html，css，javascript 等着些文件。</li></ol><p>接下来依次解决上面的问题：</p><p>问题一：有多种解决方法，可以购买阿里云，腾讯云等，来构建自己的博客系统，但是需要付费。那就寻找一个免费的平台，好在 github 提供了类似的功能，我们的代码仓库放在 github 上，外网都可以看到，这不就是一个免费的服务器嘛。但是如果我们直接把博客的 html 代码放到代码仓库，那么 github 会认为你创建的是一个 html 的代码库，这样查看例如 index.html 的文件并不是一个网页，而是代码。因此还需要一个转换器，该转换器的工作是如果我们打开的是例如 index.html 这样的文件，github 不是展示其代码，而是将其渲染成对应的网页展示出来。这一使命由 GitPage 来完成。</p><p>其实要完成上述的需求，还必须遵从 GitPage 规定的两个要求：</p><ul><li>每个人至多有一个这样的代码库，其仓库名必须是 <code>username.github.io</code>。这里的 username 就是你 github 的用户名。这里只是第一步，此时这任然是一个普通的代码库</li><li>该代码库中的文件必须按照一定的要求保存。例如在指定的文件夹中放 html 文件，在指定的文件夹放 css 文件等。</li></ul><p>只要我们按照 GitPage 的要求，将你写好的博客的 html 等文件放到指定的文件夹中。其实你就可以创建博客了。</p><p>问题二：解决了服务器的存储问题，接下来解决博客的网页生成问题了，并不是每个人都会前端的（即使会，我相信他们也不愿意真的用 html 来写博客，效率太低！），如果有这么一个转换器，可以将我写的文档转换成网页，那将极大的提高我们的工作效率。还真有这么一个转换器——Hexo。它可以将 markdown 的文件转换为 html 文件。并且配有多种主题，只需简单的配置，就可以轻松的切换风格不同的网页。而且其转换的文件夹的结构是完全符合 GitPage 的要求的。其对应于 <code>/public</code>文件夹。该文件夹下的所有文件只需要全部上传到<code>username.github.io</code>仓库中，我们就可以通过 <code>https://username.github.io/</code>来访问了。</p><p>这里强调一点：我们所写的博客，<strong>最重要的就是原始的 markdown 文件！</strong> 而不是其对应的 html 文件。因为这些文件随时可以用 hexo 来再次生成。但是如果 markdown 文件丢失了，可能意味着我们要重写写文章了。</p><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>参考之前写的这篇<a href="https://zachaxy.github.io/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/">hexo 搭建博客过程全纪录</a>就可以顺利跑通了。可以通过它进行一次练手。其主要是针对单平台的发布。如果你就是在单一的 pc 上写博客并发布，那它很适合你。但是如果你的需求是在 pcA 上写两篇，又在 pcB 上写两篇。那么请往下看。</p><h1 id="探索改进之旅"><a href="#探索改进之旅" class="headerlink" title="探索改进之旅"></a>探索改进之旅</h1><p>这里的改进主要是解决多终端同步问题。</p><h2 id="最原始最简单的方法"><a href="#最原始最简单的方法" class="headerlink" title="最原始最简单的方法"></a>最原始最简单的方法</h2><p>在了解了上面 GitPage 和 Hexo 所做的工作之后，我萌生了一个最简单的方法：在另一台电脑 pcB 上安装 Node.js。然后直接将 pcA 上的执行<code>hexo init</code>的文件夹(例如我的是：<code>E:/blogs</code>)拷贝到另一台 pcB 上，这样就可以直接用了，可以说是无缝连接。</p><p>缺点：如果你两台电脑交互发布文章的太频繁，老是这样将文件夹拷贝来拷贝去，也很麻烦。</p><p>使用情况：如果你之前长期 pcA 上发布文章，后来换了台电脑，以后准备长期在 pcB 上发布文章，那么这种方法最适合不过了。</p><h2 id="两个仓库"><a href="#两个仓库" class="headerlink" title="两个仓库"></a>两个仓库</h2><p>前面也说过博客中最重要的是 markdown 的源文件。而在<code>username.github.io</code>的代码库中保存的是博客文件夹的 public 下的内容。之前也想过用两个分支来解决。但是<a href="https://zachaxy.github.io/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/">hexo 搭建博客过程全纪录</a>的做法，二者并不在同一目录级别。无法实现用一个仓库再将博客文件夹下的 source 文件进行上传。故采用了两个仓库的做法。即新建一个仓库<code>MyBlogBackup</code>用来保存 markdown 源文件。</p><p>注意：这种解决方案是针对使用<a href="https://zachaxy.github.io/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/">hexo 搭建博客过程全纪录</a>搭建博客为前提的。其它情况则不适用。这里贴出所写的脚本文件：</p><p>发布文章的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> this time,we are in blogs dir,we need sync the source file</span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span> generate the new file and the old files from another machine</span><br><span class="line">hexo generate</span><br><span class="line">cd .deploy/zachaxy.github.io</span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span> copy web pages from public/</span><br><span class="line">cp -R ../../public/* .</span><br><span class="line">git add .</span><br><span class="line">git commit -m "update"</span><br><span class="line">git push origin master</span><br><span class="line">cd ../..</span><br><span class="line"><span class="meta">#</span> this time,you are in blogs dir</span><br><span class="line">git add .</span><br><span class="line">git commit -m "upload source file"</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>删除文章的脚本：运行该脚本，必须传入一个参数，指定要删除的文章的名称（要带 md 后缀）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">echo "the args count must equal 1,the arg we need is the name of the file you want to delete\n";</span><br><span class="line">elif [ ! -d "source/_posts/$1" ]</span><br><span class="line">then</span><br><span class="line">echo "No such file or directory"</span><br><span class="line">exit 2;</span><br><span class="line">else</span><br><span class="line"><span class="meta">#</span>first rm the file in both file system and local git</span><br><span class="line">rm "source/_posts/$1"</span><br><span class="line">git add .</span><br><span class="line">git commit -m "delete file"</span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta">#</span>second cover the change to GitPage</span><br><span class="line">hexo generate</span><br><span class="line">cp -R public/* .deploy/zachaxy.github.io</span><br><span class="line">cd .deploy/zachaxy.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m  "update"</span><br><span class="line">git push origin master</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>再次回顾下用到的两个仓库：<code>/MyBlog/.deploy/username.github.io</code>以及<code>MyBlogBackup</code></p><p>简单说一下思路：在新的终端，先用<code>hexo n</code>创建并写文章，然后执行发布脚本，该脚本会先将<code>MyBlogBackup</code>中的 markdown 同步到本地，然后用<code>hexo g</code>生成 html 文件。接下来再进入<code>.deploy</code>下的<code>username.github.io</code>的仓库,将代码 pull 下来，然后将刚刚生成的 public 下的 html 文件将仓库的文件强行覆盖。<br>按说相同的 markdown 文件用相同的主题生成的 html 文件是一样的，但是为了避免平台，hexo 版本的差异，这里还是要进行覆盖吧。</p><p>缺点：两个仓库的隔离性很高，而且目前的脚本很难称得上自动化，每次在另一个终端写博客时，都要谨记脚本的执行顺序，这些都需要人工记忆，而无法用代码约束。同时删除文件的维护成本也很高。但是作为一次尝试，它也解决了多终端同步的问题。</p><h2 id="一个仓库，两个分支"><a href="#一个仓库，两个分支" class="headerlink" title="一个仓库，两个分支"></a>一个仓库，两个分支</h2><p>这是我目前使用的解决方案。下面进行详细说明。</p><p>刚开始自己是按照<a href="https://zachaxy.github.io/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/">hexo 搭建博客过程全纪录</a>来搭建的，也是参考的别人的文章。一切顺利，但是和网上其它的教程有点不一样。不一样的地方在于发布文章的时候，这篇文章的做法并没有使用<code>hexo d</code>,而在博客文件夹下再创建一个 .deploy 的文件夹(当然文件夹的名字随意)，并创建一个 git 仓库，然后把用 hexo 生成的 html 文件(在 public 文件夹下)全部拷贝到.deploy 下，然后将直接把.deploy 下的代码全部 push。</p><p>刚开始我以为这种操作才是正统，后来看文章，发现更多的人用的是 <code>hexo d</code> 。其实这里并没有什么正统不正统，只是经历过这个事情之后，我们可以认定，<code>hexo d</code>干的事情就是把 public 中的文件 push 到远程。<br>在使用两个仓库的方法中，我也想过用两个分支的思路，但是不在同一个目录中，似乎不能作为两个分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blogs</span><br><span class="line">public</span><br><span class="line">需要向 username.github.io push 的所有文件</span><br><span class="line">source</span><br><span class="line">_post</span><br><span class="line">*.md</span><br></pre></td></tr></table></figure><p>这种目录结构创建两个分支，一个保存 _post 下的 md 文件，一个分支保存 public 下的文件。那么在初始化 git 仓库时在那个目录下？<br>这里肯定是要找二者的公共目录 Blogs，但是如果我们直接在 Blogs 下进行 git init，那么在上传 public 下的文件时是不符合 GitPage 的要求的，因为 GitPage 要求 public 下的文件必须作为仓库的一级目录。而我们这样做的话，一级目录就是 public 了。</p><p>后来经过试验，发现了使用多分支进行 hexo 同步的方法。<br>两个分支：一个分支我们可以叫 hexo，该分支主要是保存 markdown 源文件，hexo 配置文件。该分支需要我们手动创建，并把该分支设为默认分支。具体步骤如下：</p><ol><li>在 github 创建<code>username.github.io</code>的仓库</li><li>在本地创建一个同名的文件夹<code>username.github.io</code></li><li>在本地文件夹下执行 <code>git init</code>,<code>git checkout -b hexo</code>；初始化代码库，这里目前是空的，然后创建名为 hexo 的分支，其实这里并不是创建分支，而是把默认的 master 分支改名为 hexo。不信你这时候执行<code>git branch</code>，并不显示任何分支。但是 git 的命令行已经显示当前分支为 hexo 分支了。</li><li>在本地文件夹下执行<code>npm install hexo</code>、<code>hexo init</code>、<code>npm install</code> 和 <code>npm install hexo-deployer-git</code></li><li>因为我使用的主题里有一个搜索功能，所以还要额外执行<code>npm install hexo-generator-search -S</code></li><li>接下来用 hexo n xxx`创建并写文章。</li><li>写好文章后先不着急发布，先添加以下远程代码库 <code>git remote add origin git@github.com:zachaxy/zachaxy.github.io.git</code></li><li>将 markdown 源文件发布上去，具体的 ignore 文件如下。注意发布的远程仓库名 <code>git push -u origin hexo</code>。其实 master 只是默认的主分支，这个名字完全可以修改，而且在刚创建的仓库第一次这样提交时，指明远程的仓库叫 hexo，那么其默认分支就是 hexo</li><li>接下里生成并发布文章，使用<code>hexo g -d</code>，其会按照 _config.yml 中关于 deploy 的配置，自动创建 master 分支，并将 public 下的文件作为一级目录 push 到 master 分支中。</li></ol><p>ignore 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p> _config.yml 中关于 deploy 的配置，注意这里的 branch 必须为 master。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:zachaxy/zachaxy.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>以后我们在另一个终端进行发布时,同样创建一个<code>username.github.io</code>文件夹，然后依次执行</p><ol><li>安装 node.js</li><li>git init</li><li>git checkout -b hexo</li><li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:zachaxy/zachaxy.github.io.git</li><li>npm install -g hexo</li><li>git pull origin hexo</li><li>npm install</li></ol><p>要注意的地方:</p><p>这里并没有像第一次搭建的时候执行 hexo init, 这是反而是用 git pull origin hexo 来替代的,因为这个hexo init 的目的是为了在当前目录下建立一些目录结构,而这些结构我们已经上传到了 github 上.</p><p>既然目录结果一样,为什么一定要选远程仓库的,而不是用新的 hexo init, 这是因为我们的远程仓库上已经有了其它的主题配置,这个一会要用,还有一个重要的文件 <code>package.json</code>,这个文件里包含了我们创建博客时所需的额外的 node 插件,还记得我们在初始搭建环境的时候,安装的 <code>npm install hexo-deployer-git</code>和<code>npm install hexo-generator-search -S</code>吗?</p><p>这些插件的版本,都已经写在了<code>package.json</code>中,接下来我们要执行的 <code>npm install</code>命令就是安装<code>package.json</code>中所指定的插件,这样省的我们在之前另一台电脑上安装了很多插件的情况下,在新电脑上一个一个的再去重新安装.</p><p>同时在执行 npm install hexo 的时候,会生成一个多余的<code>package-lock.json</code>的文件,记得把这个文件添加到<code>.gitignore</code>文件中.</p><p>接下来正常的创建 md，写博客，发布即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac快速上手</title>
      <link href="/2017/11/13/Mac%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2017/11/13/Mac%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本快捷键"><a href="#基本快捷键" class="headerlink" title="基本快捷键"></a>基本快捷键</h1><h2 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h2><p>在看一些软件提供的快捷键时，都是给出如下的字符，其与键盘上的按键对应关系如下：</p><ul><li>⌘ (command)</li><li>⌥ (option)</li><li>⇧ (shift)</li><li>⌃ (control)</li><li>⌫ (delete)</li></ul><h2 id="MacOS-基本快捷键"><a href="#MacOS-基本快捷键" class="headerlink" title="MacOS 基本快捷键"></a>MacOS 基本快捷键</h2><p>当你熟记了这 4 个符号之后，那么就来记一些常用的快捷键吧：</p><ul><li><code>⌘ + tab</code> 切换应用程序</li><li><code>⌘ + ⌫</code> 将选中的文件移动到废纸篓</li><li><code>⌘ + c</code> 拷贝</li><li><code>⌘ + v</code> 粘贴</li><li><code>⌘ + ⌥ + v</code> 移动文件</li><li><code>⌘ + q</code> 退出当前应用</li><li><code>⌘ + h</code> 隐藏当前窗口</li><li><code>⌘ + m</code> 最小化当前窗口</li><li><code>⌘ + w</code> 关闭当前窗口</li><li><code>⌘ + &lt;-</code> 移动到行首，类 win 下的 home</li><li><code>⌘ + -&gt;</code> 移动到行末，类 win 下的 end</li><li><code>⌘ + delete</code>删除光标之前整行内容/选中文件的话，会将该文件移动到废纸篓(删除文件的功能更常用)</li><li><code>fn + delete</code>删除光标之后的一个字符；</li><li><code>⌥ + delete</code> 删除光标之前的一个单词（英文有效）；</li></ul><ul><li><code>⌘ + ⌥ + Esc</code> 类似 win 下的任务管理器，用来强制关闭应用</li></ul><p>休眠、关机</p><ul><li>休眠快捷键:<code>ctrl + shift + 右上角</code></li><li>关机快捷键:<code>cmd + opt + 右上角</code></li></ul><p>最近常用的系统快捷键：</p><ul><li><code>⌘ + 空格</code> 打开 spotlight</li><li><code>⌥ + 空格</code> 打开 iterm2</li><li><code>⌃ + 空格</code> 中英文输入源切换；不知道为什么，搜狗输入法和系统自带英文输入法会非人为切换，这是要切换回来就用该快捷键</li></ul><h1 id="显示隐藏文件"><a href="#显示隐藏文件" class="headerlink" title="显示隐藏文件"></a>显示隐藏文件</h1><p><code>Command+Shift+.</code> 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；但是这个方法是有版本限制的，目前在10.11上用不了;可能12上有用。</p><p>另一种可行的方法命令行执行显示隐藏文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true;</span><br><span class="line">KillAll Finder</span><br></pre></td></tr></table></figure><p>不显示,将上面的 true 改为 false 即可。</p><h2 id="解决-IDE-中配置环境变量的问题"><a href="#解决-IDE-中配置环境变量的问题" class="headerlink" title="解决 IDE 中配置环境变量的问题"></a>解决 IDE 中配置环境变量的问题</h2><p>很多 IDE 需要制定 SDK 的位置。例如使用 Intellj Idea开发 Groovy，就需要配置其 GROOVY 的路径，可是其路径安装时被放在了一个隐藏路径下，而在 ide 中选择路径时，是无法显示隐藏路径的。<br>解决方法：finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。这时将隐藏的路径<strong>拖到</strong>左边的快速导航，然后在IDE 中选择路径，点击左侧的快速导航即可。</p><h1 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>mac os 中的软件包管理器，类似 CentOS 中的 yum，Ubuntu 中的 apt-get。<br>安装方式：在终端中输入：<code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p><p>接下来就可以想 yum 那样在 macOS 中使用 brew 命令来安装软件了；</p><p>Homebrew 会将软件包安装到独立目录(默认：/usr/local/Cellar)，并将可执行文件软链接至 /usr/local/bin</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>brew search xxx：在软件仓库中搜索 xxx 软件，支持正则搜索</li><li>brew install xxx：安装 xxx 软件</li><li>brew uninstall xxx：卸载 xxx 软件，前提是使用 brew install 安装过的，其它方式不行；</li><li>brew info xxx:显示 xxx 软件的版本信息，安装路径，依赖信息等；</li><li>brew deps xxx：显示 xxx 软件的依赖；</li></ul><ul><li>brew list：查看使用 brew install 安装过的软件</li><li>brew update：更新 homebrew，但是没有必要单独执行这个命令，我们每次在执行 brew install 的时候，都会先执行 brew update</li></ul><h1 id="sdkman"><a href="#sdkman" class="headerlink" title="sdkman"></a>sdkman</h1><p>之前在学习 groovy 的时候,查看groovy 的官网，其推荐的安装方式是先安装 sdkman， 然后通过 sdk man 来安装 groovy。<br>sdkman 和前面介绍的 homebrew 有些类似，都是软件管理工具。而与 homebrew 不同的是，sdkman 不仅可以方便的安装软件，同时还可以管理多个开发工具版本之间的切换，eg：python2.x 和 python3.x，用 sdkman 就能很好的解决。<br>其安装方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s get.sdkman.io | bash</span><br><span class="line">source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</span><br></pre></td></tr></table></figure><p>第一步是安装，第二步是将 sdkman 配置到环境变量中，因为我使用的是 zsh，所以其自动写到了 <code>.zshrc</code>文件中。<br>最后其安装软件的方式也很简单，这里以安装 <strong>GROOVY</strong> 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install groovy</span><br></pre></td></tr></table></figure><p>其所下载的软件被放到了<code>/Users/用户名/.sdkman/candidates/</code></p><p>其安装软件的方式和 homebrew 是类似的，只需一个命令即可安装。<br>当然其强大的地方还在于可以管理多个软件的版本，具体使用请参考<a href="http://sdkman.io/usage.html" target="_blank" rel="noopener">官网</a></p><h1 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h1><p>目前最常用的快捷键：</p><ul><li>⌘ + c 复制当前行</li><li>⌘ + v 粘贴当前行</li><li>⌘ + x 剪切当前行</li><li>shift + ⌘ + &lt;-:选中光标到行首的所有字符</li><li>shift + ⌘ + -&gt;:选中光标到行首的所有字符</li><li>shift + ⌥ + &lt;-:选中光标到行首的一个单词</li><li>shift + ⌥ + -&gt;:选中光标到行首的一个单词</li></ul><ul><li>⌘ + d：高亮下一个选中的单词</li><li>⌘ + ctrl + g:高亮选中的所有单词</li><li>⌘ + ⌥ ：矩形区域选择</li><li>⌘ + shift + v (Win: Ctrl-Shift-v) 进行自适应缩进的粘贴</li></ul><ul><li><p>⌘ + enter 另起一行</p></li><li><p>⌘ + ⌃ 上下行切换</p></li><li><p>⌘ + ⇧ + p 命令提示</p></li><li><p>⌘ + ⌃ + p 切换工程</p></li></ul><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>首先要安装的是 Package Control 插件，它是一个方便 Sublime text 管理插件的插件。<br>从菜单 View -&gt; Show Console 或者 <code>ctrl + ~</code> 快捷键，调出 console。将以下 Python 代码粘贴进去并 enter 执行(注：针对的是 sublime3)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure><p>接下来再安装插件就可以通过 Package Control 来安装了，快捷键 <code>Ctrl+Shift+P</code>（菜单 – &gt;Tools –&gt; Command Paletter），输入 install 选中Install Package并回车,然后输入想要安装的插件名称即可，支持模糊搜索。</p><p>插件推荐如下：</p><ul><li>Alignment：代码对齐插件</li><li>BracketHilight：括号配对显示</li><li>DocBlockr：注释块</li><li>SublimeLinter：代码检查，还需要和具体的语言插件配对才可以使用eg:SublimeLinter-javac 使用，最好还是用编译器写代码。。</li><li>SideBarEnhancements：mac 下的名称，win 下叫 sidebar，提供了侧边连的增强功能；</li></ul><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>主题的安装同插件一样，在 Package Control 中直接搜索即可。目前用的 <code>Material Theme</code></p><h2 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"always_show_minimap_viewport"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"bold_folder_labels"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"color_scheme"</span>: <span class="string">"Packages/Material Theme/schemes/Material-Theme.tmTheme"</span>,</span><br><span class="line"><span class="attr">"draw_white_space"</span>: <span class="string">"all"</span>,</span><br><span class="line"><span class="attr">"font_size"</span>: <span class="number">15</span>,</span><br><span class="line"><span class="attr">"highlight_line"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"ignored_packages"</span>:</span><br><span class="line">[</span><br><span class="line"><span class="string">"Vintage"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"indent_guide_options"</span>:</span><br><span class="line">[</span><br><span class="line"><span class="string">"draw_normal"</span>,</span><br><span class="line"><span class="string">"draw_active"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"overlay_scroll_bars"</span>: <span class="string">"enabled"</span>,</span><br><span class="line"><span class="attr">"rulers"</span>:</span><br><span class="line">[</span><br><span class="line"><span class="number">100</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"save_on_focus_lost"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"scroll_past_end"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"show_encoding"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"show_full_path"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"show_line_endings"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"spell_check"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"tab_size"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">"theme"</span>: <span class="string">"Material-Theme.sublime-theme"</span>,</span><br><span class="line"><span class="attr">"trim_trailing_white_space_on_save"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"update_check"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"word_wrap"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="project-管理功能"><a href="#project-管理功能" class="headerlink" title="project 管理功能"></a>project 管理功能</h2><p>sublime 提供了像 IDE 那样基于 project 的功能，用来管理一组文件夹。只要保存为 project，那么下次再打开该 project 时，就会恢复上次打开的文件。这个功能在平时的工作中非常实用。</p><p>打开 sublime，注意此时 sublime 的窗口中不能有其它文件，否则一会儿保存为 project 时会将当前窗口的所有文件一块存入 project，然而 sublime 默认打开是会将上次关闭前打开的文件都打开的。所以，如果想单独创建一个 project，可以通过<code>cmd + shift + n</code>(win 下快捷键为：<code>ctrl + shift + n</code>) 重新打开一个窗口，此时再将想要打开的文件夹拖入当前窗口，或者用 <code>project -&gt; Add Folder to Project</code> 选择文件夹。同时我们在一个 project 中可以打开多个(不同路径)文件夹，然后选择 <code>Project -&gt; Save Project As...</code> 自定义该 project 的名字和保存路径，此时会在保存路径下生成两个文件，分别为<code>.workspace</code>和<code>.project</code>。前者文件中保存的是当前窗口已经打开的文件，这样下次打开该 project 时还会恢复。后者保存的是当前 project 中的所有文件的路径，前面也说了 sublime 中的 project 中可以添加多个文件夹进来。</p><p>tips：</p><ol><li>project 文件最好集中保存到一个特定的目录下，这样方便统一管理。</li><li>基于上一点，每次保存 project 时，都要选择指定的保存路径，所以推荐<code>project manager</code>的插件，在配置文件中指定路径，这样就免去每次保存 project 时选择路径的麻烦。</li><li>多个 project 的快速切换<code>cmd + ctrl + p</code>（win 下快捷键为：<code>ctrl + alt + p</code>），选择要切换的 project，这样的话当前窗口就会被替换为目标 project。如果你想打开多个 project，那么就用<code>cmd + shift + n</code>打开一个新的窗口，再用<code>cmd + ctrl + p</code>打开新的 project 即可。</li></ol><p>project manager 的插件的使用<br>在安装了该插件之后，首先要在该插件的配置文件中配置 project 保存的路径。在新建项目时，打开一个空白窗口，向其中拖入文件夹，然后使用<code>cmd + shift + p</code>打开命令行，输入<code>pm</code>，选择<code>Add New Project</code>，此时会在 sublime 底部弹出文本框，输入 project 的名字，那么该 project 就会被保存到之前配置的路径中。</p><h1 id="Iterm2-的使用"><a href="#Iterm2-的使用" class="headerlink" title="Iterm2 的使用"></a>Iterm2 的使用</h1><p>Iterm2 与系统自带的 terminal 类似，但是其功能更为强大；</p><h2 id="基本快捷键-1"><a href="#基本快捷键-1" class="headerlink" title="基本快捷键"></a>基本快捷键</h2><p>编辑相关：(注意和光标移动相关的操作全是 ctrl 打头的)</p><ul><li>清除当前行：ctrl + u</li><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>删除光标之前的单词：ctrl + w</li><li>删除到文本末尾：ctrl + k</li><li>清屏：ctrl + l 或者 command + r</li></ul><p>编辑中不太常用的：</p><ul><li>搜索命令历史：ctrl + r (类似于 history | grep xxx，搜索之前执行过的命令)</li><li>前进后退：ctrl + f/b (相当于左右方向键)</li><li>上一条命令：ctrl + p</li><li>交换光标处文本：ctrl + t</li></ul><p>历史记录：</p><ul><li>查看历史命令：<code>command + ;</code>(输入若干字符，弹出自动补齐窗口，列出曾经使用过的命令)</li><li>查看剪贴板历史：command + shift + h</li></ul><p>标签相关：</p><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><p>分屏相关：(使用频率较低)</p><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 command + [ 或 command + ]</li></ul><h2 id="全局呼出"><a href="#全局呼出" class="headerlink" title="全局呼出"></a>全局呼出</h2><p>默认是 <code>option + 空格</code><br>修改方法是在 preference-&gt;keys-&gt;hot key 勾选，并设置；<br>将快捷键改为 command + command，也是个不错的选择；</p><h2 id="智能选中"><a href="#智能选中" class="headerlink" title="智能选中"></a>智能选中</h2><p>在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）<br>在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。</p><h2 id="巧用-Command-键"><a href="#巧用-Command-键" class="headerlink" title="巧用 Command 键"></a>巧用 Command 键</h2><p>按住⌘键:</p><ul><li>可以拖拽选中的字符串；</li><li>点击 url：调用默认浏览器访问该网址；</li><li>点击文件：调用默认程序打开文件；</li><li>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；</li><li>点击文件夹：在 finder 中打开该文件夹；</li><li>同时按住option键，可以以矩形选中，类似于vim中的ctrl v操作。</li></ul><h2 id="高亮当前光标："><a href="#高亮当前光标：" class="headerlink" title="高亮当前光标："></a>高亮当前光标：</h2><p><code>⌘ + /</code> :如果一个标签页中开的窗口太多，有时候会找不到当前的鼠标，找到它。</p><h2 id="移动光标快捷键修改"><a href="#移动光标快捷键修改" class="headerlink" title="移动光标快捷键修改"></a>移动光标快捷键修改</h2><p>之前的命令单词的移动都是使用 <code>opt + -&gt;</code> / <code>opt +  &lt;-</code> 来实现的,但是这个要在 iterm2 中进行修改,具体修改方式:</p><ol><li>打开iTerm2的Preferences设置</li><li>选择相应的Profile（默认为Default），选择“Keys”选项卡</li><li>在Key Mappings看到<code>option+←</code> 和 <code>option+→</code>这两组快捷键用作了其他功能，这里我们分别修改为: 选择Action为“Send Escape Sequence”，然后输入“b”和“f”即可</li></ol><h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><p>终极 shell —— zsh</p><h2 id="切换为-zsh"><a href="#切换为-zsh" class="headerlink" title="切换为 zsh"></a>切换为 zsh</h2><p>通过 <code>cat /etc/shells</code> 查看系统自带的 shell，有如下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>目前系统默认使用的是 bash，接下来使用 <code>chsh -s /bin/zsh</code>将默认的 bash 切换为 zsh，当然想换回默认的 bash，只需键入 <code>chsh -s /bin/bash</code></p><p>zsh 的配置主要集中在用户当前目录的.zshrc里，我们对 zsh 的配置都在这个文件中，注意每当我们修改了该配置文件中的内容，都要用 <em>source ~/.zshrc</em>，使配置生效！</p><h2 id="安装-Oh-My-ZSH"><a href="#安装-Oh-My-ZSH" class="headerlink" title="安装 Oh My ZSH"></a>安装 Oh My ZSH</h2><p>zsh 相比于 bash 有很强的扩展性，但是其配置过于复杂，于是就有了 Oh My ZSH 来帮助我们简化 zsh 的配置</p><p>安装过程也很简单：<br><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p><p>其被安装到了 <code>/Users/zachaxy/.oh-my-zsh</code></p><p>现在整个 shell 的配置文件是 ~/.zshrc,所有的环境变量都在这里改动；</p><h2 id="alias-重命名功能"><a href="#alias-重命名功能" class="headerlink" title="alias 重命名功能"></a>alias 重命名功能</h2><p>例如我们为 sublime 添加一个 subl 的命令行，因为 sublime 本身就在其 bin 目录下有一个 subl 的可执行文件，所以直接拿来用就可以，在 zshrc 配置文件添加如下：<br>alias subl=”Applications/Sublime Text.app/Contents/SharedSupport/bin/subl”</p><p>然后执行：source .zshrc 是配置生效<br>接下来执行：subl xxx 就会创建并打开一个 xxx 文件；</p><h2 id="zsh-配置插件"><a href="#zsh-配置插件" class="headerlink" title="zsh 配置插件"></a>zsh 配置插件</h2><p>打开 ~/.zshrc 配置文件,找到 plugins 的配置，在括号里填入我们想要的插件就可以，可供选择的插件可以在 ~/.oh-my-zsh/plugins,其具体功能可以参考其 github 上的 <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">readme 说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  autojump</span><br><span class="line">  extract</span><br><span class="line">  sublime</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里推荐几个可能用的到的插件，注意插件安装的越多，iterm2启动越慢!</p><p>插件推荐：</p><ul><li><p>git：默认自带，主要是 alias 一些 git 的命令</p></li><li><p>sublime：提供打开文件夹功能，常用命令有：st</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">If st command is called without an argument, launch Sublime Text</span><br><span class="line"></span><br><span class="line">If st is passed a directory, cd to it and open it in Sublime Text</span><br><span class="line"></span><br><span class="line">If st is passed a file, open it in Sublime Text</span><br><span class="line"></span><br><span class="line">If stt command is called, it is equivalent to st ., opening the current folder in Sublime Text</span><br><span class="line"></span><br><span class="line">If sst command is called, it is like sudo st, opening the file or folder in Sublime Text. Useful for editing system protected files.</span><br><span class="line"></span><br><span class="line">If stp command is called, it find a .sublime-project file by traversing up the directory structure. If there is no .sublime-project file, but if the current folder is a Git repo, opens up the root directory of the repo. If the current folder is not a Git repo, then opens up the current directory.</span><br></pre></td></tr></table></figure></li><li><p>extract：功能强大的解压插件，所有类型的文件解压一个命令x全搞定，再也不需要去记tar后面到底是哪几个参数了。</p></li><li><p>web-search：命令行：google Android,就会打开浏览器，并用 Google 搜索 Android；(本机 ip暂时不稳定，暂不设置)</p></li><li><p>wd：快捷文件夹，以后会用到吧；</p></li><li><p>autojump：必选插件,快速进入某一文件夹。</p><p>需要先下载，通过 <code>brew install autojump</code>，然后在 <code>~/.zshrc</code>的最后添加如下指令，  <code>[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</code> ，同时在 plugins 中填入 autojump 插件，这样 autojump 就可以用了，用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，要在 zsh 中进入过某一目录 eg：xxx，这样 autojump 就会在自身的数据库中缓存结果，等下次再进入的话，只需要键入 j xxx，在按下 tab 键列出可选目标，然后在通过 tab 选择对应目录,xxx 支持正则，如果之前进入过多个不同位置但是名字相同的文件夹xxx，那么不同 xxx 在数据库中有一个优先级。  可以使用 autojump -h 来查看所有权重，设置权重，清除数据库等；</span><br></pre></td></tr></table></figure></li></ul><h2 id="zsh-主题配置"><a href="#zsh-主题配置" class="headerlink" title="zsh 主题配置"></a>zsh 主题配置</h2><p>同样是在 <code>~/.zshrc</code> 中，找到 <code>ZSH_THEME=&quot;robbyrussell&quot;</code>，在这里配置主题，默认的是 robbyrussell，当然可以换成别的，其它可选的主题都在 <code>~/.oh-my-zsh/themes</code>,<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">预览样式</a></p><p>这里挑几个较好的主题：</p><ul><li>blinks</li><li>gentoo</li><li>gianu</li><li>muse</li><li>pygmalion</li><li>ys</li></ul><p>最后修改配置，不要忘记执行： <code>source ~/.zshrc</code>，使配置生效</p><h1 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h1><p>很多时候查看配置文件，会使用 vim，其实上面介绍的 sublime 也很好用，不过有的人还是习惯用 vim，那么简单介绍一下 vim 的相关配置。</p><ol><li><code>cp /usr/share/vim/vimrc ~/.vimrc</code>,先复制一份vim配置模板到个人目录下，这样就使得仅对当前用户有效</li><li>编辑<code>~/.vimrc</code>，加入 <code>set nu!</code> 显示行号</li></ol><p>附其它常用配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible                 &quot;去掉有关vi一致性模式，避免以前版本的bug和局限</span><br><span class="line">set nu!                                    &quot;显示行号</span><br><span class="line">set guifont=Luxi/ Mono/ 9   &quot; 设置字体，字体名称和字号</span><br><span class="line">filetype on                              &quot;检测文件的类型</span><br><span class="line">set history=1000                  &quot;记录历史的行数</span><br><span class="line">set background=dark          &quot;背景使用黑色</span><br><span class="line">syntax on                                &quot;语法高亮度显示</span><br><span class="line">set autoindent                       &quot;vim使用自动对齐，也就是把当前行的对齐格式应用到下一行(自动缩进）</span><br><span class="line">set cindent                             &quot;（cindent是特别针对 C语言语法自动缩进）</span><br><span class="line">set smartindent                    &quot;依据上面的对齐格式，智能的选择对齐方式，对于类似C语言编写上有用</span><br><span class="line">set tabstop=4                        &quot;设置tab键为4个空格，</span><br><span class="line">set shiftwidth =4                   &quot;设置当行之间交错时使用4个空格</span><br><span class="line">set ai!                                      &quot; 设置自动缩进</span><br><span class="line">set showmatch                     &quot;设置匹配模式，类似当输入一个左括号时会匹配相应的右括号</span><br><span class="line">set guioptions-=T                 &quot;去除vim的GUI版本中得toolbar</span><br><span class="line">set vb t_vb=                            &quot;当vim进行编辑时，如果命令错误，会发出警报，该设置去掉警报</span><br><span class="line">set ruler                                  &quot;在编辑过程中，在右下角显示光标位置的状态行</span><br><span class="line">set nohls                                &quot;默认情况下，寻找匹配是高亮度显示，该设置关闭高亮显示</span><br><span class="line">set incsearch    &quot;在程序中查询一单词，自动匹配单词的位置；如查询desk单词，当输到/d时，会自动找到第一个d开头的单词，当输入到/de时，会自动找到第一个以ds开头的单词，以此类推，进行查找；当找到要匹配的单词时，别忘记回车</span><br><span class="line">set backspace=2           &quot; 设置退格键可用</span><br></pre></td></tr></table></figure><p>其实 zsh 已经把很多参数默认改好了，包括颜色方案啥的，很多都可以用设置的，直接用就行了</p><h1 id="Java-环境配置"><a href="#Java-环境配置" class="headerlink" title="Java 环境配置"></a>Java 环境配置</h1><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载地址</a>找到MacOS 的安装包，直接双击安装即可。<br>安装之后，不需要配置 Java 环境变量，直接在命令行就可以使用 Java 了，其安装位置是在：<code>/Library/Java/JavaVirtualMachines/</code>，同时系统也为刚刚的安装的 JDK 创建了软连接：<code>/usr/libexec/java_home</code>，也正是因为这个软连接，我们才可以在命令行中直接使用 Java 命令。</p><h2 id="配置-JAVA-HOME"><a href="#配置-JAVA-HOME" class="headerlink" title="配置 JAVA_HOME"></a>配置 JAVA_HOME</h2><p>虽然在命令行已经可以直接使用 Java 命令了，但是一些软件依然需要<code>JAVA_HOME</code>的环境变量，在<code>./zshrc</code>中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><h1 id="配置环境变量的配置问题"><a href="#配置环境变量的配置问题" class="headerlink" title="配置环境变量的配置问题"></a>配置环境变量的配置问题</h1><p>mac 中用要下载各种工具，然后配置环境变量，拿 gradle 的配置来说，在 <code>.zshrc</code> 中配置其环境变量，<br>之前的配置方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># add Gradle_Home</span><br><span class="line">#export GRADLE_HOME=$(/Users/zachaxy/mygradle/gradle-4.1)</span><br><span class="line">export PATH=$PATH:$GRADLE_HOME/bin</span><br></pre></td></tr></table></figure><p>然后总是提示 <code>permission denied: /Users/zachaxy/mygradle/gradle-4.1</code>,可是之前 Java 的环境变量就是这样配置的，就没有问题。<br>后来改成如下的方式，就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># add Gradle_Home</span><br><span class="line">export GRADLE_HOME=/Users/zachaxy/mygradle/gradle-4.1</span><br><span class="line">export PATH=$PATH:$GRADLE_HOME/bin</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://sspai.com/post/41371" target="_blank" rel="noopener">刚从 Windows 转到 macOS，如何快速上手操作</a><br><a href="http://wulfric.me/2015/08/iterm2/" target="_blank" rel="noopener">你应该知道的 iTerm2 使用方法–MAC终端工具</a><br><a href="https://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/" target="_blank" rel="noopener">iTerm2 快捷键大全</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数简介</title>
      <link href="/2017/11/07/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/11/07/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>卡塔兰数是组合数学中一个常在各种计数问题中出现的数列。以比利时的数学家欧仁·查理·卡特兰（1814–1894）命名。</p></blockquote><h1 id="原理证明"><a href="#原理证明" class="headerlink" title="原理证明"></a>原理证明</h1><p>先假设这样一个场景，有 n 个 1，n 个 -1，那么这 2n 个数字以 <strong>任意顺序</strong> 相加，结果肯定是等于 0 的。但是现在加一个限制，就是在所给的任意顺序的表达式，前 i 项(0&lt;=i&lt;=2n)的和也要&gt;=0,问有多少种组合方式?</p><p>首先，如果不加所给的限制，任意排列，那么产生的序列为：C(n,2n)<br>接下来，就要从所有的序列中，排除掉不合法的序列，那么结果就是合法序列数量。</p><p>不合法的序列：</p><p>想象一下，产生不合法的序列的情形，一定是在前 2i 项相加为 0 后，2i+1 项出现了一个 -1，此序列就是不合法的。同时，2i+2 到 2n 的和为 1。那么我们做一个变换，就是将第 1 项到第 2i+1 项的 -1 全部变为 1,1 全部变为 -1。因为前 2i 项相加为 0，变换后相加依然为 0，但是第 2i+1 变为了 1，这导致前 2i+1 项的和为 1。同时 2i+2 到 2n 的数字没有改变。导致此时整个序列的和变为了 2。</p><p>以下是上述的一个例子，第一个式子是不合法的，我们进行一步转换，得到第二个式子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 -1 -1 1 = 0  </span><br><span class="line">-1 1  1 1 = 2</span><br></pre></td></tr></table></figure><p>注意，这种转换后和为 2 的式子和为转换前的不合法的式子是一一对应的。也就是说如果出现了不合法的式子，一定能转换成一个唯一的相加为 2 的式子。同理这一步也是可逆的，也就是说如果出现了一个相加为 2 的式子，那么一定有一个不合法的序列和其对应。</p><p>前面我们直接找不合法的序列的种类并不好找，但是经过这一步转换后，现在的问题转换为 n+1 个 1，n-1 个 -1 组成相加为 2 的序列种类有多少，那么结果就是：C(n-1,2n)</p><p>也就是说，错排种类为：C(n-1,2n)<br>所以合法的种类为：C(n,2n) - C(n-1,2n) = C(n,2n)/(n+1)<br>该结果就是著名的卡特兰公式：f(n) = C(2n, n)/(n+1)</p><p>递推公式：f(n) = f(0)<em>f(n-1) + f(1)</em>f(n-2) + f(2)<em>f(n-3) + … + f(n-1)</em>f(0)</p><p>f(0)=1，f(1)=1，</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="出栈顺序-括号匹配"><a href="#出栈顺序-括号匹配" class="headerlink" title="出栈顺序/括号匹配"></a>出栈顺序/括号匹配</h2><p>假设有一个无穷大的栈，现在有 n 个数字按顺序依次进栈，那么合法的进出栈的序列是多少？<br>合法的进出栈，把入栈想象为 1，出栈想象为 -1，那么合法的进出栈序列为：C(n,2n)/(n+1)</p><h2 id="排队买票"><a href="#排队买票" class="headerlink" title="排队买票"></a>排队买票</h2><p>假设现在有 2n 个人排队买票，n 个人有 5 块，n 个人有十块，票价正好为 5 块，同时售票员手上没有零钱，那么合法的排队顺序有多少种?<br>这个和之前不一样的是：每个人都是不同的，所以在之前的结果前提下，还要对 n 个人进行排列，结果为：<br>C(n,2n)/(n+1) * n! * n!</p><h2 id="二叉查找树种类"><a href="#二叉查找树种类" class="headerlink" title="二叉查找树种类"></a>二叉查找树种类</h2><p>n 个节点(节点序号为 1 ~ n)，将其组成二叉查找树，有几种可能的结果；<br>n = 0，f(0) = 1,认为是空结构；<br>n = 1，f(1) = 1,只有一种可能<br>n = 2, f(2) = 2,分别是 1 作为根节点，2 只能是右子节点；或者 2 作为根节点，1 只能是左子节点；<br>n = 3，f(3) = 5;<br>n = 4, f(4) =<br>……<br>接下来，讨论 n 个节点的情况，每个节点都有可能作为头结点；<br>那么 f(n) = f(0)<em>f(n-1) + f(1)</em>f(n-2) + f(2)<em>f(n-3) + … + f(n-1)</em>f(0)<br>结果其实就是卡特兰数，为  C(n,2n)/(n+1)</p><h2 id="排队问题"><a href="#排队问题" class="headerlink" title="排队问题"></a>排队问题</h2><p>12 个高矮不同的人，站成两排，每排 6 人，从左到右，从矮到高；同时第二排的人比第一排的对应的人要高，有几种排列方式；<br>隐藏的卡特兰问题：<br>将 12 个人编号，1~12；站在第一排的为（，站在第二排的人为）；如果出现了不匹配的括号，那么说明不合法；<br> 现在问题变成：任意前缀不能出现）比（多的情况；<br> 结果依然是例题 1 的结果；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>groovy入门</title>
      <link href="/2017/10/26/groovy%E5%85%A5%E9%97%A8/"/>
      <url>/2017/10/26/groovy%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h1><p>groovy 是动态类型的语言，也就是说不需要指定变量的类型，类型是可以值来推导的。</p><ul><li>不指定类型定义变量： <code>i = 10</code></li><li>使用关键字`` def<code>，虽不是必须的，但是为了代码清晰，还是建议使用 def 关键字定义变量</code>def i = 10`</li></ul><p>这里有个误区：def 关键字的出现时替代变量类型的占位符，如果你已经明确了变量的类型，就没必要使用 def，也就是说 <code>def int i = 10</code> 是没有必要的</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li>单引号:单引号中的内容严格对应 Java 中的 String</li><li>双引号:和脚本语言类似，如果字符串中有$符的话，先对 $表达式进行求值</li><li>三引号:针对的是很长的字符串，只要在三引号之间，可以随意换行</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> s1 = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> s2 = <span class="string">"string append $&#123;version + 1&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> s3 = <span class="string">'''随意</span></span><br><span class="line"><span class="string">换行</span></span><br><span class="line"><span class="string">打印</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>字符串的长度：<code>s1.size()</code></p><p>字符串的访问：<code>s1[2]</code>   //被当做数组来处理；</p><p>或者  <code>s1.getAt(index)</code></p><p>字符串的重复：</p><p><code>s = s1*3</code>  // 代表是将 s1 拼接三次</p><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><ul><li>参数可以不指定类型</li><li>方法体中可以不使用 return 来返回，这样默认的返回值就是最后一行语句的值，但是如果不指定 return，定义函数时必须要使用 def。</li><li>可以指明返回值类型,这样就可以省略 def 关键字；但是如果未指定返回值类型，那么定义函数时必须使用 def 关键字</li><li>默认参数：可以给参数定义默认值，但是要注意的是，如果要定义有默认值的参数，那么该参数必须在参数列表的末尾</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><ul><li>调用时，可以不加括号，但这并不是一个好的习惯，因为如果一个函数是无参的，那么不带括号，很可能被误认为是属性的调用；同时在嵌套函数调用时，也容易出错（将参数设置为另一个方法调用的结果）</li><li>最好的一种形式是：能加括号都加括号；如果该方法只有一个参数，那么调用时加括号，如果有多个参数，则可以省略括号</li><li>特别注意：如果该函数没有参数，那么调用时，必须加括号；同时这个的参数个数要和闭包的参数个数区分开</li></ul><h1 id="Groovy-bean-对象"><a href="#Groovy-bean-对象" class="headerlink" title="Groovy bean 对象"></a>Groovy bean 对象</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Bean</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Bean(<span class="keyword">int</span> version,String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.version = version;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bean bean1 = <span class="keyword">new</span> Bean(<span class="number">1</span>,<span class="string">"zx"</span>)</span><br><span class="line"></span><br><span class="line">println bean1.name</span><br></pre></td></tr></table></figure><p>上面定义的 Bean 对象，在其内部定义了两个成员变量 version 和 name，这样默认就会为我们生成其对应的 getter 和 setter 方法。而在外部访问该成员变量时，其实是调用对应的 getter 和 setter 方法。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包和函数是类似的，是一个代码片段，可以定义一个引用指向这个闭包，这类似于 C 语言中的函数指针；</p><p>闭包还可以获取外部变量；与 Java 中的内部类不同的是，在闭包内不仅可以获取到外部变量，同时也可以将其修改，修改对外部是可见的。</p><p>与函数定义不同的是，闭包的参数是在方法体内定义的，以 -&gt; 分割，左侧为参数，右侧为方法体</p><p>闭包方法体内，最后一句为返回值。</p><p>闭包的默认参数：如果定义的闭包只有一个参数，那么可以在闭包内直接写方法体，使用 <code>$it</code> 来获取参数。</p><p>如果要定义一个没有参数的闭包，那么闭包内， -&gt; 左侧为空，则代表该闭包没有参数</p><p>Groovy 中的函数，可以用闭包作为参数；</p><h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h1><p>groovy 中的集合包含两种：list 和 map，其使用也很简单</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">list &lt;&lt; <span class="number">3</span></span><br><span class="line">println list.size();</span><br><span class="line"></span><br><span class="line">map = [<span class="string">name:</span><span class="string">"zx"</span>,<span class="string">age:</span><span class="number">25</span>];</span><br><span class="line">map.merry = <span class="literal">false</span><span class="comment">// 向 map 添加键值对</span></span><br><span class="line">println map.size()  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li>范围运算符(..)</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//range 更像是一个数组，其长度为 6，其为从 5 到 10</span></span><br><span class="line"><span class="keyword">def</span> range = <span class="number">5.</span><span class="number">.10</span></span><br><span class="line"><span class="comment">//通过 get(index)来获取对应的值</span></span><br><span class="line">println range.get(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它实例</span></span><br><span class="line"><span class="number">1</span> .. &lt;<span class="number">10</span>    <span class="comment">//  独占范围的示例</span></span><br><span class="line"><span class="string">'a'</span>..<span class="string">'x'</span>   <span class="comment">// 范围也可以由字符组成</span></span><br><span class="line"><span class="number">10.</span><span class="number">.1</span>     <span class="comment">// 范围也可以按降序排列</span></span><br><span class="line"><span class="string">'x'</span>..<span class="string">'a'</span> <span class="comment">// 范围也可以由字符组成并按降序排列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由此就有如下 foreach 的写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>三目运算符(?:)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 假设有这样一个需求，如果 name 不为 null，那么就输出 name 的值，否则输出 Anonymous</span><br><span class="line">// 下面的三目运算符的写法，未免有些啰嗦</span><br><span class="line">displayName = name ? name : &apos;Anonymous&apos;</span><br><span class="line"></span><br><span class="line">// 下面是 groovy 中支持三目运算符的写法</span><br><span class="line">displayName = name ?: &apos;Anonymous&apos;</span><br></pre></td></tr></table></figure><ul><li>展开操作符(*.)</li></ul><p>应用于实现了 iterator 的对象中，一般是数组，集合，是 foreach 的缩写</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> technologies = [<span class="string">'Groovy'</span>,<span class="string">'Grails'</span>,<span class="string">'Gradle'</span>]</span><br><span class="line">technologies*.toUpperCase() <span class="comment">// = to technologies.collect &#123; it?.toUpperCase() &#125;</span></span><br></pre></td></tr></table></figure><ul><li>安全操作符(?.)</li></ul><p>可以有效的避免空指针</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg：get(1)返回的结果是 null，此时如果调用 user.username 会产生空指针异常</span></span><br><span class="line"><span class="comment">//而是用 ?. 如果 user 为空,那么 username 也为 空，不会产生空指针异常</span></span><br><span class="line"><span class="keyword">def</span> user = User.get(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> username = user?.username</span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>groovy 提供了比 Java 更为便捷的方法来操作文件，其<a href="http://www.groovy-lang.org/gdk.html" target="_blank" rel="noopener">API 文档参考</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"E:/hello.txt"</span>)</span><br><span class="line"><span class="comment">//按行读文件 </span></span><br><span class="line">file.eachLine &#123;  </span><br><span class="line">   line -&gt; println <span class="string">"line : $line"</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件的整个内容，是用 text 熟悉</span></span><br><span class="line">println  file.text</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件内同的大小，单位是字节</span></span><br><span class="line">println file.length()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件,内容为 hello world</span></span><br><span class="line">file.withWriter(<span class="string">'utf-8'</span>) &#123; </span><br><span class="line">writer -&gt; writer.writeLine <span class="string">'Hello World'</span> </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//复制文件</span></span><br><span class="line"><span class="keyword">def</span> src = <span class="keyword">new</span> File(<span class="string">"E:/hello.txt"</span>)</span><br><span class="line"><span class="keyword">def</span> dst = <span class="keyword">new</span> File(<span class="string">"E:/hello1.txt"</span>)</span><br><span class="line">dst &lt;&lt; src.text</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归显示目录及其子目录中的所有文件</span></span><br><span class="line">file.eachFileRecurse() &#123;</span><br><span class="line">file -&gt; println file.getAbsolutePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://groovy-lang.org/documentation.html" target="_blank" rel="noopener">官方手册</a><br><a href="https://learnxinyminutes.com/docs/groovy/" target="_blank" rel="noopener">Learn groovy in Y minutes</a><br><a href="http://www.jianshu.com/p/ba55dc163dfd" target="_blank" rel="noopener">使用 Groovy 开发之新特性</a><br><a href="http://blog.csdn.net/dabaoonline/article/details/50477090" target="_blank" rel="noopener">日积月累–Groovy 语言规范之操作符</a><br><a href="http://www.jianshu.com/p/2c17a50ff7f1" target="_blank" rel="noopener">Groovy 学习之-运行时元编程</a><br><a href="https://www.ibm.com/developerworks/cn/education/java/j-groovy/j-groovy.html#N1036D" target="_blank" rel="noopener">精通 Groovy</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven简介</title>
      <link href="/2017/10/20/Maven%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/10/20/Maven%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在看 Gradle 相关的知识，看到介绍 Gradle 的开篇总是会拿来和 Maven 做对比，于是就好奇了解下 Maven 的使用，本篇文章只是对 Maven 很浅显的一个介绍，知道 Maven 是怎么回事，并不会对 Maven 做深入的探讨，因为我们的重点还是 Gradle。</p><p>Ant，Maven，Gradle 都是优秀的项目管理工具，做 Android 开发时应该都知道整个项目是用 gradle 进行管理的，平时用的最多的也就是往 gradle 配置文件中添加第三方库的依赖，仅此而已。接着我们直接点击了 run 的按钮等最终结果的输出了，而这些项目管理工具到底管理的是什么呢？我们不去看官方的话语，这里用大白话解释下，所谓项目管理，可以想象一个很大的项目，模块无穷多，这时就遇到问题了。</p><a id="more"></a><ol><li>项目中不可避免的要引入一些第三方的库</li><li>每个模块之间也会产生一定的依赖关系</li><li>每个模块都要进行独立的单元测试</li><li>代码在其他人机器上不能跑，而在自己的机器上明明可以跑…</li><li>项目需要在构建的过程而不是编码过程中加入一些自定义的功能</li><li>……</li></ol><p>这么多的问题，想想就头大，然而平时我们做的 hello world 根本不会遇到这些问题。如何解决？单靠程序员手动解决，简直累死，于是项目管理工具产生了，我们只需要在配置文件中进行简单的配置，即可完成以上复杂的流程。</p><h1 id="Maven-下载安装"><a href="#Maven-下载安装" class="headerlink" title="Maven 下载安装"></a>Maven 下载安装</h1><p>略。。。</p><p>注意配置环境变量</p><p>配置好之后，用 <code>mvn -v</code> 查看是否安装成功并成功配置了环境变量。</p><h1 id="Maven-项目的默认目录结构"><a href="#Maven-项目的默认目录结构" class="headerlink" title="Maven 项目的默认目录结构"></a>Maven 项目的默认目录结构</h1><p>我们平时写的代码可能有自己的组织结构，要想将该项目改造为由 Maven 管理，那么就要按照 Maven 的管理规则来，否则 Maven 无法识别正确的路径，影响最终结果的生成。Maven 默认的文件结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">项目文件夹</span><br><span class="line">src</span><br><span class="line">    main</span><br><span class="line">        java</span><br><span class="line">test</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>我们的平时写的代码放在 src/main/java/下，测试代码放在 test/java 下，当然这个结构也是可以通过 maven 来配置的，不过一般使用默认结构，而且现在大多数的 IDE 创建的工程也是按照这个结构组织的。</p><h1 id="pom-xml-简介"><a href="#pom-xml-简介" class="headerlink" title="pom.xml 简介"></a>pom.xml 简介</h1><p>上面只是对代码的文件夹结构进行了约束，若要使用 maven 提供的 mvn 命令来管理该项目，还需要在项目文件夹下添加一个 pom.xml 的配置文件，其基本的结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.mymavenproj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mymavenproj-model<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有几个节点简单介绍下：</p><p>首先，project 的属性是默认的，所有的 pom 文件都一样，接下来是 modelVersion 节点，其值是 4.0.0，也是固定的。</p><ul><li>groupId：项目包名（一般为公司域名反写+项目名）</li><li>artifactId：项目名-模块名（maven 是的一个优势就是对项目多模块之间的管理，不同的模块都可以用 maven 进行管理）</li><li>version：项目的版本号</li></ul><p>以上三个节点称之为一个组件的 <strong>坐标</strong>，因为我们可以通过这三个属性唯一的确定一个模块或者依赖。</p><ul><li>dependencies：用来进行依赖管理，具体见下一节</li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>现在的项目中难免会用到一些第三方的依赖库，早期的做法是直接将 jar 包拷贝下来，放到工程目录的 libs 文件夹下，但是 jar 包一多，尤其是对于团队开发，将 jar 包们来回拷贝也是麻烦，而且还可能因为不同的小组使用了不同版本的 jar，导致项目最终无法通过编译，好在 maven 为我们解决了这个问题，不用将 jar 包拷贝来拷贝去，同时只要指定 jar 包的版本号，即可是团队中的 jar 包保持一致，不同的小组只需要同步这个 pom.xml 文件即可。</p><p>在 pom.xml 文件中，有一个 dependencies 的节点，在这个节点中可以将我们所有的依赖配置进去。每个依赖都由一个单独的 dependency 节点组成，该节点下有三个重要的属性：</p><ul><li>groupId：项目包名 </li><li>artifactId：项目名-模块名 </li><li>version：项目的版本号</li></ul><p>这和上一节介绍配置我们自己项目时需要的三个属性是相同的，通过在三个属性，就能唯一确定一个依赖项。</p><p>eg：maven 的项目管理中包括测试这一项，这就需要我们在依赖中添加关于测试相关的框架</p><p>我们可以在 <a href="http://search.maven.org/" target="_blank" rel="noopener">maven center</a> 中寻找我们所需的项目，这是 Maven 为我们提供的仓库，有了它，我们就不必到 Junit 的官网下载 jar 包了，而是通过 maven 统一管理，在这个网页中搜索 junit，找到 <a href="http://search.maven.org/#artifactdetails%7Cjunit%7Cjunit%7C4.12%7Cjar" target="_blank" rel="noopener">http://search.maven.org/#artifactdetails%7Cjunit%7Cjunit%7C4.12%7Cjar</a> 这里提供了如何向我们自己的项目中添加 junit 的依赖。</p><p>添加完 junit 的依赖后，我们的 pom.xml 的内容就是上一节中的样子。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>经过前面的配置，一个简单的 Maven 项目已经配置好了，那么接下来考虑我们要做什么？</p><ul><li>代码要被编译为 class——compile</li><li>代码要进行测试——test</li><li>代码可能需要进行打包生成 jar 或者其它形式——package</li><li>代码上传到本地仓库——install</li><li>清除上次构建产生的结果——clean</li><li>……</li></ul><p>为满足上述的要求，可以使用后面提供的命令 <code>mvn  xxx</code>即可。</p><p>构建所产生的结果放在工程目录下的 target 子文件夹中</p><p>这里特别要说明一下 install 的命令，假设我们开发的这个模块是日志记录模块 log，那么执行 package 命令之后就会生成对应 的 jar 包，接下来就要考虑如何将该 jar 包提供给其它模块来使用了，假设这里有一个网络模块 net，需要依赖 log 模块，那么需要在 net 的 pom.xml 的 dependency 中加入 log 对应的坐标即可。仅仅是加入这个依赖，那么 net 模块是如何找到 log 的代码呢？</p><p>这里分为两个步骤，首先 Maven 会从本机的本地 Maven 仓库去找，如果找到就使用，如果没找到，那么从 <a href="http://search.maven.org/" target="_blank" rel="noopener">maven center</a> 去找，如果还找不到，就直接报错了。这个 Maven 本地仓库的地址是：<code>C:\Users\UserName\.m2\repository</code>这是 windows 下的默认路径，当然也可以修改为其它路径。</p><p>那么这个 install 命令的作用就是将 package 生成的 jar 包拷贝到该路径下，这样在接下来 net 进行编译的时候就可以找到对应的 log 的依赖了。</p><h1 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h1><p>了解了上面常用的命令，我们还需要知道 Maven 工程构建的生命周期，上述的命令执行其实是有先后顺序的，eg：<code>mvn install</code>如果执行该命令，其实会先依次执行： <code>compile -&gt; test -&gt; package -&gt; install</code></p><p>一般情况下，直接点击 install，等待打包即可，中间任何环节出现问题，都会停止构建，并输出对应的信息。</p><p>同时要注意的是，如果运行 package 命令，中间势必要经过 test 的流程，这就要求我们在当前项目中必须要依赖 junit，即使我们并没有写任何测试代码，否则 test 流程会失败。</p><h1 id="在-idea-中使用-Maven"><a href="#在-idea-中使用-Maven" class="headerlink" title="在 idea 中使用 Maven"></a>在 idea 中使用 Maven</h1><p>前面讲解的流程都是手动构建了项目目录，然后使用 maven 命令行对项目进行构建的，通过这种方式可以更加清楚的了解 maven 构建过程中的一些细节，但是这种方式已经很少手动去都建了，所有的大型项目都是通过 IDE 来写的，而且目前几乎所有的 IDE 创建的工程目录结构默认都是符合 Maven 规范的，所以我们也不用手动去创建符合 Mavne 标准的目录结构了。</p><p>接下来以常用的 IDE——idea 来讲解如何在项目中使用 Maven。</p><p>新建一个工程，类型为 empty，然后在该工程下创建三个 module，依次为 log，net，ui。module 的类型可以选择 java,也可以选为 maven。这两个类型的区别在于 maven module 会比 java module 多一个 pom.xml 文件，仅此而已，其它的都一样。我们既可以直接创建一个 maven 的 module，也可以选择创建好 java module 之后，在该 module 的根目录下手动添加一个 pom.xml，然后执行同步，其最终结果都是一样的。</p><p>但是如果你真的想让 maven 来管理项目，那么还是建议直接创建 Maven 项目，因为先创建 java module，然后在添加 pom.xml 文件时，识别比较慢，而且 java module 创建的目录下只到了项目目录/src，而 src 下面没有 main 和 test 的文件夹，还是需要我们手动创建</p><p>目前我们已经创建了 log，net，ui 三个 module，三个模块的 pom 文件如下：</p><p>log 模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-log<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>net 模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-net<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ui 模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h1><p>目前我们已经创建了 log，net，ui 三个 module，然后让 net 依赖 log，ui 依赖 net。三个模块的 pom 文件如下：</p><p>log 模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-log<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>net 模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-net<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-log<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ui 模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-net<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前的依赖关系是：ui-&gt;net-&gt;log；</p><p>我们依次对 log，net，进行 install，对 ui 进行 package。此时可以发现 ui 的 dependencise 中依赖了 net，同时又依赖了 log。这就是所谓的依赖传递，虽然 ui 并没有直接依赖 log，但是其依赖的 net 中却依赖了 log，因此 ui 也就依赖了 log。这样的话，在 ui 中编写代码时也可以直接使用 log 中的类了。</p><h1 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h1><p>上一节介绍了依赖的传递，但是现在有个问题，ui 中并不想依赖 log，因为在某些情况下，我们在 ui 中自己写了一个类和 log 中的类是同名的，恰好方法也是同名的，如果没有注意，可能会引入 log 中的类，而我们的本意是依赖 ui 中自己写的类，这就在 import 时，带来不必要的麻烦，解决的方法是在 ui 的 pom 文件，对net 的依赖中，使用 exclusions 标签，将不想依赖的 log 移除，移除后的 pom 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-net<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-log<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h1><p>产生依赖冲突的场景：</p><p>（1）A-&gt;B-&gt;C, A-&gt;C</p><p>A 依赖 B，B 依赖 C，而 A 有直接依赖 C，同时这两个 C 的版本还不一致，这就导致了依赖冲突。</p><p>解决该冲突的默认方法：</p><p>短路优先：默认解析路径短的，上例中，会采用 A 直接依赖的 C 的版本，而不是采用 B 中依赖的。</p><p>（2）A-&gt;B-X,A-&gt;C-&gt;X</p><p>A 依赖 B，B 依赖 X，同时 A 依赖 C，C 依赖 X，也会导致冲突</p><p>解决该冲突的默认方法：</p><p>路径相同，谁的 dependency 靠前就依赖谁，eg 在 A 的 dependency 中，先依赖的 B，那么间接引用的 X 采用的是 B 的。</p><h1 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h1><p>引入依赖后，该依赖起作用的范围也是不同的，其大体可以分为以下三种范围：</p><ul><li>编译</li><li>测试</li><li>运行</li></ul><p>这里所说的范围指的是</p><p>有的依赖仅仅是在测试的时候引入的，有的依赖仅在编译的时候使用，有的依赖仅在运行时使用，或者有的依赖是在其中的三种或者两种是有效的，为了避免依赖在其无用的范围内被错误的使用，maven 为我们提供了以下 6 种 dependency 节点中可选的 scope 属性，其对应的值分别是：</p><ul><li>compile：默认级别，对于编译，测试，运行三种 classpath 均有效；</li><li>provided：仅在编译和测试时有效，在运行是不会被打入包中</li><li>runtime：在测试和运行时有效，典型的应用就是 jdbc 驱动的实现；</li><li>test：仅在测试范围有效；</li><li>system：类型 provided，在编译和测试时有效，但是该特性与本地系统相关联，系统移植性差</li><li>import：导入范围，仅适用于 dependencyManagement 标签下，表示从其它的 pom 中导入 dependency 配置</li></ul><p>而我们也看到，在上述的三个模块中，均使用了 junit 的框架，而该框架只是在测试的范围内使用的，因此我们可以在 dependency 节点中引入 scope 节点，将其值设置为 test</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>我们要得到 ui 的 jar 包，要分别对 log 和 net 进行 install，这就要求我们必须了解各个模块是如何相互依赖的，然后在手动的去 install。有没有一种方法，通过一个命令，直接得到最后 ui 的 jar，答案就是聚合。</p><p>依旧在该工程中创建一个 maven 的 module，这里主要要将 packaging 标签改为 pom，默认值为 jar，同时在 modules 标签中，将上面的 log，net，ui 的 module 都包含进来。示例如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-aggreation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Log<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Net<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../UI<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时在依次执行该 module 的 celan-&gt;package 就会直接得到 ui 的 jar。</p><p>注意：使用 package，并没有将 log 和 net 的 jar 上传到本地 maven 仓库中，但却可以打出 ui 的包。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在上面的三个模块中都是用了 junit，我们可以将其抽象出来，定义到一个父 pom 中，然后让这三个模块都继承这个父 pom，而自身的 pom 中不需要引入 junit 的依赖了。</p><p>定义一个 parent 的 maven 模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>其 packaging 的值为 pom</li><li>是用 dependencyManagement 标签管理 dependencies，然后在其下的 dependency 中将 junit 填入</li><li>可以定义为 junit 的版本定义一个属性，然后在其 version 中进行引用（可选）</li></ol><p>接下来，要让三个模块来继承这个 parent，以 log 为例，进行如下修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-log<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zx.testmaven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testmaven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;dependencies&gt;</span></span><br><span class="line"><span class="comment">        &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;junit&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;4.10&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;/dependencies&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入了 parent 标签，同时将依赖中的 junit 删除掉。net，ui 模块也是类似的处理。</p><p>接下来，先对 parent 模块进行 install，然后再用 aggreation 模块，进行 install，此时 ui 的 jar 成功的安装在本地 mave 仓库中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AsyncTask详解</title>
      <link href="/2017/10/17/AsyncTask%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/10/17/AsyncTask%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="AsyncTask详解"><a href="#AsyncTask详解" class="headerlink" title="AsyncTask详解"></a>AsyncTask详解</h2><h3 id="AsyncTask中的参数"><a href="#AsyncTask中的参数" class="headerlink" title="AsyncTask中的参数"></a>AsyncTask中的参数</h3><p>AsyncTask是一个抽象类,如果我们想使用它就要自定义一个子类去继承它。继成时我们可以为<br>AsyncTask制定三个泛型参数:</p><ul><li>Params:调用AsyncTask的excute方法时传入的参数类型，如果该方法传入了多个不同类型的参数，那么就定义为Object。</li><li>Progress:执行AsyncTask时如果需要在前台显示进度条,使用该类型作为进度的单位</li><li>Result:当AsyncTask结束后,如果需要对结果进行返回,该类型作为返回值的类型</li></ul><p>如果某一个类型不需要传递具体的参数,那么对应的泛型参数用<code>Void</code>代替</p><h3 id="AsyncTask中一些重要的方法"><a href="#AsyncTask中一些重要的方法" class="headerlink" title="AsyncTask中一些重要的方法"></a>AsyncTask中一些重要的方法</h3><ul><li>void onPreExecute():在主线程执行,用于进行一些界面上的初始化操作,eg:显示一个进度条对话框等</li></ul><ul><li>Result doInBackground(Params … params):在子线程中执行,用于执行耗时任务,相当于Thread中的run()方法</li><li>void onProgressUpdate(Progress… values):在主线程中执行,前提是在<code>doInBackground</code>方法中执行了publishProgress(Progress… values),由该方法自动调用<code>onProgressUpdate</code>,可以界面上实时显示进度</li><li>void onPostExecute(Result res),在子线程中执行,<code>doInBackground</code>方法执行结束后,将返回值传给该方法,负责任务结束后的工作</li><li>void publishProgress(Progress… values),一般在<code>doInBackground</code>方法中调用(非必须),将当前进度传递出来,一旦执行了该方法,那么将自动回调onProgressUpdate方法,并将当前进度作为参数传递给它.</li><li>void onCancelled(boolean cancel),在主线程中执行,如果被调用,那么<code>onPostExecute</code>方法不会被执行,详见源码解析.</li></ul><h3 id="AsyncTask的基本使用"><a href="#AsyncTask的基本使用" class="headerlink" title="AsyncTask的基本使用"></a>AsyncTask的基本使用</h3><p>一个简单的下载的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskTest</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> TextView show;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.main);</span><br><span class="line">show = (TextView) findViewById(R.id.show);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法为界面的按钮提供事件响应方法,</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(View source)</span> <span class="keyword">throws</span> MalformedURLException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DownTask task = <span class="keyword">new</span> DownTask(<span class="keyword">this</span>);</span><br><span class="line">task.execute(<span class="keyword">new</span> URL(<span class="string">"http://www.crazyit.org/ethos.php"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 可变长的输入参数，与AsyncTask.exucute()对应</span></span><br><span class="line">ProgressDialog pdialog;</span><br><span class="line"><span class="comment">// 定义记录已经读取行的数量</span></span><br><span class="line"><span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">Context mContext;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DownTask</span><span class="params">(Context ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mContext = ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(URL... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">URLConnection conn = params[<span class="number">0</span>].openConnection();</span><br><span class="line"><span class="comment">// 打开conn连接对应的输入流，并将它包装成BufferedReader</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(conn.getInputStream()</span><br><span class="line">, <span class="string">"utf-8"</span>));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">sb.append(line + <span class="string">"\n"</span>);</span><br><span class="line">hasRead++;</span><br><span class="line">publishProgress(hasRead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 返回HTML页面的内容</span></span><br><span class="line">show.setText(result);</span><br><span class="line">pdialog.dismiss();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pdialog = <span class="keyword">new</span> ProgressDialog(mContext);</span><br><span class="line"><span class="comment">// 设置对话框的标题</span></span><br><span class="line">pdialog.setTitle(<span class="string">"任务正在执行中"</span>);</span><br><span class="line"><span class="comment">// 设置对话框 显示的内容</span></span><br><span class="line">pdialog.setMessage(<span class="string">"任务正在执行中，敬请等待..."</span>);</span><br><span class="line"><span class="comment">// 设置对话框不能用“取消”按钮关闭</span></span><br><span class="line">pdialog.setCancelable(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置该进度条的最大进度值</span></span><br><span class="line">pdialog.setMax(<span class="number">202</span>);</span><br><span class="line"><span class="comment">// 设置对话框的进度条风格</span></span><br><span class="line">pdialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line"><span class="comment">// 设置对话框的进度条是否显示进度</span></span><br><span class="line">pdialog.setIndeterminate(<span class="keyword">false</span>);</span><br><span class="line">pdialog.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 更新进度</span></span><br><span class="line">show.setText(<span class="string">"已经读取了【"</span> + values[<span class="number">0</span>] + <span class="string">"】行！"</span>);</span><br><span class="line">pdialog.setProgress(values[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTask的启动只需要执行:task.execute(Param … params);可以想其execute()方法中传入多个Param,代表多个任务,(eg:这个例子中可以传入多个url,那么就可以进行多个的下载),可以同时进行,其内部使用了线程池原理;</p><h3 id="AsyncTask中的注意事项"><a href="#AsyncTask中的注意事项" class="headerlink" title="AsyncTask中的注意事项"></a>AsyncTask中的注意事项</h3><ol><li>AsyncTask的类必须在主线程进行加载,也就是说第一次访问AsyncTask必须在主线程,在4.1之后的版本中,被系统自动完成,在5.0的代码中,在ActivityThread.main()中,调用了AsyncTask.init()方法来实现在主线程中被加载</li><li>AsyncTask对象必须在主线程中创建</li><li>execute()方法必须在UI线程中调用</li><li>不要在持续中自己调用onPreExecute(),doInBackground()等方法</li><li>一个AsyncTask对象执行一次execute()方法,多次执行会报错;</li><li>AsyncTask在不同版本上的表现是不一样的,eg:1.6版本之前,串行执行任务;1.6时,采用线程池并行处理任务;3.0开始又采用一个线程来串行执行任务;</li></ol><h3 id="AsyncTask源码解析"><a href="#AsyncTask源码解析" class="headerlink" title="AsyncTask源码解析"></a>AsyncTask源码解析</h3><p>这里分析的版本是Andoid4.0/4.2,不同的版本可能稍有不同;</p><p>首先从AsyncTask的execute()方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 额,只有一句话,具体实现在下面;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,Params... params)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;  </span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;  </span><br><span class="line">            <span class="keyword">case</span> RUNNING:  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span>  </span><br><span class="line">                        + <span class="string">" the task is already running."</span>);  </span><br><span class="line">            <span class="keyword">case</span> FINISHED:  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span>  </span><br><span class="line">                        + <span class="string">" the task has already been executed "</span>  </span><br><span class="line">                        + <span class="string">"(a task can be executed only once)"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mStatus = Status.RUNNING;  </span><br><span class="line">    onPreExecute();  </span><br><span class="line">    mWorker.mParams = params;  </span><br><span class="line">    exec.execute(mFuture);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关注的点是:</p><ol><li>最后将<code>mStatus</code>设置为<code>RUNNING</code>,由此也可以得出AsyncTask只能执行一次,否则其execute()方法一进去判断状态,如果已经是<code>RUNNING</code>,直接报错</li><li>执行了<code>onPreExecute()</code>方法,因此证明了onPreExecute()方法会第一个得到执行,当前依然在UI线程，所以我们可以在其中做一些准备工作。</li><li>调用了Executor的execute()方法，并将前面初始化的mFuture对象传了进去</li><li>mWorker.mParams = params,将我们传入的参数赋值给了mWorker.mParams</li><li>exec.execute(mFuture)</li></ol><p>相信大家对与<code>mWorker</code>和<code>mFuture</code>感到困惑,我们找到这两个类</p><p>其在<code>AsyncTask</code>中的定义<code>private final WorkerRunnable&lt;Params, Result&gt; mWorker;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;  </span><br><span class="line">        Params[] mParams;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是Callable的子类，且包含一个<code>mParams</code>用于保存我们传入的参数，下面看初始化mWorker的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;  </span><br><span class="line">          <span class="comment">//重写了call方法,只要mWorker一启动,就执行call方法,在call方法中先执行doInBackground方法</span></span><br><span class="line">          <span class="comment">//然后将其结果作为postResult的参数传入postResult()中,作为callable接口的返回值,此时依然在子线程中</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);  </span><br><span class="line">  <span class="comment">//设置线程优先级:后台线程;</span></span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  </span><br><span class="line">                <span class="comment">//noinspection unchecked </span></span><br><span class="line">                <span class="keyword">return</span> postResult(doInBackground(mParams));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"><span class="comment">//….  </span></span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到mWorker在构造方法中完成了初始化，并且因为是一个抽象类，在这里new了一个实现类，实现了call方法，call方法中设置mTaskInvoked=true，且最终调用doInBackground(mParams)方法，并返回Result值作为参数给postResult方法.这基本上就将 中几个重要函数的执行流程描述清楚了.</p><p>这里也出现了最重要的方法<code>doInBackground()</code>,我们知道<code>doInBackground()</code>的返回值是是作为参数传给<code>onPostExecute(Result res)</code>,为什么是作为参数传给了<code>postResult</code>呢?</p><p>其实可以想到:<code>doInBackground()</code>方法的执行是在子线程的,而<code>onPostExecute(Result res)</code>方法是在主线程的,这里直接传递是不可能的,需要一个中间的桥梁来实现线程的切换,这个桥梁就是<code>postResult();</code></p><p>接着往下看,<code>postResult</code>中具体做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line">        Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,  </span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));  <span class="comment">//第一个参数是当前的task,这个方法是task中的方法</span></span><br><span class="line">        message.sendToTarget();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然,这里用到了<code>handler</code>的消息传递机制,是在子线程中将结果传递出去,结合之前所说的AsyncTask类的加载必须在主线程,那么我们还可以料想到这个主线程中的AsyncTask在初始化时也创建了一个handler,并且重写了handleMessage()方法,在该方法中根据Message.What,来将返回的消息结果传给onPostExecute(Result res),这样整个消息就从子线程传递到主线程了.</p><p>是不是上面预想的那样,接着看代码,先看一下<code>AsyncTaskResult</code>这个类里有什么,这是一个静态内部类,封装了当前的AsyncTask对象和要返回的结果集,其实这个结果集并没有什么用,因为最终取的还是第一个值 data[0].</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;  </span><br><span class="line">       <span class="keyword">final</span> AsyncTask mTask;  </span><br><span class="line">       <span class="keyword">final</span> Data[] mData;  </span><br><span class="line">  </span><br><span class="line">       AsyncTaskResult(AsyncTask task, Data... data) &#123;  </span><br><span class="line">           mTask = task;  </span><br><span class="line">           mData = data;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来看一下AsyncTask中的handler对象在哪里?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler(); <span class="comment">//AsyncTask中的成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来看一下这个handler是专门处理详细的, 在handleMessage(msg)方法中已经说得很清楚了.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">            AsyncTaskResult result = (AsyncTaskResult) msg.obj;  </span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;  </span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:  </span><br><span class="line">                    <span class="comment">// There is only one result  </span></span><br><span class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:  </span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看正常发出的标签 msg.what是<code>MESSAGE_POST_RESULT</code>,这里调用了<code>result.mTask.finish(result.mData[0]);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到这里进行了判断,如果该任务被取消了,那么走<code>onCancelled(result)</code>的分支,否则,执行<code>onPostExecute(result)</code>,最后将状态设置为<code>最后将状态置为FINISHED</code>,整个任务就结束了.</p><p>mWoker看完了，应该到我们的mFuture了，我们在使用Future的时候,是将其作为参数传入Thread中的,依然实在构造方法中完成mFuture的初始化，将mWorker作为参数，复写了其done方法。done()方法是在其成员变量Callable中的call()方法执行结束之后才执行的回调,此时调用其get()方法不会阻塞主线程,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ...  </span><br><span class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    postResultIfNotInvoked(get());  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,  </span><br><span class="line">                            e.getCause());  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;  </span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在任务执行结束后调用了<code>postResultIfNotInvoked(get())</code>,看一下这个方法是如何实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();  </span><br><span class="line">    <span class="keyword">if</span> (!wasTaskInvoked) &#123;  </span><br><span class="line">        postResult(result);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>mTaskInvoked</code>不为<code>true</code>，则执行<code>postResult</code>；但是在<code>mWorker</code>初始化时就已经将<code>mTaskInvoked</code>为<code>true</code>，所以一般这个<code>postResult()</code>执行不到。</p><p>小总结一下:这里是介绍了两个变量的初始化:分别是<code>mWorker</code> 以及<code>mFuture</code>,这里<code>mWorker</code> 其实是一个<code>Callable</code>,<code>mFuture</code>其实是一个<code>FutureTask</code></p><p>具体使用还请参考《疯狂Java讲义》中的关于Callable和Future的使用吧</p><p>好了，到了这里，已经介绍完了execute方法中出现了mWorker和mFurture，不过这里一直是初始化这两个对象的代码，并没有真正的执行。下面我们看真正调用执行的地方。</p><p>excute()方法</p><p>还记得上面的<code>execute</code>中：exec.execute(mFuture),其中<code>exec</code>为<code>executeOnExecutor(sDefaultExecutor, params)</code>中的<code>sDefaultExecutor</code><br>下面看这个<code>sDefaultExecutor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;  </span><br><span class="line">  <span class="comment">//维持一个队列,队列里面盛放的是 Runnable,而FutureTask 正好实现了 Runnable 接口;</span></span><br><span class="line">   <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();  </span><br><span class="line">  </span><br><span class="line">   Runnable mActive;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;  </span><br><span class="line">     <span class="comment">//差点又被误导了,这里是指创建了一个Runnable,其中的run方法是在线程池被调用的时候执行的,而不是现在;</span></span><br><span class="line">     <span class="comment">//这里只是往上面的队列mTask中提交一个runnable对象,这个runnable对象时什么呢,就是我们所提供的mFuture对象;</span></span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">              <span class="meta">@override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        r.run();  <span class="comment">//这个步骤本身就是一个阻塞的,会经过一段时间,执行过程中可能有新的任务添加进来</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                        scheduleNext();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;  <span class="comment">//当前没有要执行的任务,那么就取出队列的第一个任务开始执行;</span></span><br><span class="line">                scheduleNext();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);  <span class="comment">//此时才会执行其r.run()方法,真正执行的线程池是这个,而上一个SERIAL_EXECUTOR的线程池只负责线程串行的调度;</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sDefaultExecutor其实为SerialExecutor的一个实例,(SerialExecutor实现了Executor接口,该接口中只有一个void execute(Runnable r)方法)其内部维持一个任务队列;直接看其execute（Runnable runnable）方法，将runnable放入mTasks队尾,但是这里提供的Runnable并不是AsyncTask在构造方法中创建的FutureTask(虽然FutureTask也是一个Runnable),而是自己new了一个Runnable对象,在其run的内部手动调用了FutureTask.run(),最后执行scheduleNext()方法.</p><p>这个时候就要说一下其实AsyncTask其实是串行执行任务的,我们向<code>ArrayDeque&lt;Runnable&gt; mTasks</code>中添加一个任务(注意这里只是添加并不是执行…),添加完后都会判断mActivie是不是为null,如果此时没有任务在执行,那么就会调用scheduleNext()方法,但是此时不为null的话,就什么也不做,仅仅是添加任务,而当scheduleNext()中执行完一个任务后,其finally中会再次调用scheduleNext()方法,执行下一个任务,这就做到了串行…</p><h2 id="问题-既然AsyncTask只能execute一次-要线程池干什么"><a href="#问题-既然AsyncTask只能execute一次-要线程池干什么" class="headerlink" title="问题:既然AsyncTask只能execute一次,要线程池干什么?"></a>问题:既然AsyncTask只能execute一次,要线程池干什么?</h2><p>两个原因:</p><p>(一)同一个AsyncTask只能execute()一次,如果代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AsyncTask().execute();</span><br><span class="line"><span class="keyword">new</span> AsyncTask().execute();</span><br><span class="line"><span class="keyword">new</span> AsyncTask().execute();</span><br><span class="line"><span class="keyword">new</span> AsyncTask().execute();</span><br><span class="line"><span class="keyword">new</span> AsyncTask().execute();</span><br></pre></td></tr></table></figure><p>那么就会有多个任务了,注意:AsyncTask中的线程池是是<code>static final</code>的,这样就会产生多任务了,那么线程池自然也就派上用场了</p><p>(二)在3.0之前的版本,如果提交了多个任务,那么其线程池不是串行执行的,而是并行执行的.</p><h2 id="问题-在3-0之后可以依旧使用任务并发执行吗"><a href="#问题-在3-0之后可以依旧使用任务并发执行吗" class="headerlink" title="问题:在3.0之后可以依旧使用任务并发执行吗?"></a>问题:在3.0之后可以依旧使用任务并发执行吗?</h2><p>可以,只不过不要调用<code>new AsyncTask().execute();</code>而是调用<code>new AsyncTask().executeOnExecutor(Executor exec,Params... params)</code>,这时候,我们就可以不使用默认的sDefaultExecutor了,而是我们自己提供一个线程池,实现并发.</p><p>我们知道在execute()方法中其实是调用了executeOnExecutor(),而这个方法在3.0之前是没有的,3.0之前直接把execute(),然后线程池就并发执行了,当然了,线程池你也知道,如果你提交的任务数过多,就直接报错的,这也是3.0之前的一个缺点,不可配置.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android UI 专题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C快速上手</title>
      <link href="/2017/06/05/Objective-C%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2017/06/05/Objective-C%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 Objective-C 的快速上手文章，只要你之前有 Java 或者 C++ 的基础，相信入门 Objective-C ，只需要很短的时间。</p></blockquote><h1 id="OC-语法概览"><a href="#OC-语法概览" class="headerlink" title="OC 语法概览"></a>OC 语法概览</h1><h2 id="源代码文件拓展名对比"><a href="#源代码文件拓展名对比" class="headerlink" title="源代码文件拓展名对比"></a>源代码文件拓展名对比</h2><table><thead><tr><th></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td>c</td><td>.h</td><td>.c</td></tr><tr><td>c++</td><td>.h</td><td>.cpp</td></tr><tr><td>oc</td><td>.h</td><td>.m</td></tr><tr><td>oc&amp;&amp;c++</td><td>.h</td><td>.mm</td></tr></tbody></table><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass:NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>定义一个类，以@interface MyClass:NSObject 开头，以@end 结尾，类名就是 MyClass，后面跟一个冒号，其含义就是 Java 中的 extends 关键字， 表示继承自 NSObject 类</p><p>遇到@符号，编译器会进行相应的预处理。</p><p>声明之中只有属性的定义，方法的声明，并没有方法的具体实现，具体实现是在类的实现中。从这个角度看，类的声明又很像是 Java 中的接口。类的声明一般是放在头文件中<code>.h</code>中</p><h2 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person:NSObject</span><br><span class="line">@property NSString *firstName;</span><br><span class="line">@property NSNumber *age;</span><br><span class="line">@property int id;</span><br><span class="line">@property (readonly)NSString * lastName;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>定义属性必须以@property 开头，然后是属性的类型，后面是变量名，如果变量是以<code>*</code>开头的，那么表明这个变量是一个指针，指向的是一块对内存中的区域；</p><p>同时，属性也有基本类型，eg：int，double 等，这表明的是一个基本类型；</p><p>用(readonly)前缀的变量，表明该变量时只读的，这和 Java 中的 final 关键字很类似</p><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>减号方法（普通方法，又称为对象方法）</p><p>加号方法（类方法，又称为静态方法）</p><h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>类的声明和实现是分开的，也就是说声明之中只有属性的定义，方法的声明，并没有方法的具体实现，具体实现是在类的实现中。从这个角度看，类的声明又很像是 Java 中的接口</p><h2 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h2><p>定义类 <code>Person.h</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person:NSObject</span><br><span class="line">-(void)sayHello;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>实现类<code>Person.m</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">-(void)sayHello&#123;</span><br><span class="line"> NSLog(@&quot;hello,world&quot;);</span><br><span class="line">&#125; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在实现方法中，有一个 NSLog 的方法，这个方法是一个静态方法，类似于 Java 中的 System.out.println 方法；</p><p>在”hello world”字符串之前，加一个@符号，表明这是一个 OC 类型的字符串，OC 是完美支持 C 语言的，如果不加@符号，那么表明这是一个 C 语言类型的字符串（其实就是一个字符数组）。</p><h2 id="简单的-main-方法"><a href="#简单的-main-方法" class="headerlink" title="简单的 main 方法"></a>简单的 main 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">/* code */</span><br><span class="line">@autoreleasepool&#123;</span><br><span class="line">NSLog(@&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li>int：4byte</li><li>float：4byte</li><li>double：8byte</li><li>char；1byte</li><li>boolean ：和其它语言不一样的是，oc 中 true 是用 1 来表示的，false 是用</li></ul><p>限定词：</p><ul><li>long：long int a，表示加长版的 int，简写为：long a</li><li>long long：long long int a，表示加长版的 long，简写为：long long  a</li><li>short：short int a，表示简短版的 short，简写为： short a</li><li>unsigned：unsigned int a，表示无符号整形</li><li>signed：signed int a；表示有符号的整形</li></ul><p>字符串:并不是基础类型，但是可以平时使用很多</p><p>OC 字符串类型：NSString:@”hello”，在打印时使用%@</p><p>C 语言字符串类型：”hello”，在打印时，使用%s</p><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>关于 OC 中的布尔值，和其它语言不同，并不是 true、false，而是用 0 来表示 false，如果 if 中的条件表达式中的值不是 0，其它所有的数字，或者字符串都可以表示 true；</p><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>和 C 语言的 goto 语法相同，定义一个标签，只要不是关键字都可以，后面的代码用花括号包起来，不包也可以；然后在想要跳转的地方进行 goto label 的跳转；</p><p>标签并不一定要定义在 goto 语句之前出现，后面也是可以的；</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>for、while 和 C 语言完全一样</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>定义：同 C 语言</p><p>调用：同 C 语言</p><h1 id="Objective-C-面向对象"><a href="#Objective-C-面向对象" class="headerlink" title="Objective-C 面向对象"></a>Objective-C 面向对象</h1><p>OOP：面向对象编程</p><p>OOA：面向对象分析</p><p>OOD：面向对象设计</p><h2 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h2><p>在 Xcode 中创建一个类，右键 new File，选择 iOS 中的 Source，选择 Cocoa Touch Class,选择继承自 NSObject，这样的话就会生成两个文件，分别是一个 .h  和 .m 文件，h 文件中写类的声明，m 中写类的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Person.h</span><br><span class="line"># import&lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject&#123;</span><br><span class="line">NSString *name</span><br><span class="line">int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个属性，这个属性就相当于对成员变量的 get/set</span><br><span class="line">@property(nonatomic,strong)NSString *personName;</span><br><span class="line"></span><br><span class="line">//上面属性的定义的本质就是定义了如下方法：</span><br><span class="line">/*- (void) setName:(NSString *)name;</span><br><span class="line">- (NSString *)getName;*/</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">@synthesize personName = name;</span><br><span class="line"></span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self)</span><br><span class="line">&#123;</span><br><span class="line">name = @&quot;张三&quot;；</span><br><span class="line">&#125;</span><br><span class="line">return self；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*- (void) setName:(NSString *)name&#123;</span><br><span class="line">personName = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)getName&#123;</span><br><span class="line">return personName;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在 main 方法中使用该对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> @autoreleasepool&#123;</span><br><span class="line">Person *p1 = [[Person alloc]init]; </span><br><span class="line">        p1.personName = @&quot;张三&quot;;</span><br><span class="line">      Person *p2 = [Person new];</span><br><span class="line"> &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析<code>Person *p1 = [[Person alloc] init];</code></p><p>首先，Person 是类名，后面跟变量名，但前边必须有一个 <code>*</code>,表示指针，所以在 OC 中，所有的对象都是一个指针，这其实和 Java 是类似的，因为 Java 中的对象的引用，实际上就是指向对内存中的地址，其实也就是一个指针。</p><ul><li>对于静态方法：[类名 方法名]</li><li>对于非静态方法：[对象名 方法名]</li></ul><p>alloc 是一个方法名，用来分配内存，init 也是一个方法名，用来初始化对象；</p><p>另一种初始化对象的方法是 [类名 new]，直接使用一个 new 的关键字，就代表了 alloc 和 init 两个方法，直接申请内存并初始话对象，但是这种方法与整体编码风格不搭，所以还是使用先 alloc 再 init 的方法。</p><h2 id="成员变量和属性"><a href="#成员变量和属性" class="headerlink" title="成员变量和属性"></a>成员变量和属性</h2><p>类内使用成员变量，类外使用属性</p><p>因为成员变量是只能在类内使用的，属性存在的意义是让类外访问成员变量，充当成员变量的外部访问接口。从这个角度来分析，这又有点像 Java 中的 get/set 方法；</p><p>所以我们在 h 文件中定义了一个属性，名字叫做 personName，那么我们直接在类外对这个属性赋值或者取值就可以了，如果没有定义属性，那么我们就必须自己手写 get/set 方法，代码量增加了。然而如何将属性和成员变量进行关联呢？</p><p>成员变量名：name</p><p>属性名：personName</p><p>为了建立关联，我们要在 m 文件中定义关联：<code>@synthesize personName = name;</code></p><p>如果成员变量名和属性名一样的话，eg 都是 name，那么关联更为简单：</p><p><code>@synthesize name;</code></p><p>但是这样写的话，带来一个困扰，就是在类中调用的究竟是成员变量还是属性，这是两个对象，这给代码的编写带来迷惑，所以不建议将属性名和成员变量名写成一样的。</p><p>在类内是完全没有必要调用属性的，因为成员变量在类内是完全可用的，所以我们在类内应该使用成员变量，属性是给类外使用的。</p><p>苹果官方推荐的做法是，成员变量使用 _name，而属性使用 name，以作区分，当然这只是一个建议，并不一定必须要这样；然后在 m 文件中使用 @synthesize 关键字进行对应，这是较老的版本的做法。</p><p>在新版本中则不需要这么做，如果我们想要将一个属性和成员变量进行对接，直接定义一个属性即可，也不需要再 m 文件中使用 @synthesize 关键字进行对接，SDK 已经自动帮我们生成了<code>_ 属性名</code>的成员变量，在类中我们只可以使用 _name 来获取成员变量。</p><p>因为成员变量是在类内才能进行调用的，所以现在成员变量在 m 文件中定义和在 h 文件中定义是没有区别的。建议在 m 文件定义吧，但是属性是一定要在 h 文件中定义的。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h3><p>方法的定义是在 h 文件中，这里只有一个方法的声明，声明的形式：</p><p>方法类型 (方法返回值类型) 方法名 : (参数 1 类型) 参数 1 名字  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(returnType)methodName:(typeName) variable1 :(typeName)variable2;</span><br></pre></td></tr></table></figure><ul><li>方法类型，可选的有 + 或者 -，其中前者代表类方法，后者代表对象方法</li><li>方法返回值类型：要用括号包裹起来，eg：(void) ，(int) ，(NSString *)等</li><li>方法名：和其它语言相同</li><li>方法参数：没有参数，那么方法名后面就不用跟冒号了，如果有参数，那么方法名后边要跟一个冒号，然后</li></ul><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- void showName;</span><br><span class="line">- void showName : (NSString *) name;</span><br><span class="line">- void showName : (NSString *) name andAge:(int) age;</span><br></pre></td></tr></table></figure><h3 id="方法的实现"><a href="#方法的实现" class="headerlink" title="方法的实现"></a>方法的实现</h3><p>方法的实现是在 m 文件中；</p><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>使用[ ] ，完成调用，分为两种情况：</p><ul><li>对于静态方法：[类名 方法名]</li><li>对于非静态方法：[对象名 方法名]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = [[Person alloc] init];</span><br><span class="line">[p1 showName]；</span><br><span class="line">[p1 showName: @&quot;zx&quot;]；</span><br><span class="line">[p1 showName: @&quot;zx&quot; andAge: 24]；</span><br></pre></td></tr></table></figure><h3 id="关于-init-方法"><a href="#关于-init-方法" class="headerlink" title="关于 init 方法"></a>关于 init 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># import&lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (id) init;</span><br><span class="line">- (instancetype)init;</span><br><span class="line">- (instancetype)initPerson:(NSString *)name :(int)age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>关于 init 方法，我们可以在类的声明中重写，其返回值类型可以是 id，表示任何类型；返回值类型可以使 instancetype，表示当前类型；单纯的初始化方法的话，其实都可以，但是要赋值的时候可能会出错，所以推荐使用后者；因为我们所有的类其实都是 NSObject 的子类，所以 init 方法不在类声明中也是可以的，如果声明的话，就相当于重写了；这里重写 init 方法的意义在于给初始化方法提供多个参数，供具体的类来使用。例如上面的 initPerson，具体实现略；</p><p>那么在使用时就可以用下面的方法来调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Person * p1 = [[Person alloc]initPerson:@&quot;zx&quot;:20];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>屏蔽内部实现细节，只提供一个使用的接口。和 Java 无异；</p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>可用来修饰成员变量（注意不是属性）</p><ul><li>@public :在类内，类外都可以使用，并可以被继承；在类外的使用方法是：p1-&gt;name</li><li>@protected：默认访问修饰符，在类内可以使用，类外不可被使用，可以被继承</li><li>@private：只能在类内使用，不可以被继承；</li><li>@package：框架权限，在框架内相当于 protected，在框架外，相当于 private；</li></ul><p><strong>注：方法是没有访问修饰符</strong></p><p>这个用法完全和 C 语言是一样的，如果不想让人在外面使用，可以不在 h 文件中申明该方法，那么在类外就无法调用该方法了（类外引用的永远都是 h 文件，而看不到具体实现），调用直接报错；而我们可以在 m 文件中写一个方法的声明，这样的话就可以在 m 文件内部被其它方法调用了。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>OC 中也是单继承的，要想实现多继承的效果，可以使用协议；</p><p>关于继承，我们在之前其实已经见到过了，就是继承了 NSObject；NSObject 是所有类型的基类；</p><p>继承的语法：</p><ol><li><p>在 h 文件中</p><p>这时 import 的是父类的 h 文件，并且在 @interface 后面类名，后面加冒号，然后跟父类名字；</p></li><li><p>在 m 文件中，我们可以对父类中在 h 文件中声明的方法进行一个覆盖，不覆盖默认使用的是父类中的方法</p></li></ol><p>父类在 h 文件中声明的方法才可以被子类继承，如果没有在 h 文件中声明，那么表示只有父类自己内部可以用，外部，子类均不可用。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>父类引用指向子类对象；</p><p>OC 中不支持方法重载，只能重写</p><p>其它特点和 Java 无异。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volley源码解析-线程切换</title>
      <link href="/2017/05/28/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
      <url>/2017/05/28/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="ResponseDelivery-接口"><a href="#ResponseDelivery-接口" class="headerlink" title="ResponseDelivery 接口"></a>ResponseDelivery 接口</h1><p>无论是执行网络请求还是从本地文件中读取缓存，都是放在子线程中去执行的，那么读取到响应之后，要做的工作就是把响应从子线程分发到 UI 线程，本节将学习 Volley 中是如何实现这一功能的。</p><p>这里用到了一个接口：<strong>ResponseDelivery</strong>，其中定义了一些方法，用来将响应从子线程发送的 UI 线程。</p><ul><li><code>public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response)</code>：将 response 发送到 UI 线程；</li><li><code>public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</code>：和上一个方法功能类似，只不过多加了一个 Runnable，其作用是在 response 被发送到 UI 线程之后，执行该 runnable</li><li><code>public void postError(Request&lt;?&gt; request, VolleyError error)</code>：在网络请求过程中出现了错误，Volley 会将该错误封装成一个 VolleyError，调用该方法可以将该 VolleyError 发送的 UI 线程，由具体的业务处理不同的错误，显示不同的提示信息；</li></ul><h1 id="ExecutorDelivery-实现类"><a href="#ExecutorDelivery-实现类" class="headerlink" title="ExecutorDelivery 实现类"></a>ExecutorDelivery 实现类</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>而 ResponseDelivery 只有一个实现类——ExecutorDelivery，无论是在 NetworkDispatcher 中还是 CacheDispatcher 中得到了 response，都会调用该类的 postResponse 方法，将结果发送到 UI 线程，ExecutorDelivery 是何时被创建的呢？答案就是创建 RequestQueue 时，在 RequestQueue 的构造方法中。ExecutorDelivery 的创建方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</span><br></pre></td></tr></table></figure><p>这里看到构造方法中传入了一个 Handler，并且传入的是 MainLooper，那么首先子线程向 UI 线程发送数据的机制肯定是通过 Handler 无疑了。</p><h2 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h2><p>ExecutorDelivery 中还有一个很重要的成员变量<code>Executor mResponsePoster</code>这是一个线程池，其创建过程也是在构造方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">            handler.post(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，ExecutorDelivery 中线程池 mResponsePoster 的作用就是在线程中调用 handler，发送 runnable，通过这种形式使得 runnable 在 UI 线程中执行。</p><h2 id="内部类——Runnable-子类"><a href="#内部类——Runnable-子类" class="headerlink" title="内部类——Runnable 子类"></a>内部类——Runnable 子类</h2><p>上面提到线程池的内部是通过 handler，发送 runnable，通过这种形式使得 runnable 在 UI 线程中执行，那么这个 runnable 对象又是如何与 request 和 response 关联的呢？这就用到了 ExecutorDelivery 中的一个内部类 ResponseDeliveryRunnable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        mRequest = request;</span><br><span class="line">        mResponse = response;</span><br><span class="line">        mRunnable = runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">            mRequest.deliverResponse(mResponse.result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.deliverError(mResponse.error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">        <span class="comment">// and the request can be finished.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></span><br><span class="line">        <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRunnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ResponseDeliveryRunnable 的构造方法，将 request，response 传入，同时还可以在传入一个 Runnable 对象，这在 ResponseDelivery 的第二个接口中有提到过，该 Runnable 会在 response 被发送到 UI 线程后立即执行。</p><p>那么 ResponseDeliveryRunnable 类中的 run 方法则是整个线程切换的核心了；</p><p>要明确一点是，如果能执行到这里，那么 request 一定是得到 response 了</p><p>首先，判断该 request 是不是在得到请求还为发送到 UI 线程之前被取消了，如果是的话，执行 request 的 finish 方法</p><p>接着，如果 response 成功返回了，那么就调用 request 的 deliverResponse 方法，这个方法也很眼熟吧，这是我们在自定义 request 时必须要实现的方法，这个方法内部一般是回调 request 中的 listener 的 onResponse，否则，如果该 response 没有成功返回，会调用 request 的 deliverError 方法，而这个方法内部 request 的默认实现是调用 ErrorListener 的 onErrorResponse 方法。</p><p>最后调用 request 的 finish 方法，表示该请求已经执行结束了，同时，如果 ResponseDeliveryRunnable 的构造方法中的第三个参数 runnable 不为空，立即执行该 runnable 的 run 方法。</p><p>至此，在子线程中的 response 就被发送到 UI 线程中去了。其实说到这里，你可能发现，在 Android 体系中，很多框架都要在子线程中执行任务，然后将结果传输到 UI 线程，其处理的方式大多类似，那就是 “线程池” + “Handler” 的组合 。较为知名的框架<code>RxJava</code>，<code>EventBus</code>等都是这样实现的。关于 RxJava 的实现方式，请参考之前的一片文章<a href="https://zachaxy.github.io/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/">RxJava源码详解-线程切换原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volley源码解析-网络</title>
      <link href="/2017/05/24/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C/"/>
      <url>/2017/05/24/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="NetWork-接口"><a href="#NetWork-接口" class="headerlink" title="NetWork 接口"></a>NetWork 接口</h1><p>一个 request 并不是一开始就被添加进 mNetworkQueue 中的，而是先添加进 mCacheQueue，如果缓存不存在或者缓存失效，才会走网络路线，这里一旦用到了网络，就用到了 NetWork 接口，该接口是整个 Volley 库的网络请求的最外层的封装，其内部只包含了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs the specified request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request Request to process</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> NetworkResponse&#125; with data and caching metadata; will never be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> VolleyError on errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行网络请求，返回 NetWorkResponse，而该接口只有一个实现类——BasicNetwork，那么就看一下 BasicNetwork 中是如何实现该方法，执行网络请求的。</p><h2 id="BasicNetwork"><a href="#BasicNetwork" class="headerlink" title="BasicNetwork"></a>BasicNetwork</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Gather headers.</span></span><br><span class="line">            Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">            httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">            StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">            <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">            <span class="comment">// Handle cache validation.</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                        request.getCacheEntry().data, responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">            <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">              <span class="comment">// no-content request.</span></span><br><span class="line">              responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">            logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">            attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">            NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                        responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                        statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                    attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                            request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 11 行，执行了 addCacheHeaders 方法，因为执行网络请求分两种情况，第一种：全新的请求；第二种：超时的缓存，也就是说缓存过期了，再次请求时需要附带上一次请求所带的<code>If-None-Match</code>或者<code>If-Modified-Since</code>等信息（如果有的话），如果是全新的请求，则没有这些；</p><p>第 12 行，利用 HttpStack 执行其 performRequest 方法，这是网络请求的核心。关于 HttpStack，请参考中的讲解；</p><p>第 13、14 行获取执行网络请求后的状态行和状态码</p><p>第 16 行，将 12 行中执行的网络请求的 响应的头部保存到一个 map 中，作为响应头</p><p>第 18 行，首先做一个特殊的处理，如果状态码是 304，也就是表明当前缓存依然可用，那么直接从缓存中读出数据，然后封装成 NetworkResponse，直接返回</p><p>第 24 行，判断响应中的响应体是否为空，因为例如像 204 表示响应执行成功，但没有数据返回，浏览器不用刷新，不用导向新页面，所以我们为 response 的内容添加一个长度为 0 的字节数组；否则读取响应中的响应体，将其转换为字节数组，然后赋给 responseContents</p><p>第 39 行，最终返回由 statusCode, responseContents, responseHeaders 组成的 NetworkResponse。</p><p><strong>注意：第 36 行，这里判断了如果响应码是在 200 范围之外的，直接抛出了 IOException，除了在 18 行处理的 304，其它非 2XX 的响应均不能处理，这也是 Volley 的一个缺陷。</strong></p><h2 id="关于-HttpStack"><a href="#关于-HttpStack" class="headerlink" title="关于 HttpStack"></a>关于 HttpStack</h2><p>这是一个接口，该接口中只有一个方法 performRequest，该方法的作用是：根据所给的参数，执行 HTTP 请求，并返回服务器的响应。</p><p>这个接口有两个实现类：HurlStack 和 HttpClientStack；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs an HTTP request with the given parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,</span></span><br><span class="line"><span class="comment">     * and the Content-Type header is set to request.getPostBodyContentType().&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the request to perform</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> additionalHeaders additional headers to be sent together with</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@link</span> Request#getHeaders()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the HTTP response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道在 Android 中主要提供了两种方式来进行 HTTP 操作，分别是：HttpURLConnection 和 HttpClient。而 Volley 作为一个网络请求库，其底层网络请求的实现正是依靠这两种实现方式，所以 HttpStack 的两个实现类中，HurlStack 是基于 HttpURLConnection ，而 HttpClientStack 则基于 HttpClient 。不过 HttpURLConnection 和 HttpClient 的用法还是稍微有些复杂的，如果不进行适当封装的话，很容易就会写出不少重复代码。那么接下来看一下 HurlStack 和 HttpClientStack 是如何对 HttpURLConnection 和 HttpClient 进行封装的，这里选 HurlStack 类，主要看其如何实现 HttpStack 中的 performRequest 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">        connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">    &#125;</span><br><span class="line">    setConnectionParametersForRequest(connection, request);</span><br><span class="line">    <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">    ProtocolVersion protocolVersion = <span class="keyword">new</span> ProtocolVersion(<span class="string">"HTTP"</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">        <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StatusLine responseStatus = <span class="keyword">new</span> BasicStatusLine(protocolVersion,</span><br><span class="line">            connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">    BasicHttpResponse response = <span class="keyword">new</span> BasicHttpResponse(responseStatus);</span><br><span class="line">    response.setEntity(entityFromConnection(connection));</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</span><br><span class="line">            response.addHeader(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 4 行，拿到请求中的 url 字符串</p><p>第 5 行，创建一个 Map，并将 request 中的 headers 都添加到该 map 中，（我们在构造 request 的时候，可以重写其中的 getHeaders 方法，在内部创建一个 Map，然后把 HTTP 请求中需要额外定制的 header 添加到该 map 中），同时把 performRequest 方法中的第二个参数 additionalHeaders 中的所有键值对也都添加到 map 中。</p><p>第 16 行，创建了 HttpURLConnection，这里设置了连接超时时间，读取数据的超时时间，如果我们使用的是 HTTPS 协议，那么还要对该连接设置 SSL 相关的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HttpURLConnection <span class="title">openConnection</span><span class="params">(URL url, Request&lt;?&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    HttpURLConnection connection = createConnection(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeoutMs = request.getTimeoutMs();</span><br><span class="line">    connection.setConnectTimeout(timeoutMs);</span><br><span class="line">    connection.setReadTimeout(timeoutMs);</span><br><span class="line">    connection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">    connection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use caller-provided custom SslSocketFactory, if any, for HTTPS</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"https"</span>.equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 17 行，将我们之前第 5 行的 map 中所有的 HTTP 头部设置添加到连接中。</p><p>第 20 行，设置 HTTP 的请求方法。如果我们在创建 request 时没有设置请求方法，那么需要根据该 request 中是否包含 body，如果包含，则设置为 post，如果不包含，则设置为 get。但是在创建 request 时不设置请求方法，是极为不负责的形式，我们在编码时不要这么做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setConnectionParametersForRequest</span><span class="params">(HttpURLConnection connection,</span></span></span><br><span class="line"><span class="function"><span class="params">Request&lt;?&gt; request)</span> <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (request.getMethod()) &#123;</span><br><span class="line"><span class="keyword">case</span> Method.DEPRECATED_GET_OR_POST:</span><br><span class="line"><span class="comment">// This is the deprecated way that needs to be handled for backwards compatibility.</span></span><br><span class="line"><span class="comment">// If the request's post body is null, then the assumption is that the request is</span></span><br><span class="line"><span class="comment">// GET.  Otherwise, it is assumed that the request is a POST.</span></span><br><span class="line"><span class="keyword">byte</span>[] postBody = request.getPostBody();</span><br><span class="line"><span class="keyword">if</span> (postBody != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Prepare output. There is no need to set Content-Length explicitly,</span></span><br><span class="line"><span class="comment">// since this is handled by HttpURLConnection using the size of the prepared</span></span><br><span class="line"><span class="comment">// output stream.</span></span><br><span class="line">connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">connection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">connection.addRequestProperty(HEADER_CONTENT_TYPE,</span><br><span class="line">request.getPostBodyContentType());</span><br><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(connection.getOutputStream());</span><br><span class="line">out.write(postBody);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Method.GET:</span><br><span class="line"><span class="comment">// Not necessary to set the request method because connection defaults to GET but</span></span><br><span class="line"><span class="comment">// being explicit here.</span></span><br><span class="line">connection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Method.DELETE:</span><br><span class="line">connection.setRequestMethod(<span class="string">"DELETE"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Method.POST:</span><br><span class="line">connection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">addBodyIfExists(connection, request);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Method.PUT:</span><br><span class="line">connection.setRequestMethod(<span class="string">"PUT"</span>);</span><br><span class="line">addBodyIfExists(connection, request);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown method type."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看一下其中的 post 方法，除了设置请求方法为 post 之外，还要把请求体添加上去，这就用到了 addBodyIfExists 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBodyIfExists</span><span class="params">(HttpURLConnection connection, Request&lt;?&gt; request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line"><span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());</span><br><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(connection.getOutputStream());</span><br><span class="line">out.write(body);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先获取 request 中的 body（字节数组），如果 body 不为空，那么为连接添加”Content-Type”的头部，其值默认为“application/x-www-form-urlencoded”，默认编码方式为”UTF-8”。拼接起来一项请求头是：”Content-Type:application/x-www-form-urlencoded; charset=UTF-8”。</p><p>（如果值为：x-www-form-urlencoded，那么其请求体中的数据采用的是键值对，形如：key1=val1&amp;key2=val2），关于 HTTP 相关知识，请参考<a href>HTTP 包结构</a></p><p>额，刚刚扯得有点远了，再回到 performRequest 方法中，前面是阐述了一个 HTTP 的<strong>request</strong>是如何构造的，那么接下来就该执行 HTTP 请求了</p><p>第 23 行，这是一个阻塞的方法，一直等待服务器的响应。当然我们在 request 中已经设置了等待时间。</p><p>第 29 行，拿到 HTTP 的状态行和响应体，最终包装成 BasicHttpResponse；</p><p>第 33 行，拿到响应头部，应该是一个以 key-value 形式的 map，一次解析出响应头，添加到 response 中，最终返回。</p><h1 id="NetworkDispatcher-线程"><a href="#NetworkDispatcher-线程" class="headerlink" title="NetworkDispatcher 线程"></a>NetworkDispatcher 线程</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>首先看一下 NetworkDispatcher 的构造方法，传入了在 RequestQueue 中创建的 mNetworkQueue, mNetwork, mCache, mDelivery，其中 mNetwork 是 RequestQueue 的构造方法中传入的第二个参数 Network；mCache 是在 RequestQueue 的构造方法中传入的第一个参数 Cache，mDelivery 用来将子线程中得到的响应发送要主线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&gt; queue,</span></span></span><br><span class="line"><span class="function"><span class="params">        Network network, Cache cache,</span></span></span><br><span class="line"><span class="function"><span class="params">        ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mQueue = queue;</span><br><span class="line">    mNetwork = network;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="run-方法"><a href="#run-方法" class="headerlink" title="run 方法"></a>run 方法</h2><p>接下来看一下 NetworkDispatcher 线程的 run 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">Request request;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Take a request from the queue.</span></span><br><span class="line">request = mQueue.take();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line"><span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the request was cancelled already, do not perform the</span></span><br><span class="line"><span class="comment">// network request.</span></span><br><span class="line"><span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform the network request.</span></span><br><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the server returned 304 AND we delivered a response already,</span></span><br><span class="line"><span class="comment">// we're done -- don't deliver a second identical response.</span></span><br><span class="line"><span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse the response here on the worker thread.</span></span><br><span class="line">Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to cache if applicable.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line"><span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post the response back.</span></span><br><span class="line">request.markDelivered();</span><br><span class="line">mDelivery.postResponse(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 3 行，设置当前线程的优先级为：Process.THREAD_PRIORITY_BACKGROUND，后台线程，相对来说优先级还是比较低的。</p><p>第 5 行，可以看到该线程是个死循环。</p><p>第 8 行，从 BlockingQueue 中取出一个 request，如果没有的话，就会被阻塞，也不会占用系统资源，赞。</p><p>第 22 行，如果该 request 还未被执行，但是在其它线程取消了，那么调用 request 的 finish 方法，其主要功能是将该 request 从 RequestQueue 的 mCurrentRequests 中移除掉当前 request。</p><p>第 33 行，如果能走到这一步，就表明真的要执行网络请求了，还记的 NetworkDispatcher 的构造方法中传入的 Network 对象吗，调用了它的 performRequest 方法，但是真正的执行者是 Network 的实现类 BasicNetwork。具体流程已经在上面进行了分析。</p><p>第 38 行，如果响应是 304 并且该 request 已经分发了，那么调用 request 的 finish 方法，该方法是将 RequestQueue 中 mWaitingRequests 队列中取出相同的 request，然后添加到 mCacheQueue 中。</p><p>第 44 行，调用 request 的 parseNetworkResponse 方法对 33 得到的 networkResponse 进行解析，至于具体怎么解析，还记的我们自定义请求时需要重写的方法，就是这个方法，所以具体如何解析 networkResponse 完全由你自己决定</p><p>第 49 行，执行缓存相关的操作，具体实现请参考<a href="https://zachaxy.github.io/2017/05/23/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BC%93%E5%AD%98/">Volley 源码解析-缓存</a></p><p>第 55 行，将该 request 标记为已分发</p><p>第 56 行，将该 request 进行分发，调用了 mDelivery 的方法，这个 mDelivery 是在 NetworkDispatcher 的构造方法中传入进来的，具体创建是在 RequestQueue 的构造方法中，期创建方式是：<code>new ExecutorDelivery(new Handler(Looper.getMainLooper()))</code>看到这相信各位也能猜个大概了，我们前面也说了这个 ResponseDelivery 的作用是分发 response，我们在应用中请求网络数据，首先在子线程中执行网络请求，得到了响应之后，肯定要将结果返回到主线程，如何发呢？答案就是 Handler，而 ResponseDelivery 正是包装了一个 Handler；具体如何实现请参考<a href>Volley 源码解析-线程切换</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，一个完整的网络请求的过程就分析完了，这里在总结一下网络请求的过程：</p><p>需要执行网络的 request 无非是两种情况：</p><ul><li>第一种：一个新的请求，之前没有执行过，自然也没有对应的缓存，所以必须要走 NetworkDispatcher 这个线程；</li><li>第二种：之前执行过该请求，所以先从缓存中取，但是缓存不可用（缓存过期了或者不存在了），所以也必须要走 NetworkDispatcher 这个线程；</li></ul><p>走网络路线，有一个接口 Network，该接口内部封装了执行网络操作的所有方法，其唯一实现类是 BasicNetwork，而 BasicNetwork 中有包含了 HttpStack，HttpStack 接口的实现类才是真正实现了真正执行网络请求的功能（HttpURLConnection 和 HttpClient）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据场景下的解决思路</title>
      <link href="/2017/05/24/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
      <url>/2017/05/24/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>1.海量日志数据，提取出现次数最多的一条(IP)</strong><br>注意,这里说的是 IP,那么<strong>IP 是有大小范围的</strong>,是 32 位的<br>首先把海量数据放在一个文件中,接下来对已每个 IP 都进行<strong>mod(1000)</strong>,那么这样的话就会产生 1000 个小文件,将海量数据进行了分散,针对这 1000 个文件中的每个小文件,使用 hashMap 进行统计,其中将 IP 作为 key,该条 IP 出现的次数作为 value。这样统计出每个小文件中出现最多的 IP,这样就取到了 1000 个 IP,然后从这 1000 个 IP 中找到出现次数最大的一个。</p><p><strong>2.海量字符串(基于搜索热度),提取出现搜索词最多的十条记录</strong><br>注意,这些海量搜索词中很多是重复的,所以字符串的种类其实并不多,可能只有原来的一半的样子,这时我们使用一个 hashMap 来保存每个字符串的引用和出现次数,内存是可以放的下的,所求是出现次数最多的,然后使用堆排序中的大根堆,找到最大的 10 个。</p><p><strong>3.一个 1G 大小的一个文件，里面每一行是一个词，词的大小不超过 16 字节，内存限制大小是 1M。返回频数最高的 100 个词</strong></p><p>这个题目就没有前一个题目那么幸运了,也许没有很多重复的单词，我们无法将全部内容都读取到内存中,所以需要<strong>分成小文件</strong>;</p><p>1G 大小，每个单词 16 字节，那么一共有 <code>1G/16byte = 2^26</code>个单词</p><p>顺序读取该大文件，对于每个词 x，取 hash(x)%5000，然后按照该值存到 5000 个小文件（记为 x0,x1,…x4999）中(平均每个文件大约 20w 个单词)。这样每个文件大概是 200k 左右(如果单词比较随机的话)。<br>对于每个文件,使用 HashMap 统计每个文件中出现的词以及相应的频率,然后取出每个文件中出现频率最高的 100 个词(用最大堆排好序),这样就得到了 5000*100 个词,放到一个数组中,进行归并排序即可;</p><p><strong>4.有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。</strong><br>顺序读取 10 个文件，按照 hash(query)%10 的结果将 query 写入到另外 10 个文件（记为）中。这样新生成的文件每个的大小大约也 1G（假设 hash 函数是随机的）。</p><p>分好这 10 个文件之后,就需要进行着 10 个文件,进行快速/堆/归并排序按照出现次数进行排序,然后这 10 个文件时排好序的,在对这 10 个文件进行归并排序;<br>​<br>找一台内存在 2G 左右的机器，依次对用 hashMap(query,queryCount)来统计每个 query 出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的 query 和对应的 queryCout 输出到文件中。这样得到了 10 个排好序的文件。</p><p><strong>5.给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4G，让你找出 a、b 文件共同的 url？</strong><br>遍历文件 a，对每个 url 求取 hash(url)%1000，然后根据所取得的值将 url 分别存储到 1000 个小文件（记为 a0,a1,…,a999）中。这样每个小文件的大约为 300M。</p><p>遍历文件 b，对每个 url 求取 hash(url)%1000，然后根据所取得的值将 url 分别存储到 1000 个小文件（记为 b0,b1,…,b999）中。这样每个小文件的大约为 300M。</p><p>那么接下来针对每一个 ax VS bx 文件（这时可以保证每个如果是相同的 url，都在相同的 ax 或 bx 中）,可以把其中一个小文件的 url 存储到 hashSet 中。然后遍历另一个小文件的每个 url，看其是否在刚才构建的 hashSet 中，如果是，那么就是共同的 url，存到文件里面就可以了。</p><p><strong>6.在 2.5 亿个整数中找出不重复的整数的个数</strong><br>既然是整数,那么整数最多也就是 2^32 个,定义一个 2bit 的标志,00 没有出现过,01,出现一次;10,出现多次;11,无意义;那么整个 2^32<em>2bit 是完全可以在内存中放得下的<br>接下来遍历一次 2.5 亿个数,然后映射到 2bit 中,然后再遍历一次 2^32</em>2bit 的内存空间,只找 01 标志位的;</p><p><strong>7.给 40 亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</strong><br>同 6 一样,将这 40 亿个数映射到一个 1bit 的内存中,如果是 0 则没出现过,如果是 1 则出现过;</p><p>方案 2:将这 40 亿个数按照每一位的 0 或 1 来分开：</p><p>2^32 为 40 亿多，所以给定一个数可能在，也可能不在其中；这里我们把 40 亿个数中的每一个用 32 位的二进制来表示假设这 40 亿个数开始放在一个文件中。</p><p>然后将这 40 亿个数分成两类:<br>1.最高位为 0<br>2.最高位为 1<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20 亿，而另一个&gt;=20 亿（这相当于折半了）；</p><p>与要查找的数的最高位比较并接着进入相应的文件再查找</p><p>再然后把这个文件为又分成两类:<br>1.次最高位为 0<br>2.次最高位为 1<br>​<br>并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10 亿，而另一个&gt;=10 亿（这相当于折半了）；<br>与要查找的数的次最高位比较并接着进入相应的文件再查找。<br>…….<br>以此类推，就可以找到了,而且时间复杂度为 O(logn)。</p><p><strong>8.海量数据中找出重复次数最多的一个</strong><br>先做 hash，然后<strong>求模映射为小文件</strong>，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><p> <strong>9.海量数据中找出重复次数最多的 N 个</strong><br>首先还是用 hash 进行分类,假设分成 1k 个组,对这 1k 个组中,分别进行堆排序,找出前 N 个,现在就有 1K*N 个数据,那么接下来就是对这 1K 个组进行归并或者堆排序。</p><p><strong>10.一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，请给出思想，给出时间复杂度分析。</strong></p><p>方案 1：这题是考虑时间效率。用<strong>trie 树</strong>统计每个词出现的次数，时间复杂度是<code>O(n*le)</code>（le 表示单词的平均长度）。然后是找出出现最频繁的前 10 个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是<code>O(n*lg10)</code>。所以总的时间复杂度，是<code>O(n*le)</code>与 O<code>(n*lg10)</code>中较大的哪一个。</p><p>方案 2：先将这 1w 个单词进行 hash（eg：mod 10），分成 1000 个组，每组创建最大堆，维持 10 个元素，然后在对着 1000 个组中的 top10 进行归并，找到前 10 个即停止。</p><p><strong>11.100w 个数中找出最大的 100 个数。</strong><br>在前面的题中，我们已经提到了，用一个含 100 个元素的最大堆完成。复杂度为<code>O(100w*lg100)</code>。或者先分组（组内用堆排序），然后归并，找到前 100 即停止。</p><p>参考：<br><a href="http://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="noopener">十道海量数据处理面试题与十个方法大总结</a><br><a href="http://taop.marchtea.com/06.02.html" target="_blank" rel="noopener">分而治之</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volley源码解析-缓存</title>
      <link href="/2017/05/23/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BC%93%E5%AD%98/"/>
      <url>/2017/05/23/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Cache-接口"><a href="#Cache-接口" class="headerlink" title="Cache 接口"></a>Cache 接口</h1><p>我们再来回顾一下一个 Request 被添加到 RequestQueue 后，首先是被添加到 mCacheQueue 中，而不是添加到 mNetworkQueue，因为这个请求可能之前执行过，先看一下缓存中有没有，如果没有或者过期，那么再将该请求从 mCacheQueue 中移除，并添加到 mNetworkQueue。</p><p>那么 Cache 中保存了哪些信息呢？</p><p>代码过多这里就不贴出来了，首先作为缓存，肯定要指定一个缓存文件夹以及其保存的位置，接着每个缓存最好是以键值对的形式存在，使用 HashMap 结构来保存，这样才能快速的通过 key 查找 value，key 对应的是一个 request 的 url，value 对应的是 request 得到的 response；</p><p>接下来，response 中需要保存哪些数据呢？首先肯定要保存响应体中的数据，使用字节数组保存。同时还应该保存这个请求的 Etag，有效时长等和 HTTP 缓存相关的字段，以及其它的响应头信息，这些信息被封装在一个 Entry 的类中，该类是 Cache 接口中的静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The data returned from cache. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** ETag for cache coherency. */</span></span><br><span class="line">    <span class="keyword">public</span> String etag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Date of this response as reported by the server. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** TTL for this record. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Soft TTL for this record. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Immutable response headers as received from server; must be non-null. */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if the entry is expired. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if a refresh is needed from the original data source. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DiskBasedCache"><a href="#DiskBasedCache" class="headerlink" title="DiskBasedCache"></a>DiskBasedCache</h2><p>前面讲了 Cache 的整体实现思路，接下来设计到具体如何读写缓存，这就用到了 Cache 的实现类 DiskBasedCache</p><p>这里只列出方法名和内部实现流程，就不一行一行的写了，因为太多了！！！</p><ul><li><p><code>private final Map&lt;String, CacheHeader&gt; mEntries = new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true)</code>是整个缓存的 map</p></li><li><p><code>CacheHeader</code>是map 中保存的 value，DiskBasedCache 中的静态内部类，是缓存文件中内容的一个概述，不包含 Cache 中 Entry 类中的 data 数据，因为这是要读取到内存中的，如果带上响应体数据，那么会占用很大一部分内存。</p><p> Cache.Entry 和 DiskBasedCache.CacheHeader 之间的关系：<strong>Entry = CacheHeader + byte[] data</strong></p><ul><li><p><code>writeHeader(OutputStream os)</code>:直接看其是如何将 CacheHeader 写到到文件中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">writeHeader</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">writeInt(os, CACHE_MAGIC);</span><br><span class="line">writeString(os, key);</span><br><span class="line">writeString(os, etag == <span class="keyword">null</span> ? <span class="string">""</span> : etag);</span><br><span class="line">writeLong(os, serverDate);</span><br><span class="line">writeLong(os, ttl);</span><br><span class="line">writeLong(os, softTtl);</span><br><span class="line">writeStringStringMap(responseHeaders, os);</span><br><span class="line">os.flush();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">VolleyLog.d(<span class="string">"%s"</span>, e.toString());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>readHeader(InputStream is)</code>和上面的 write 方法是相反的，怎么写的怎么读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CacheHeader <span class="title">readHeader</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">CacheHeader entry = <span class="keyword">new</span> CacheHeader();</span><br><span class="line"><span class="keyword">int</span> magic = readInt(is);</span><br><span class="line"><span class="keyword">if</span> (magic != CACHE_MAGIC) &#123;</span><br><span class="line"><span class="comment">// don't bother deleting, it'll get pruned eventually</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">&#125;</span><br><span class="line">entry.key = readString(is);</span><br><span class="line">entry.etag = readString(is);</span><br><span class="line"><span class="keyword">if</span> (entry.etag.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">entry.etag = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">entry.serverDate = readLong(is);</span><br><span class="line">entry.ttl = readLong(is);</span><br><span class="line">entry.softTtl = readLong(is);</span><br><span class="line">entry.responseHeaders = readStringStringMap(is);</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个很有意思的<strong>写缓存文件的技巧</strong>，因为这里涉及到了写 int，long，String，那么如何去写呢？ 方法是：如果你写的是 int，那么就用 4 字节来表示，如果是 long，那么就用 8 字节来表示，这样在读的时候，只要是读 int，那么直接向后读 4 个字节，然后拼装成 int 即可；至于字符串，统一将其转换成 UTF8 格式的字节数据，并得到数组长度，首先写入 long 类型的长度，然后再将字节数组写入，在读取的时候先读取 8 字节的 long 值，得到后续字节数组的长度，然后在读取后面相应长度的字节数组，转换为字符串即可。</p></li></ul></li><li><p><code>public synchronized void initialize()</code>初始化上面的 map，遍历缓存文件夹，读取每个缓存文件，然后不断的调用 CacheHeader 的 readHeader 方法读取 CacheHeader，并添加到 map 中</p></li><li><p><code>public synchronized void put(String key, Entry entry)</code>首先调用 CacheHeader 的 writeHeader 方法将数据写入缓存文件，在将 data 数据额外写入缓存文件；同时将该 entry 对应的 entryHeader 添加到 map 中；</p></li><li><p><code>public synchronized Entry get(String key)</code>先从 map 中通过 key 得到 CacheHeader，在根据 key 得到缓存文件名（将 key 的字符串均分为前后两部分，前半部分的 hashCode 和后半部分的 hashCode 拼接起来），然后读取缓存文件中的 data 数据，和 CacheHeader 组合起来得到 Entry。</p></li><li><p><code>public synchronized void remove(String key)</code>先从 map 中删除掉 key 对应的数据，然后删除缓存文件中对应的文件</p></li><li><p><code>public synchronized void clear()</code>：清空缓存，可以在应用的设置中提供这一项。有一个对应的 ClearCacheRequest，专门负责清空缓存。</p></li></ul><h1 id="CacheDispatcher-线程"><a href="#CacheDispatcher-线程" class="headerlink" title="CacheDispatcher 线程"></a>CacheDispatcher 线程</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>CacheDispatcher 线程是会不断的执行读缓存的操作，如果能读到缓存，那么将数据用 ResponseDelivery 发送到 UI 线程，否则将 request 提交给 NetworkDispatcher 来处理。</p><p>首先看其构造方法，传入了在 RequestQueue 中创建的 mCacheQueue, mNetworkQueue, mCache, mDelivery 四个变量。注意这个 mCache 是在 RequestQueue 的构造方法中传入的第一个参数 Cache。也就是说 CacheDispatcher 内部只有这几个成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Request&gt; cacheQueue, BlockingQueue&lt;Request&gt; networkQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        Cache cache, ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mCacheQueue = cacheQueue;</span><br><span class="line">    mNetworkQueue = networkQueue;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="run-方法"><a href="#run-方法" class="headerlink" title="run 方法"></a>run 方法</h2><p>接下来看一下其 run 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">            <span class="comment">// at least one is available.</span></span><br><span class="line">            <span class="keyword">final</span> Request request = mCacheQueue.take();</span><br><span class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Attempt to retrieve this item from cache.</span></span><br><span class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                <span class="comment">// Cache miss; send off to the network dispatcher.</span></span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If it is completely expired, just send it to the network.</span></span><br><span class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></span><br><span class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></span><br><span class="line">                <span class="comment">// but we need to also send the request to the network for</span></span><br><span class="line">                <span class="comment">// refreshing.</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 4 行，设置当前线程的优先级为：Process.THREAD_PRIORITY_BACKGROUND，标准后台线程，相对来说优先级还是比较低的。</p><p>第 7 行，因为这里是 Cache，需要先进行一些初始化，这里调用了 Cache 的 initialize 方法，内部逻辑在上面已经说过了。</p><p>第 9 行，死循环，表明该线程不一直不断的从 mCacheQueue 中取 request</p><p>第 13 行，从 BlockingQueue 中取出一个 request，如果没有的话，就会被阻塞，也不会占用系统资源，赞。</p><p>第 17 行，如果该请求在执行之前，又被其他线程调用了 cancle 方法，那么就取消该 request 的执行。</p><p>第 23 行，从缓存中查看是否有该 request 的缓存，如果不存在，表明是一个新的请求，那么直接将该请求添加到 mNetworkQueue 中，下面的逻辑不用执行，重新从 BlockingQueue 中取 request</p><p>第 32 行，能走到这一行，表明缓存不为空，判断该缓存是否已经过期，这里判断的标准是：<code>this.ttl &lt; System.currentTimeMillis();</code>现在 HTTP1.1 的版本里面保存的都是存活时间，而不是绝对时间，但是考虑到我们的客户端可能会退出，所以无法用时间段来统计，这里还是转换成相对于客户端的绝对时间，再和当前时间进行比较。如果缓存过期了，那么需要将该 request 添加到 mNetworkQueue 中重新进行网络请求，但是在此之前，还要把缓存中的一些信息(“If-None-Match”&lt;=&gt;”etag”，”If-Modified-Since”&lt;=&gt;”serverDate”)附加到 request 中</p><p>第 41 行，能走到这一步，说明我们的缓存命中并且是可用的，此时需要把缓存中的数据读取出来，包装成 Response</p><p><code>Response&lt;?&gt; response = request.parseNetworkResponse(new NetworkResponse(entry.data, entry.responseHeaders));</code></p><p>第 45 行，虽然现在缓存已被转换为 Response，但是还要进行一步新鲜度验证，但是这一步新鲜度验证时多余的，因为 Entry 中的 softTtl 和 ttl 的值是相同的，而前面已经验证了是否过期，所以这一步是多余的，直接使用 ResponseDelivery 分发响应，关于响应的分发，请参阅<a href>Volley 源码解析-线程切换</a></p><p>如果不是新鲜的，那么首先将该 response 分发到 UI 线程显示，同时立即执行网络请求，获取最新的响应。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volley源码解析-请求队列</title>
      <link href="/2017/05/22/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97/"/>
      <url>/2017/05/22/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="整体理解"><a href="#整体理解" class="headerlink" title="整体理解"></a>整体理解</h1><p><a href="https://zachaxy.github.io/2017/05/20/Volley%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#自定义请求">上一节</a>，我们介绍了 Volley 的基本使用，再次回顾一下其整体流程：</p><ol><li>创建 RequestQueue 队列</li><li>创建 XXXRequest</li><li>将 2 中创建的 request 添加到 1 中创建的 RequestQueue 队列中</li></ol><p>整个流程就这么简单，添加到 RequestQueue 队列之后，队列中的请求就会自动被执行，我们只需要等待请求中的回调方法被调用即可。那么其内部是如何实现的呢？猜想：后台一定有一个子线程，不断的轮询 RequestQueue，如果其中有请求，那么就会执行网络请求，因为这是在子线程中执行，所以不会阻塞 UI 线程，等服务器有响应后，执行请求中的回调。所以如果让我们来设计一套网络请求框架的话，最基本的一定是这个思路。</p><p>那还等什么，马上打开源码验证一下我们的猜想对不对吧！等等，似乎还少了什么，有可能会出现这种情况，如果我们重复的执行某一个相同的请求（eg：不断的打开相同的图片），图片资源一般在短时间内很少改变的，如果我们重复执行网络请求，似乎不是很合理，所以对于相同的网络请求（相同的 url），我们应该将结果缓存起来，这样也符合 http 协议中缓存的思想，这样就避免消耗过多的流量。</p><p>那么接下来，我们就按照 Volley 使用的三步流程开始，进入源码，剖析 Volley 的内部流程，首先介绍的是创建请求队列：</p><h1 id="创建-RequestQueue-队列"><a href="#创建-RequestQueue-队列" class="headerlink" title="创建 RequestQueue 队列"></a>创建 RequestQueue 队列</h1><p>在介绍 RequestQueue 队列之前，这里先介绍几个关键的类，以便于我们更好的理解 Volley。</p><ul><li><strong>HttpStack：</strong>处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的<code>HurlStack</code>和 基于 Apache HttpClient 的<code>HttpClientStack</code>。关于 HttpStack 的详细理解，请参考<a href>Volley 源码解析-网络</a></li><li><strong>Volley：</strong>Volley 对外暴露的 API，通过 newRequestQueue 方法新建并启动一个请求队列<code>RequestQueue</code>。</li><li><strong>Request：</strong>表示一个请求的抽象类。<code>StringRequest</code>、<code>JsonRequest</code>、<code>ImageRequest</code> 都是它的子类，表示某种类型的请求。</li><li><strong>ResponseDelivery：</strong>返回结果分发接口，目前只有基于<code>ExecutorDelivery</code>的在入参 handler 对应线程内进行分发。</li><li><strong>Network：</strong>调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。</li><li><strong>Cache：</strong>缓存请求结果，Volley 默认使用的是基于 sdcard 的<code>DiskBasedCache</code>。<code>NetworkDispatcher</code>得到请求结果后判断是否需要存储在 Cache，<code>CacheDispatcher</code>会从 Cache 中取缓存结果。</li></ul><p>创建请求队列是我们在应用程序中是这样调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mQueue = Volley.newRequestQueue(context);</span><br></pre></td></tr></table></figure><p>其内部调用的 Volley 类中的静态方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们默认值传入了第一个参数 Context，第二个参数 HttpStack 默认为 null，接下来调用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line"></span><br><span class="line">    String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String packageName = context.getPackageName();</span><br><span class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">            <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    Cache cache = <span class="keyword">new</span> DiskBasedCache(cacheDir);</span><br><span class="line"></span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(cache, network);</span><br><span class="line">    queue.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2 行，创建一个文件夹，保存网络的请求缓存，默认路径是在：“/data/data/com.xxx.xxx（当前包）/cache/volley/”</p><p>第 4 行，创建了 User Agent，其默认值是：”volley/0”，接下来获取本应用的包名，如果可以获取到，那么将 User Agent 设置为：App 的 packageName/versionCode，这个 User Agent 用来设置 http 请求头的 User-Agent 字段。</p><p>第 12 行，因为我们传入的 HttpStack 为 null，所以就根据当前系统的版本(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。我们知道在 Android 中默认有两种。关于为何在不同的版本使用不同的 HttpStack，参考  <a href="http://blog.csdn.net/guolin_blog/article/details/12452307" target="_blank" rel="noopener">Android 访问网络，使用 HttpURLConnection 还是 HttpClient？</a>，关于 HttpStack 的详细讲解，请参考<a href>Volley 源码解析-网络</a></p><p>第 22 行，创建了一个 NetWork 对象，其实 NetWork 是一个接口，其实现类只有 BasicNetwork；简单介绍一下 NetWork 接口，其内部只有一个方法 performRequest，而实现类 BasicNetwork 其内部调用 HttpStack 处理请求来实现 NetWork 中的方法，并将结果转换为可被 ResponseDelivery 处理的 NetworkResponse。</p><p>第 23 行，创建了一个 Cache 对象，其实 Cache 也是一个接口，其实现类只有 DiskBasedCache；简单介绍一下 Cache，Volley 默认使用的是基于 sdcard 的 DiskBasedCache。Cache 接口中包含了对于缓存文件中初始化，添加缓存，超找缓存，删除缓存等常用操作。并不执行网络请求。</p><p>第 25 行，终于看到了 RequestQueue 的创建了，其构造方法将上面创建的 Cache 和 Network 的实例传入，<strong>注意这里传入的是父类引用（接口），也就是说执行网络请求或者缓存读取的业务逻辑都是以接口的形式来提供的，所以后面的编码都是基于接口的，而不针对具体实现类，从而达到了高扩展性。</strong></p><p>在 Volley 中的静态方法 newRequestQueue 中，创建 RequestQueue 的方法是使用了<code>new RequestQueue(cache, network)</code>，那么进入源码看一下其是如何创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(cache, network, threadPoolSize,<span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">mCache = cache;</span><br><span class="line">mNetwork = network;</span><br><span class="line">mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中创建队列是使用的 RequestQueue 最简单的构造方法，通过一些列不断的调用，最终调用了四个参数的方法，这里先关注一下<strong>ResponseDelivery</strong>这个类，该类的作用是将网络请求的结果或者从缓存读取数据的结果分发到主线程。具体实现在后面分析。</p><p>不要被 RequestQueue 的类名所迷惑，RequestQueue 本身并不是一个队列，而是其内部包含了若干队列，这些队列分别有不同的作用，具体内部队列在下一节介绍；</p><p>第 26 行，执行了 queue 的 start 方法，这里轻描淡写的一句 start 确包含了整个 Volley 框架的所有业务流程。先简单说一下 start 内部的流程，RequestQueue 中其实包含了两种线程，一种用来执行网络请求，一种用来从本地文件中读取缓存，这两种线程不断的从 RequestQueue 中取出 request，然后执行该 request。这个 start 方法内部其实就是将这两类线程运行起来。</p><p>第 28 行，返回最终创建的 RequestQueue。</p><h1 id="向-RequestQueue-中添加请求"><a href="#向-RequestQueue-中添加请求" class="headerlink" title="向 RequestQueue 中添加请求"></a>向 RequestQueue 中添加请求</h1><p>虽然我们创建了 RequestQueue 队列之后，其内部的线程就已经开启了，这里先不讨论细节，在接下来开启线程的部分讨论。因为创建了队列后，队列中并没有 request，所以不会执行任何操作。这里先看一下我们使用 Volley 的第三步，向队列中添加请求，调用的是 RequestQueue 中的 add 方法：</p><p>在介绍 add 方法之前，这里还有两个重要的变量需要介绍一下，分别是：mCacheQueue 和 mNetworkQueue；这是两个优先级队列，是 RequestQueue 的成员变量，其直接在 RequestQueue 创建的时候进行初始化：</p><p>这里设计为优先级队列，主要是考虑到我们的 request 是有优先级的，有的请求可能想立即被执行，那么就将其优先级调大一些，从而获得优先执行权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The cache triage queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mCacheQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The queue of requests that are actually going out to the network. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</span><br></pre></td></tr></table></figure><p>同时还有两个成员变量，mWaitingRequests 和 mCurrentRequests；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();</span><br></pre></td></tr></table></figure><p>上述四个变量的作用：</p><ul><li><strong>mCacheQueue</strong>：</li><li><strong>mNetworkQueue</strong>：保存需要真正执行网络请求的 request</li><li><strong>mWaitingRequests</strong>：</li><li><strong>mCurrentRequests</strong>：HashSet，用来保存添加到 RequestQueue 中的请求，只要该请求还没有响应，就一直在 mCurrentRequests 中保存。</li></ul><p>接下来我们进入 add 方法中看一下其具体的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">mCurrentRequests.add(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process requests in the order they are added.</span></span><br><span class="line">request.setSequence(getSequenceNumber());</span><br><span class="line">request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></span><br><span class="line"><span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">mNetworkQueue.add(request);</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">String cacheKey = request.getCacheKey();</span><br><span class="line"><span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</span><br><span class="line">&#125;</span><br><span class="line">stagedRequests.add(request);</span><br><span class="line">mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line"><span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></span><br><span class="line"><span class="comment">// flight.</span></span><br><span class="line">mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">mCacheQueue.add(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2 行，该 request 与当前 RequestQueue 进行关联绑定，标识该 request 是被添加到哪个 RequestQueue 中的。</p><p>第 5 行，将 request 添加到 mCurrentRequests 队列中。只要该请求还没有响应，就一直在 mCurrentRequests 中保存。</p><p>第 9、10 行，对添加进来的 request 设置一个序列号，作为区分不同的请求。addMarker 方法也会在后面的源码中经常遇到，其实就是为当前的 request 添加一个状态的描述，此时添加的描述为”add-to-queue”，表明该请求才刚被添加进来，还未执行。</p><p>第 13 行，判断该 request 是否是可以缓存的，如果我们不做特殊设置，所有的 request 默认都是可以缓存的，这样做是为了减少流量的使用。当然如果你的应用对实时性要求很高，每次请求都要获取服务器最新的数据，那么可以将调用<code>request.setShouldCache(false);</code>取消缓存，这样的话，该 request 就会被添加到 mNetworkQueue 队列中，那么 RequestQueue 的 add 方法就结束了</p><p>第 19 行，能走到这一步，说明 request 是可以被缓存的，那么首先获取该 request 的 getCacheKey 方法，该方法简单的返回了该请求的 url，接下来就判断 mWaitingRequests(HashMap)中是否存在以该 request 的 url 作为 key 的值，这里分两种情况来说，如果当前 request 是一个全新的请求，那么 mWaitingRequests 中肯定不存在该 key 的，所以走 else 分支，如果存在，那么说明我们之前执行过相同的请求，走 if 分支；接下来分别看一下这两个分支</p><p>第 31 行，这是一个全新的请求，那么在 mWaitingRequests 中，将该 request 的 url 作为 key 添加进去，但是其 value 设置 null，并将该 request 添加到 mCacheQueue 中。</p><p>第 21 行，这不是一个新的请求，之前执行过。那么拿到该 key 对应的 value，其 value 值是一个<code>LinkedList&lt;Request&gt;</code>,然后将该请求添加到这个 value 中。这里要注意的是：如果是第二次执行这个请求，会走到该 if 分支，但是从 mWaitingRequests 中获取 value 时是空的，因为第一次执行该请求时，走的是 else 分支，当时只是把 key 添加进来了，value 是空的，所以如果是第二次执行的话，获取的是一个空的 LinkedList，此时需要重新创建一个 LinkedList，并将自己添加进去，那么及诶按来如果是第三次，第四次等添加该请求时，就可以直接拿到 LinkedList，然后直接添加进去即可。</p><p><strong>总结</strong></p><p>request 被添加到 RequestQueue 中时，所经历的过程：</p><p><img src="http://oi8e3sh89.bkt.clouddn.com/image/%E6%A1%86%E6%9E%B6/Volley%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B.png" alt></p><h1 id="开启请求队列中的线程"><a href="#开启请求队列中的线程" class="headerlink" title="开启请求队列中的线程"></a>开启请求队列中的线程</h1><p>前面我们讲解了 RequestQueue 的创建时，调用了其 start 方法，这个方法虽然只有一句，但是其内部却是整个框架的核心，一起来看一下 start 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到两个重要的线程，我们在文章刚一开始根据 Volley 的使用方法，猜想其内部实现时也说到了，Volley 内部一定有一个线程不断的从 RequestQueue 中出请求，然后执行该请求。同时提供了缓存机制，就需要另一个线程从本地缓存中去取缓存。这分别对应了两个线程调度器：<strong>CacheDispatcher</strong>和<strong>NetworkDispatcher</strong>。</p><p>这里先说一下这两个调度器的作用：</p><ul><li><strong>CacheDispatcher：</strong>（extends Thread），用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。</li><li><strong>NetworkDispatcher</strong>：（extends Thread），用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理，并判断结果是否要进行缓存。</li></ul><p>那么在 start 方法中：</p><p>第 3 行，首先创建了一个 mCacheDispatcher 线程的实例，然后让该线程运行起来。</p><p>第 8 行，创建了 4 个 NetworkDispatcher 的线程实例，然后让着 4 个线程运行起来。这里为什么是 4 个，这是因为在创建 RequestQueue 的时候使用的是最简单的构造方法，只传入了 Cache 和 Network 两个参数。而 threadPoolSize 的参数使用了默认的 4，如果你想改变，可以使用 RequestQueue 三个参数的构造方法，第三个参数来指定 NetworkDispatcher 线程的数量。</p><p>目前总共 5 个线程就这样运行起来了，后面会用两个章节来分别讲解 Volley 中的网络请求（Network）和缓存（Cache）相关的部分，敬请期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volley框架详解-基本使用</title>
      <link href="/2017/05/20/Volley%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/20/Volley%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在往博客上整理一些之前看过的框架，翻到了已经推出很久的网络请求框架—— Volley。这是在 13 年由谷歌推出的一款轻量级的 Android 异步网络请求框架和图片加载框架。虽然现在市面上已经出现了比 Volley 更好的网络请求框架——Okhttp，和图片请求框架——Glide，但是个人认为 Volley 的源码比其它框架的源码更加优美，所以 Volley 的源码非常值得初学者拿来分析练手。</p></blockquote><h1 id="Volley-简介"><a href="#Volley-简介" class="headerlink" title="Volley 简介"></a>Volley 简介</h1><p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。</p><p>Volley 的特点：特别适合<strong>数据量小，通信频繁</strong>的网络操作。</p><h1 id="Volley-的主要特点"><a href="#Volley-的主要特点" class="headerlink" title="Volley 的主要特点"></a>Volley 的主要特点</h1><ol><li>扩展性强。Volley 中大多是<strong>基于接口</strong>的设计，可配置性强。</li><li>一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。</li><li>默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现。所以兼容性强。</li></ol><h1 id="Volley-的基本用法"><a href="#Volley-的基本用法" class="headerlink" title="Volley 的基本用法"></a>Volley 的基本用法</h1><p>在使用 Volley 之前，不要忘记在你的 manifest 文件中添加网络权限。</p><h2 id="（一）创建请求队列"><a href="#（一）创建请求队列" class="headerlink" title="（一）创建请求队列"></a>（一）创建请求队列</h2><p>首先需要创建一个 RequestQueue 对象，用来保存所有的网路请求 request，其获取方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mQueue = Volley.newRequestQueue(context);</span><br></pre></td></tr></table></figure><p>这里要注意的是：RequestQueue 内部的设计适合高并发，因此我们不必为每一次 HTTP 请求都创建一个 RequestQueue 对象，这是非常浪费资源的，基本上一个 RequestQueue 对象就足够了。所以我们将 RequestQueue 的获取放在自定义的 Application 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RequestQueue queues;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        queues = Volley.newRequestQueue(getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">getHttpQueues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）创建请求"><a href="#（二）创建请求" class="headerlink" title="（二）创建请求"></a>（二）创建请求</h2><p>Volley 自带的请求有：</p><ol><li>StringRequest</li><li>JsonRequest</li><li>ImageRequest</li></ol><p>一般我们请求的数据都是当做字符串来返回的，如果返回的结果使我们自定义的简单的结果，那么直接解析返回的字符串即可，但如果返回的结果是 Json 或者 Xml，那么就需要我们手动将返回的字符串转换为对应的 Json 或 Xml，好在 Volley 已经为我们实现了 Json，后面我们会学习如何自定义 Xml 的请求。</p><p>常见的请求又分为两种，一种是 GET 请求，一种是 POST 请求，这里以 StringRequest 为例，分别创建 GET 请求和 POST 请求：</p><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://op.juhe.cn/onebox/phone/query?tel=18220197835&amp;key=xxxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line"><span class="comment">//使用 get 方法;传入 URL;请求成功的监听回调;请求失败的监听回调;</span></span><br><span class="line">StringRequest request = <span class="keyword">new</span> StringRequest(Request.Method.GET, url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(s);</span></span><br><span class="line">        Log.e(<span class="string">"volley_GetByString"</span>, <span class="string">"onResponse: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">request.setTag(<span class="string">"abc"</span>);</span><br><span class="line">MyApp.getHttpQueues().add(request);</span><br></pre></td></tr></table></figure><p>创建 GET 请求，只需要在创建的 StringRequest 的构造方法的第一个参数中传入常量 Request.Method.GET 即可；第二个参数是所请求的 URL，第三个参数是请求成功的回调，这是一个接口，需要我们实现 onResponse 方法，该方法中传入的参数就是服务器给我们回调的结果；第四个参数是请求失败的回调，也是一个接口，需要我们实现 onErrorResponse，我们可以根据自己的业务需求，分别在请求成功或者失败的回调中处理不同的逻辑；</p><p>至此，一个请求就已经创建好了，如何发送请求呢？很简单，只需要将该请求添加到我们在上一步中创建的 RequestQueue 中即可。这里我们为 request 打上了一个标签，这个标签有什么用？在 Volley 与 Activity 生命周期的联动中会用到，别急。</p><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://op.juhe.cn/onebox/phone/query?"</span>;</span><br><span class="line">StringRequest request = <span class="keyword">new</span> StringRequest(Request.Method.POST, url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        PhoneMsg msg;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        msg = gson.fromJson(s, PhoneMsg.class);</span><br><span class="line">        Log.e(<span class="string">"###"</span>, <span class="string">"volley_PostByString: "</span> + msg.reason + <span class="string">"&lt;&gt;"</span> + msg.result.city + <span class="string">"&lt;&gt;"</span> + msg.error_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="comment">//StringRequest 的父类中的方法,这里我们是创建了一个匿名 StringRequest,重写了其 getParams 方法;</span></span><br><span class="line">    <span class="comment">//当使用 post 方法时,会自动回调该方法,得到一个 map,并将其中的 key-value 以 key1=value1&amp;key2=value2&amp; 的形式拼接起来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">getParams</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"tel"</span>, <span class="string">"18220197835"</span>);</span><br><span class="line">        hashMap.put(<span class="string">"key"</span>, <span class="string">"xxxxxxxxxxxxxxxxxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> hashMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.setTag(<span class="string">"abc"</span>);</span><br><span class="line">MyApp.getHttpQueues().add(request);</span><br></pre></td></tr></table></figure><p>POST 请求和 GET 请求类似，只不过在创建的 StringRequest 第一个参数改为常量 Request.Method.POST 即可，第二个参数 URL 和 get 不同了，因为我们这里是用 POST 方法发送请求，那么请求的 key-value 都不会出现在 url 中，而是重写了 StringRequest 的 getParams 方法，创建了一个 map，将请求的 key-value 保存到 map 中，然后将该 map 返回即可，在 post 请求发送时会自动回调 getParams 方法,并得到的 map 中的 key-value 以 key1=value1&amp;key2=value2&amp; 的形式拼接起来，添加到请求体中。第三个参数和第四个参数与 GET 请求相同。</p><h1 id="Volley-与-Activity-生命周期的联动"><a href="#Volley-与-Activity-生命周期的联动" class="headerlink" title="Volley 与 Activity 生命周期的联动"></a>Volley 与 Activity 生命周期的联动</h1><p>在创建了请求之后，将请求添加到 RequestQueue 中，</p><p>考虑这样一种场景，如果我们在当前的 Activity 中创建了大量的 request，但是这时突然用户有点击了 back 键或者跳转到了另一个 Activity，那么还未执行的 request 此时就没有必要去执行了，如何取消还未执行的请求呢？注意我们在每个 request 中都绑定了一个 tag，<code>request.setTag(&quot;abc&quot;);</code>，如果想取消这些 request，只需要在 Activity 的 onStop 回调中调用 cancelAll 方法，取消特定的 tag，那么之前发出的请求将不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    MyApp.getHttpQueues().cancelAll(<span class="string">"abc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义请求"><a href="#自定义请求" class="headerlink" title="自定义请求"></a>自定义请求</h1><p>前面也介绍了 Volley 的一个特点就是高扩展性，官方也为我们提供了 StringRequest，JsonRequest 等现成的 request，但是如果我们的业务用的是我们一种公司自定义的形式，那么我们就有必要自定义请求来解析返回的结果。</p><p>首先要明确的是：最原始的请求返回的结果都是字节流，我们正是通过对字节流的转换，才得到了我们想要的请求，这就是自定义 request 的本质。</p><p>JsonRequest 的数据解析是利用 Android 本身自带的 JSONObject 和 JSONArray 来实现的，配合使用 JSONObject 和 JSONArray 就可以解析出任意格式的 JSON 数据。但是使用 JSONObject 还是太麻烦了，还有很多方法可以让 JSON 数据解析变得更加简单，比如说 GSON。那么接下来我们自定义一个 GsonRequest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonRequest</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Response.Listener&lt;T&gt; mListener;</span><br><span class="line">    <span class="keyword">private</span> Gson mGson;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; mClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GsonRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Response.ErrorListener elistener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(method, url, elistener);</span><br><span class="line">        mGson = <span class="keyword">new</span> Gson();</span><br><span class="line">        mClass = clazz;</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GsonRequest</span><span class="params">(String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Response.ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Method.GET, url, clazz, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是响应最原始的面貌,得到的就是一个 NetWorkResponse,至于应用层想得到什么类型的响应,需要在这里进行转换;</span></span><br><span class="line"><span class="comment">    这个过程和 StringRequest 的构造很像,具体可以参考 StringRequest;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Response <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这一句是固定格式,先将 response 的 data 域拿出来,其是字节,要转换成字符串,同时要获取该字节的编码;</span></span><br><span class="line">            String jsonString = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">            <span class="keyword">return</span> Response.success(mGson.fromJson(jsonString, mClass), HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span> </span>&#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 request 需要继承 Request 类，而 Request 是一个抽象类，需要我们实现其抽象方法，包含两个：parseNetworkResponse 和 deliverResponse。</p><p>第一个要实现的方法 parseNetworkResponse，该方法是得到服务器响应时回调的结果，其参数是执行网络请求得到的响应 NetworkResponse，我们可以通过 NetworkResponse.data 拿到包含在响应中的字节数组，然后通过 HttpHeaderParser.parseCacheHeaders(response)获取响应中的编码格式，将该字节数组转换为对应的字符串。如果字符串解析成功，接下来我们就可以调用 Response 中的 success 方法，将结果传入进去，如果解码失败，那么调用 Response 的 error 方法。</p><p>第二个要实现的方法是 deliverResponse，这个方法也必须实现,该方法的参数是从上一步 parseNetworkResponse 中 Response.success()第一个参数得到的响应,我们要把这个响应分发下去;注意这一步说明我们已经得到成功的响应了,而之前 errorListener 的响应则是在网络出错或者服务器出错的情况下分发的 是由 Volley 顶层实现的。</p><p>我们看一下Volley自带的StringRequest是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRequest</span> <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Listener&lt;String&gt; mListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new request with the given method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method the request &#123;<span class="doctag">@link</span> Method&#125; to use</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL to fetch the string at</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener Listener to receive the String response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorListener Error listener, or null to ignore errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">            ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new GET request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL to fetch the string at</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener Listener to receive the String response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorListener Error listener, or null to ignore errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(String url, Listener&lt;String&gt; listener, ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Method.GET, url, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">        String parsed;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是相同的套路，同样是拿到了服务器的字节数组之后，直接转换为了字符串，然后就返回了，这个我们自定义的GsonRequest和StringRequest的套路是一致的。</p><p>至此，关于Volley的基本使用就讲完了，具体的使用请参考<a href="https://github.com/zachaxy/android-project-demo/blob/master/TestVolley/app/src/main/java/com/zx/testvolley/MainActivity.java" target="_blank" rel="noopener">这里</a>，下一篇，会进入Volley的源码，详细解剖其内部的基本实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(10)-解释器</title>
      <link href="/2017/05/15/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-10-%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>/2017/05/15/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-10-%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一节介绍了关于 JVM 指令集的相关知识，那么接下来我们就根据上一节介绍的知识，编写一个简易的解释器，读取字节码中的操作码和操作数，实现 JVM 规范中描述的指令集对应功能，从而完成简单方法的调用过程，并在接下来的章节中不断完善该解释器，使其支持更多指令。本节所实现的代码均在<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">项目</a>的 instructions 包下。</p></blockquote><h1 id="操作码的实现"><a href="#操作码的实现" class="headerlink" title="操作码的实现"></a>操作码的实现</h1><p>在 Code 属性中的字节数组就是字节码。操作码规定长度为一个字节，所以这里先读取一个字节，查看其对应的是哪种操作码，然后根据该操作码的实际含义，再决定是不是后面还有操作数需要读取。这一节实现了约 150 条指令，这些指令根据其分类，在 instructions 包下的子包中，具体实现见<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">项目源码</a>。</p><h1 id="指令抽象接口"><a href="#指令抽象接口" class="headerlink" title="指令抽象接口"></a>指令抽象接口</h1><p>有了前面的基础知识，接下来我们就要从字节码中读取指令，并执行指令，完成解释器的功能了。首先定义指令接口，然后定义一个结构体用来辅助指令解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从字节码中提取操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(BytecodeReader reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行指令逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Zframe frame)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是所有指令都要完成的两个动作，提取操作数（如果有的话），执行指令。</p><h1 id="指令抽象类"><a href="#指令抽象类" class="headerlink" title="指令抽象类"></a>指令抽象类</h1><p>有很多指令的操作数都是类似的。为了避免重复代码，按照操作码类型定义一些抽象类，这些抽象类实现了 Instruction 接口，并实现 FetchOperands（）方法。再由具体的类去继承这些抽象类，然后<br>专注实现 Execute（）方法即可。定义的抽象类有以下几种。</p><h2 id="NoOperandsInstruction"><a href="#NoOperandsInstruction" class="headerlink" title="NoOperandsInstruction"></a>NoOperandsInstruction</h2><p>NoOperandsInstruction 表示没有操作数的指令，所以没有定义任何字段。FetchOperands（）方法自然也是空空如也，什么也不用读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NoOperandsInstruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(BytecodeReader reader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BranchInstruction"><a href="#BranchInstruction" class="headerlink" title="BranchInstruction"></a>BranchInstruction</h2><p>BranchInstruction 表示跳转指令，Offset 字段存放跳转偏移量。FetchOperands（）方法从字节码中读取一个 uint16 整数，转成 int 后赋给 Offset 字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BranchInstruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(BytecodeReader reader)</span> </span>&#123;</span><br><span class="line">        offset = reader.readInt16();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index8Instruction"><a href="#Index8Instruction" class="headerlink" title="Index8Instruction"></a>Index8Instruction</h2><p>存储和加载类指令需要根据索引存取局部变量表，索引由单字节操作数给出。把这类指令抽象成 Index8Instruction 结构体，用 Index 字段表示局部变量表索引。FetchOperands（）方法从字节码中读取一个 int8 整数，转成 uint 后赋给 Index 字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Index8Instruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Index8Instruction</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(BytecodeReader reader)</span> </span>&#123;</span><br><span class="line">        index = reader.readUint8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index16Instruction"><a href="#Index16Instruction" class="headerlink" title="Index16Instruction"></a>Index16Instruction</h2><p>有一些指令需要访问运行时常量池，常量池索引由两字节操作数给出。把这类指令抽象成 Index16Instruction 结构体，用 Index 字段表示常量池索引。FetchOperands（）方法从字节码中读取一个 uint16 整数，转成 uint 后赋给 Index 字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Index16Instruction</span> <span class="keyword">implements</span> <span class="title">Instruction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchOperands</span><span class="params">(BytecodeReader reader)</span> </span>&#123;</span><br><span class="line">        index = reader.readUint16();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读取字节码辅助类"><a href="#读取字节码辅助类" class="headerlink" title="读取字节码辅助类"></a>读取字节码辅助类</h1><p>code 字段存放字节码，pc 字段记录读取到了哪个字节。所有的指令都要从字节码中读取数据，并根据不同的指令类型读取 int、long、float、double 等类型的数据，所以定义一个读取字节码的辅助类 BytecodeReader，让其实现一系列的 readXXX（）方法。至于具体调用哪个 read 方法，则根据操作码中对应的操作类型来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BytecodeReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] code;  <span class="comment">//Java 语言中 byte 的范围四 -128~127,和 Go 语言中的 byte:0~255 不同,所以在取数据的时候需要注意;</span></span><br><span class="line">    <span class="keyword">int</span> pc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">byte</span>[] code, <span class="keyword">int</span> pc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.pc = pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readInt8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> res = code[pc];</span><br><span class="line">        pc++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readUint8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = code[pc];</span><br><span class="line">        res = (res + <span class="number">256</span>) % <span class="number">256</span>;</span><br><span class="line">        pc++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) readUint16();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">readUint16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = readUint8();</span><br><span class="line">        <span class="keyword">int</span> a2 = readUint8();</span><br><span class="line">        <span class="keyword">return</span> (a1 &lt;&lt; <span class="number">8</span> | a2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        data[<span class="number">0</span>] = readInt8();</span><br><span class="line">        data[<span class="number">1</span>] = readInt8();</span><br><span class="line">        data[<span class="number">2</span>] = readInt8();</span><br><span class="line">        data[<span class="number">3</span>] = readInt8();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ByteUtils.byteToInt32(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] readInt32s(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[i] = readInt32();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4k 对齐,没有对齐的会有填充数据,这些数据要忽略掉;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipPadding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pc % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            readInt8();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指令创建工厂"><a href="#指令创建工厂" class="headerlink" title="指令创建工厂"></a>指令创建工厂</h1><p>有了前面的各个指令的具体实现，接下来统一对外提供一个创建指令的接口，根据不同的操作码创建具体的指令，整体结构就是一个 switch-case 语句，其枚举了这一节已经实现的 150 多种指令，代码太长就不列举了，具体实现在 instructions 包下的 InstructionFactory 类中。</p><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>Java 虚拟机解释器的大致逻辑，其伪码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    atomically calculate pc and fetch opcode at pc;</span><br><span class="line">    <span class="keyword">if</span> (operands) fetch operands;</span><br><span class="line">    execute the action <span class="keyword">for</span> the opcode;</span><br><span class="line">&#125; <span class="keyword">while</span> (there is more to <span class="keyword">do</span>);</span><br></pre></td></tr></table></figure><p>解释一下上面的过程：</p><ol><li>计算 pc 值（默认 pc++，取下一条指令，否则就是跳转指令，对应 pc + offset ）；</li><li>根据 pc 寄存器的指示位置，从字节码中读取出操作码；</li><li>如果该操作码存在操作数，那么继续从字节码中读取操作数；</li><li>执行操作码所定义的操作；</li><li>如果字节码还未读取完，继续步骤 1；</li></ol><p>我们根据前面已经实现的编码，创建 Interpreter 类，实现指令的执行过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">(Zthread thread, <span class="keyword">byte</span>[] byteCode)</span> </span>&#123;</span><br><span class="line">    Zframe frame = thread.popFrame();   <span class="comment">//得到栈顶的帧。</span></span><br><span class="line">    BytecodeReader reader = <span class="keyword">new</span> BytecodeReader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里循环的条件是 true,因为在解析指令的时候会遇到 return,而现在还没有实现 return,所以遇到 return 直接抛出异常,那么循环也就终止了</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pc = frame.getNextPC(); <span class="comment">//这第一次 frame 才刚初始化，获取的 pc 应该是默认值 0 吧。</span></span><br><span class="line">        thread.setPc(pc);</span><br><span class="line">        reader.reset(byteCode, pc); <span class="comment">//reset 方法，其实是在不断的设置 pc 的位置。</span></span><br><span class="line">        <span class="keyword">int</span> opCode = reader.readUint8();</span><br><span class="line">        <span class="comment">//解析指令,创建指令,然后根据不同的指令执行不同的操作</span></span><br><span class="line">        Instruction instruction = InstructionFactory.createInstruction(opCode);</span><br><span class="line">        instruction.fetchOperands(reader);</span><br><span class="line">        frame.setNextPC(reader.getPc());</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"pc: %2d, inst: %s \n"</span>, pc, instruction.getClass().getSimpleName());</span><br><span class="line">        instruction.execute(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 Interpreter#loop（）方法中，while 循环部分的代码就是 Java 虚拟机规范中 JVM 解释器的具体实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setContentView内部原理</title>
      <link href="/2017/05/13/setContentView%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2017/05/13/setContentView%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们平时在写Android界面的时候，一般都是创建一个Activity（eg：MainActivity.java），并创建一个对应的布局文件（eg：activity_main.xml），然后在Activity的onCreate方法中，调用setContentView(R.layout.activity_main)，这样布局文件中所展示的界面就能显示出来了。相信刚开始学习Android时，这一步骤是让我们的界面显示出来的必经套路，那么其内部究竟执行了什么，才能实现这一效果？今天就一起来了解一下setContentView方法的内部实现原理。</p></blockquote><h1 id="早期的setContentView方法"><a href="#早期的setContentView方法" class="headerlink" title="早期的setContentView方法"></a>早期的setContentView方法</h1><p>之前我们在编写Android程序的时候，创建的XXXActivity默认都是继承Activity这个类的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        getWindow().requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入setContentView方法中一探究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其实Activity中的setContentView方法自己并没有执行上面逻辑，而是调用了与Activity关联的Window的setContentView，</p><h1 id="现在的setContentView方法"><a href="#现在的setContentView方法" class="headerlink" title="现在的setContentView方法"></a>现在的setContentView方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppcompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        getWindow().requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android UI 专题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(9)-指令集</title>
      <link href="/2017/05/13/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-9-%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
      <url>/2017/05/13/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-9-%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>编译之后的 Java 方法以字节码的形式存储在 class 文件中。前面已经初步实现了 Java 虚拟机栈、帧、操作数栈和局部变量表等运行时数据区。那么 JVM 是如何操作局部变量表和操作数栈中的数据呢？这就涉及到了 JVM 的字节码指令集。这一节对 JVM 的字节码指令集做一个介绍，本节所实现的指令位于<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">项目</a>的 instructions 包下。</p></blockquote><h1 id="字节码简介"><a href="#字节码简介" class="headerlink" title="字节码简介"></a>字节码简介</h1><p>字节码是运行在虚拟机上的机器码,每一个类或者接口都会被 Java 编译器编译成一个 class 文件，类或接口的方法信息就放在 class 文件的 method_info 结构中。如果方法不是抽象的，也不是本地方法，方法的 Java 代码就会被编译器编译成字节码（即使方法是空的，编译器也会生成一条 return 语句），存放在 method_info 结构的<strong>Code 属性</strong>中。 ==&gt; 字节码一般来说是针对方法中的步骤的；</p><h1 id="指令简介"><a href="#指令简介" class="headerlink" title="指令简介"></a>指令简介</h1><p>字节码中存放编码后的 Java 虚拟机指令。</p><p><strong>指令 = 操作码 + 操作数（如果有的话）</strong></p><ul><li>操作码（Opcode）：一个字节长度，代表着某种特定操作含义。</li><li>操作数（Operands）：操作码后面需要跟零到多个代表该操作码所需的参数。</li></ul><p>所以 Java 虚拟机使用的是<strong>变长指令</strong></p><p>如果把指令想象成函数的话，操作数就是它的参数。每条指令都以一个单字节的操作码（opcode）开头。由于只使用一字节表示操作码，显而易见，Java 虚拟机最多只能支持 256（2^8 ）条指令。</p><p>Java 虚拟机规范已经定义了 205 条指令，操作码分别是 0（0x00）到 202（0xCA）、254（0xFE）和 255（0xFF）。这 205 条指令构成了 Java 虚拟机的指令集（instruction set）。</p><p>字节码指令是一种具有鲜明特点，优劣势都很突出的指令集架构。</p><p>缺点：由于 Class 文件格式放弃了将编译后操作数长度对齐，那么如果处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据，eg：将一个 16 位无符号整数用两字节（byte1，byte2）存储起来，那么在读取该 16 位整数时，需要这样转换：<code>( byte1 &lt;&lt; 8 ) | byte2</code>，这导致解释执行操作码时损失了一些性能。</p><p>优点：放弃了操作数长度对其，意味着可以省略很多填充和间隔符号，尽可能获取短小精干的编译代码（小数据量，高效传输）</p><h1 id="操作码的数据类型"><a href="#操作码的数据类型" class="headerlink" title="操作码的数据类型"></a>操作码的数据类型</h1><p>为了让编码后的字节码更加紧凑，很多操作码本身就隐含了操作数，比如把常数 0 推入操作数栈的指令是 iconst_0。</p><p><strong>操作数栈</strong>和<strong>局部变量表</strong>只存放数据的值，并不记录数据类型。结果就是：<strong>指令必须知道自己在操作什么类型的数据。</strong>这一点也直接反映在了操作码的助记符上。</p><p>例如：</p><p>iadd 指令就是对 int 值进行加法操作；</p><p>dstore 指令把操作数栈顶的 double 值弹出，存储到局部变量表中；</p><p>areturn 从方法中返回引用值。</p><p>也就是说，如果某类指令可以操作不同类型的变量，则助记符的<strong>第一个字母表示变量类型</strong>。</p><table><thead><tr><th>助记符首字母</th><th>数据类型</th><th>例子</th></tr></thead><tbody><tr><td>a</td><td>reference</td><td>aload、astore、areturn</td></tr><tr><td>b</td><td>byte/boolean</td><td>bipush、baload</td></tr><tr><td>c</td><td>char</td><td>caload、castore</td></tr><tr><td>d</td><td>double</td><td>dload、dstore、dadd</td></tr><tr><td>f</td><td>float</td><td>fload、fstore、fadd</td></tr><tr><td>i</td><td>int</td><td>iload、istore、iadd</td></tr><tr><td>l</td><td>long</td><td>lload、lstore、ladd</td></tr><tr><td>s</td><td>short</td><td>sipush、sastore</td></tr></tbody></table><p>并非每个基本数据类型都有对应的操作码，从上图可以看到大部指令都没有直接支持 byte、char、short、boolean，编译器会在编译器或者运行期将 byte 和 short 类型的数据<strong>带符号扩展</strong>为相应的 int 类型，将 boolean 和 char 类型数据<strong>零位扩展</strong>为相应的 int 类型。因此，大多数对于 byte、char、short、boolean 的操作，实际上都是使用相应的 int 类型作为运算类型。</p><h1 id="指令的分类"><a href="#指令的分类" class="headerlink" title="指令的分类"></a>指令的分类</h1><p>因为使用一字节表示操作码，所以 Java 虚拟机最多只能支持 256（2^8 ）条指令。</p><p>Java 虚拟机规范已经定义了 205 条指令，操作码分别是 0（0x00）到 202（0xCA）、254（0xFE）和 255（0xFF）。这 205 条指令构成了 Java 虚拟机的指令集（instruction set）。</p><p>Java 虚拟机规范把已经定义的 205 条指令按用途分成了 11 类：</p><ol><li>常量（constants）指令</li><li>加载（loads）指令</li><li>存储（stores）指令</li><li>操作数栈（stack）指令</li><li>数学（math）指令</li><li>转换（conversions）指令</li><li>比较（comparisons）指令</li><li>控制（control）指令</li><li>引用（references）指令</li><li>扩展（extended）指令</li><li>保留（reserved）指令</li></ol><p>注:保留指令共有 3 条。其中一条是留给调试器的，用于实现断点，操作码是<code>202（0xCA）</code>，助记符是<code>breakpoint</code>。另外两条留给<code>Java</code>虚拟机实现内使用，操作码分别是<code>254（0xFE）</code>和<code>266（0xFF）</code>，助记符是<code>impdep1</code>和<code>impdep2</code>。这三条指令不允许出现在 class 文件中。</p><p>接下来这上述的 11 类指令做一个简单的介绍，并在每种类别的指令中跳出几个有代表性的进行简要说明。</p><h1 id="常量指令"><a href="#常量指令" class="headerlink" title="常量指令"></a>常量指令</h1><p>常量指令把常量<strong>推入操作数栈顶</strong>。常量可以来自三个地方：隐含在操作码里、操作数和运行时常量池。</p><h2 id="nop-指令"><a href="#nop-指令" class="headerlink" title="nop 指令"></a>nop 指令</h2><p>nop 指令是最简单的一条指令，因为它什么也不做。</p><h2 id="const-系列指令"><a href="#const-系列指令" class="headerlink" title="const 系列指令"></a>const 系列指令</h2><p>这一系列指令把隐含在操作码中的常量值<strong>推入操作数栈顶</strong>。几个具体的例子如下：</p><ul><li><p>aconst_null 指令把 null 引用推入操作数栈顶</p></li><li><p>dconst_0 指令把 double 型 0 推入操作数栈顶</p></li><li><p>iconst_m1 指令把 int 型 -1 推入操作数栈顶</p><p>​</p></li></ul><h2 id="bipush-和-sipush-指令"><a href="#bipush-和-sipush-指令" class="headerlink" title="bipush 和 sipush 指令"></a>bipush 和 sipush 指令</h2><p>bipush 指令从<strong>操作数</strong>中获取一个 byte 型整数，扩展成 int 型，然后<strong>推入栈顶</strong>。</p><p>sipush 指令从<strong>操作数</strong>中获取一个 short 型整数，扩展成 int 型，然后<strong>推入栈顶</strong>。</p><h1 id="加载指令"><a href="#加载指令" class="headerlink" title="加载指令"></a>加载指令</h1><p>加载指令从局部变量表获取变量，然后推入操作数栈顶。加载指令共 33 条，按照所操作变量的类型可以分为 6 类:</p><ol><li>aload 系列指令操作引用类型变量</li><li>dload 系列操作 double 类型变量</li><li>fload 系列操作 float 变量</li><li>iload 系列操作 int 变量</li><li>lload 系列操作 long 变量</li><li>xaload 操作数组</li></ol><h1 id="存储指令"><a href="#存储指令" class="headerlink" title="存储指令"></a>存储指令</h1><p>和加载指令刚好相反，存储指令把变量从操作数栈顶弹出，然后存入局部变量表。</p><h1 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h1><p>直接对<strong>操作数栈</strong>进行操作，栈指令并不关心变量类型（但是可以确定不是 long 和 double，因为这两种类型占用两个 Slot，所以这里虽然不管类型，但是可以确定是占用了一个 Slot）。共 9 条：</p><ul><li>pop 和 pop2 指令将栈顶变量弹出</li><li>dup 系列指令复制栈顶变量</li><li>swap 指令交换栈顶的两个变量</li></ul><h1 id="数学指令"><a href="#数学指令" class="headerlink" title="数学指令"></a>数学指令</h1><p>数学指令大致对应 Java 语言中的加、减、乘、除等数学运算符。</p><p>数学指令共 37 条，包括：</p><ul><li>算术指令</li><li>位移指令</li><li>布尔运算指令</li><li>自增指令(eg:i++)</li></ul><h2 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h2><ol><li>加法（add）指令</li><li>减法（sub）指令</li><li>乘法（mul）指令</li><li>除法（div）指令</li><li>求余（rem）指令</li><li>取反（neg）指令</li></ol><h2 id="位移指令"><a href="#位移指令" class="headerlink" title="位移指令"></a>位移指令</h2><ol><li><p>左移</p></li><li><p>右移</p><ol><li>算术右移（有符号右移）</li><li>逻辑右移（无符号右移）</li></ol><p>​</p></li></ol><h2 id="布尔运算指令"><a href="#布尔运算指令" class="headerlink" title="布尔运算指令"></a>布尔运算指令</h2><p>布尔运算指令只能操作 int 和 long 变量：</p><ol><li>按位与（and）</li><li>按位或（or）</li><li>按位异或（xor）</li></ol><h2 id="iinc-指令"><a href="#iinc-指令" class="headerlink" title="iinc 指令"></a>iinc 指令</h2><p>iinc 指令给局部变量表中的 int 变量增加常量值，局部变量表索引和常量值都由指令的操作数提供。</p><h1 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h1><p>类型转换指令可以分为 4 种：</p><ul><li>i2x 系列指令把 int 变量强制转换成其他类型</li><li>l2x 系列指令把 long 变量强制转换成其他类型</li><li>f2x 系列指令把 float 变量强制转换成其他型</li><li>d2x 系列指令把 double 变量强制转换成其他类型</li></ul><p>注意:引用类型转换对应的是 checkcast 指令,在后面的章节会出现。</p><h1 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h1><p>比较指令可以分为两类：</p><ul><li>将比较结果推入操作数栈顶。</li><li>根据比较结果跳转。</li></ul><h2 id="lcmp-指令"><a href="#lcmp-指令" class="headerlink" title="lcmp 指令"></a>lcmp 指令</h2><p>用于比较 long 变量,把栈顶的两个 long 变量弹出，进行比较，然后把比较结果（int 型 0、1 或 -1）推入栈顶。</p><h2 id="fcmp-指令"><a href="#fcmp-指令" class="headerlink" title="fcmp 指令"></a>fcmp 指令</h2><p>指令和 lcmp 指令很像，但是除了比较的变量类型不同以外，还有一个重要的区别:由于浮点数计算有可能产生 NaN（Not a Number）值，所以比较两个浮点数时，除了大于、等于、小于之外， 还有第 4 种结果：<strong>无法比较</strong></p><p>fcmpg 和 fcmpl 指令的区别就在于对第 4 种结果的定义;<br>当两个 float 变量中至少有一个是 NaN 时，用 fcmpg 指令比较的结果是 1，而用 fcmpl 指令比较的结果是 -1。</p><h2 id="dcmp-指令"><a href="#dcmp-指令" class="headerlink" title="dcmp 指令"></a>dcmp 指令</h2><p>dcmpg 和 dcmpl 指令用来比较 double 变量,这条指令和 fcmp 指令只是比较的变量类型不同。</p><h2 id="if-lt-cond-gt-指令"><a href="#if-lt-cond-gt-指令" class="headerlink" title="if&lt;cond&gt;指令"></a><code>if&lt;cond&gt;</code>指令</h2><p><code>if&lt;cond&gt;</code>指令把操作数栈顶的 int 变量弹出，然后跟 0 进行比较，满足条件则跳转。假设从栈顶弹出的变量是 x，则指令执行跳转操作的条件如下：具体判定之后如何跳转,现在先不讨论;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifeq：x==0</span><br><span class="line">ifne：x！=0</span><br><span class="line">iflt：x&lt;0</span><br><span class="line">ifle：x&lt;=0</span><br><span class="line">ifgt：x&gt;0</span><br><span class="line">ifge：x&gt;=0</span><br></pre></td></tr></table></figure><h2 id="if-icmp-lt-cond-gt-指令"><a href="#if-icmp-lt-cond-gt-指令" class="headerlink" title="if_icmp&lt;cond&gt;指令"></a><code>if_icmp&lt;cond&gt;指令</code></h2><p><code>if_icmp&lt;cond&gt;</code>指令把栈顶的两个 int 变量弹出，然后进行比较，满足条件则跳转。跳转条件和 if<cond>指令类似。</cond></p><h2 id="if-acmp-lt-cond-gt-指令"><a href="#if-acmp-lt-cond-gt-指令" class="headerlink" title="if_acmp&lt;cond&gt;指令"></a><code>if_acmp&lt;cond&gt;指令</code></h2><p>把栈顶的两个引用弹出，根据引用是否相同进行跳转。</p><h1 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h1><p>分类:</p><ul><li>goto</li></ul><ul><li>tableswitch</li></ul><ul><li>lookupswitch</li></ul><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>goto 指令进行无条件跳转,其操作码后是一个 int16 类型的操作数，所以需要读两个字节并转成成 int16 类型，该操作数即偏移 offset，那么接下来要执行的指令的位置为：<code>pc + offset</code></p><h2 id="tableswitch"><a href="#tableswitch" class="headerlink" title="tableswitch"></a>tableswitch</h2><p>Java 语言中的 switch-case 语句有两种实现方式：如果 case 值可以编码成一个索引表(索引值是连续的)，则实现成 tableswitch 指令；否则实现成 lookupswitch 指令</p><p>下面这个 Java 方法中的 switch-case 可以编译成 tableswitch 指令，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chooseNear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tableswitch 后跟的操作数是对应 case 分支的跳转 offset，其格式类似于：</p><p>default 分支对应的跳转 defaultOffset，0 分支对应的索引 low(这里就是 0)，2 分支对应的索引 high(这里就是 2)，因为 0<del>2 分支对应的跳转是连续的，所以接下来分别对应 0</del>2 分支的跳转 offset。</p><p>这里用一个数组存放最合适不过了，数组大小就是<code>high-low+1</code>，这里拿到一个分支跳转的 case 的索引 index，先判断 index 在不在 low 和 high 之间，如果不在，其 offset 就是 defaultOffset，否则就用从数组中找 <code>arr[index-low]</code>，拿到对应的 offset。</p><h2 id="lookupswitch"><a href="#lookupswitch" class="headerlink" title="lookupswitch"></a>lookupswitch</h2><p>(索引值是非连续的)下面这个 Java 方法中的 switch-case 则需要编译成 lookupswitch 指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chooseFar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> -<span class="number">100</span>: <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">100</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的 case 语句并不是连续的，所以不能用数组来表示了，只能是一个 case 的索引，接下来该 case 对应的跳转。</p><h1 id="扩展指令"><a href="#扩展指令" class="headerlink" title="扩展指令"></a>扩展指令</h1><h2 id="wide-指令"><a href="#wide-指令" class="headerlink" title="wide 指令"></a>wide 指令</h2><p>加载类指令、存储类指令、ret 指令和 iinc 指令需要按索引访问局部变量表，索引以 uint8 的形式存在字节码中。对于大部分方法来说，<strong>局部变量表大小一般都不会超过 256</strong>，所以用一字节来表示索引就够了。</p><p>但是如果有方法的局部变量表超过这限制时,Java 虚拟机规范定义了 wide 指令来扩展前述指令。</p><p>wide 指令改变其他指令的行为，modifiedInstruction 字段存放被改变的指令。</p><h2 id="ifnull-ifnonnull-指令"><a href="#ifnull-ifnonnull-指令" class="headerlink" title="ifnull/ifnonnull 指令"></a>ifnull/ifnonnull 指令</h2><p>根据引用是否是 null 进行跳转，ifnull 和 ifnonnull 指令把栈顶的引用弹出。</p><h2 id="goto-w-指令"><a href="#goto-w-指令" class="headerlink" title="goto_w 指令"></a>goto_w 指令</h2><p>goto_w 指令和 goto 指令的唯一区别就是索引从 2 字节变成了 4 字节。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(8)-运行时数据</title>
      <link href="/2017/05/12/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-8-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE/"/>
      <url>/2017/05/12/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-8-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面介绍了如何搜索和解析 class 文件，如何解析 class 文件，那么接下来就要开始实现 JVM 了，这一节我们讨论并初步实现运行时数据区（run-time data area），为接下来编写字节码解释器做准备。本节所有的<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">代码</a>均位于 runtimedata 包下。</p></blockquote><h1 id="运行时数据区概述"><a href="#运行时数据区概述" class="headerlink" title="运行时数据区概述"></a>运行时数据区概述</h1><p>运行时数据区可以分为两类：</p><ul><li>多线程共享:在 Java 虚拟机启动时创建好，在 Java 虚拟机退出时销毁。<ul><li>类数据，其存放在方法区(逻辑上来说,方法区也是堆中的一部分)<ul><li>字段</li><li>方法信息</li><li>方法字节码</li><li>运行时常量池</li></ul></li><li>类实例(对象)=&gt;堆(堆由垃圾收集器定期清理，所以程序员不需要关心对象空间的释放)</li></ul></li><li>线程私有:创建线程时才创建，线程退出时销毁。其主要作用是辅助执行 Java 字节码<ul><li>pc 寄存器：存放当前正在执行的 Java 虚拟机指令的地址，如果当前执行的是 native 方法，则 pc 的值 JVM 没有明确定义。</li><li>Java 虚拟机栈<ul><li>栈帧<ul><li>局部变量表</li><li>操作数</li></ul></li></ul></li></ul></li></ul><p> 在任一时刻，某一线程肯定是在执行某个方法。这个方法叫作该线程的<strong>当前方法</strong>；</p><p>执行该方法的帧叫作线程的<strong>当前帧</strong>；</p><p>声明该方法的类叫作<strong>当前类</strong>。</p><p>如果当前方法是<strong>Java 方法</strong>，则 pc 寄存器中存放当前正在执行的 Java 虚拟机指令的地址，否则，当前方法是本地方法，pc 寄存器中的值没有明确定义。</p><p><img src="https://geosmart.github.io/2016/03/07/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="运行时数据区示意图"></p><p>堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展。</p><p>Java 命令提供了-Xms 和-Xmx 两个非标准选项，用来调整堆的初始大小和最大大小。如果没有进行指定,那么使用默认大小;</p><p>虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Java 虚拟机可以操作两类数据：</p><ul><li>基本类型:变量中存放数据本身。</li><li>引用类型:变量中存放的是对象引用，真正的对象数据是在堆里分配的。</li></ul><p>这里所说的变量包括 类变量（静态字段）、实例变量（非静态字段）、数组元素、方法的参数和局部变量等</p><p>引用类型可以进一步分为 3 种：</p><ul><li>类类型:指向类实例</li><li>接口类型:指向实现了该接口的类或数组实例</li><li>数组类型类:指向数组实例 </li></ul><p>引用类型有一个特殊的值——null，表示该引用不指向任何对象。</p><p><strong>操作数栈和局部变量表只存放数据的值,并不记录数据类型。具体操作的是什么类型的数据,反映在操作符上,eg:iadd:就是对 int 值进行加法操作.</strong></p><p>关于字节码和指令集的具体讲解在<a href="https://zachaxy.github.io/2017/05/13/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-9-%E6%8C%87%E4%BB%A4%E9%9B%86/">手写JVM系列(9)-指令集</a>中介绍。</p><p>基于 Java 虚拟机只能操作上面两种数据，并且在<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/#Code">属性表</a>的 Code 属性一节中介绍过，局部变量是存放在 Slot 中的，所以这里定义一个 Slot 类，里面存放上面所述的两种变量：基本类型和引用类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> Zobject ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Slot</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基本类型，使用定义的 num 变量，对于引用类型，使用 Zobject 变量，因为现在还没有涉及到实现类和对象的实现，所以这里自己定义了一个类 Zobject 来代表引用。等到后面章节中，会具体讲解实现类和对象的实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zobject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 暂时为空实现  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现线程私有的运行时数据区"><a href="#实现线程私有的运行时数据区" class="headerlink" title="实现线程私有的运行时数据区"></a>实现线程私有的运行时数据区</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>既然是要实现线程私有的运行时数据区，那么就要先实现线程类，这里定义 Zthread 类代表线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zthread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pc;</span><br><span class="line">    Zstack stack; <span class="comment">//Stack 结构体（Java 虚拟机栈）的引用;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认栈的大小是 1024,也就是说可以存放 1024 个栈帧</span></span><br><span class="line">        stack = <span class="keyword">new</span> Zstack(<span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPc</span><span class="params">(<span class="keyword">int</span> pc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pc = pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushFrame</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        stack.push(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Zframe <span class="title">popFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Zframe <span class="title">getCurrentFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Zframe <span class="title">createFrame</span><span class="params">(<span class="keyword">int</span> maxLocals, <span class="keyword">int</span> maxStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Zframe(<span class="keyword">this</span>, maxLocals, maxStack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只关注其中的成员变量。我们知道线程中私有的数据包括：PC 和虚拟机栈。PC 使用一个整数保存，虚拟机栈使用了我们自定义的一个 Zstack 类，下面是其具体实现。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>Java 虚拟机规范对 Java 虚拟机栈的约束非常宽松。虚拟机栈可以是连续的空间，也可以不连续可以是固定大小，也可以在运行时动态扩展。Java 提供了-Xss 选项来设置 Java 虚拟机栈大小。</p><p>如果 Java 虚拟机栈有大小限制，且执行线程所需的栈空间超出了这个限制，会导致 StackOverflowError 异常抛出。</p><p>如果 Java 虚拟机栈可以动态扩展，但是内存已经耗尽，会导致 OutOfMemoryError 异常抛出。</p><p>这里我们用经典的链表（linked list）数据结构来实现 Java 虚拟机栈，这样栈就可以按需使用内存空间，而且弹出的帧也可被及时回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zstack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSize;    <span class="comment">//虚拟机栈中所包含栈帧的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> size;       <span class="comment">//当前虚拟机栈中包含帧的数量</span></span><br><span class="line">    <span class="keyword">private</span> Zframe _top; <span class="comment">//栈顶的帧</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zstack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新添加一个栈帧,将这个栈帧设置为 top,当然如果当前栈之前有元素,那么将要 push 进的 frame 的 lower 是指为之前的 top,当前 frame 变为 top;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Zframe frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; maxSize) &#123;</span><br><span class="line">            <span class="comment">//throw new RuntimeException("java.lang.StackOverflowError");</span></span><br><span class="line">            <span class="comment">//如果栈已经满了，按照 Java 虚拟机规范，应该抛出 StackOverflowError 异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StackOverflowError();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_top != <span class="keyword">null</span>) &#123;</span><br><span class="line">            frame.lower = _top; <span class="comment">// frame 中保存前一个帧的引用,使得当前帧被 push 的时,前一个帧顶上去;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _top = frame;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Zframe <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_top == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        Zframe tmp = _top;</span><br><span class="line">        _top = tmp.lower;</span><br><span class="line">        tmp.lower = <span class="keyword">null</span>;  <span class="comment">//tmp 是带 pop 出的栈帧,既然要 pop 出来,那么将其 lower 设置为 null,不在持有栈中的帧,避免内存泄露;</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Zframe <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_top == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：maxSize 字段保存栈的容量（最多可以容纳多少帧），size 字段保存栈的当前大小，_top 字段保存栈顶指针。</p><p>push（）方法把帧推入栈顶，如果栈已经满了，按照 Java 虚拟机规范，应该抛出 StackOverflowError 异常。</p><p>pop（）方法把栈顶帧弹出，如果此时栈是空的，肯定是我们的虚拟机有 bug，这里我们手动抛出了一个 EmptyStackException 异常。</p><p>top（）方法只是返回栈顶帧，但并不弹出。</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>上面的虚拟机栈是用单向链表实现的，栈中每一个元素都是栈帧，这里我们定义一个 Zframe 类，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zframe</span> </span>&#123;</span><br><span class="line">    Zframe lower;       <span class="comment">//当前帧的 前一帧的引用;相当于单向链表的前一个指针</span></span><br><span class="line">    LocalVars localVars;    <span class="comment">//局部变量表的引用;</span></span><br><span class="line">    OperandStack operandStack;  <span class="comment">//操作数栈的引用;</span></span><br><span class="line">    Zthread thread;</span><br><span class="line">    <span class="keyword">int</span> nextPC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 2017/5/4 0004</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zframe</span><span class="params">(Zthread thread, <span class="keyword">int</span> maxLocals, <span class="keyword">int</span> maxStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        localVars = <span class="keyword">new</span> LocalVars(maxLocals);</span><br><span class="line">        operandStack = <span class="keyword">new</span> OperandStack(maxStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalVars <span class="title">getLocalVars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localVars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OperandStack <span class="title">getOperandStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operandStack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Zthread <span class="title">getThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextPC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextPC</span><span class="params">(<span class="keyword">int</span> nextPC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextPC = nextPC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lower 字段用来实现链表数据结构，保存的是栈中前一个栈帧的引用，相当于链表中的 next 指针，这样当栈顶的帧出栈时，栈顶帧把其持有的 lower 帧设置为当前栈顶帧。</p><p>localVars 字段保存局部变量表引用。</p><p>operandStack 字段保存操作数栈引用。</p><p>在构造方法中传入了局部变量表大小和操作数栈深度，这两个值是由编译器预先计算好的，存储在 class 文件 method_info 结构的 Code 属性中。</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表是按索引访问的，那么我们自然也是用数组来实现。根据 Java 虚拟机规范，这个数组的每个元素至少可以容纳一个 int 或引用值，两个连续的元素可以容纳一个 long 或 double 值。这就是我们之前讲的属性表中 Code 属性中的<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/#Code">Slot</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> Zobject ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Slot</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作局部变量表和操作数栈的指令都是隐含类型信息的。下面给 LocalVars 类型定义一些方法，用来存取不同类型的变量。</p><ul><li>int 变量最简单，直接存取即可。</li><li>float 变量可以先转成 int 类型，然后按 int 变量来处理。</li><li>long 变量则需要拆成两个 int 变量（需要注意的点是将两个 int 合并成一个 long 的方式，具体处理方式见下面的源码 getLong）。</li><li>double 变量可以先转成 long 类型，然后按照 long 变量来处理。</li><li>引用值，也比较简单，直接存取即可。</li></ul><p>下面给出 LocalVars 中存取变量或引用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Slot[] localVars; <span class="comment">//局部变量表,JVM 规定其按照索引访问,所以将其设置为数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalVars</span><span class="params">(<span class="keyword">int</span> maxLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxLocals &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            localVars = <span class="keyword">new</span> Slot[maxLocals];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"maxLocals&lt;0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供了对 int,float,long,double,引用的存取,这里要注意的是 long 和 double 是占用 8 字节的,所以使用了局部变量表中的两个槽位分别存储前四字节和后四字节</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Slot slot = <span class="keyword">new</span> Slot();</span><br><span class="line">        slot.num = val;</span><br><span class="line">        localVars[index] = slot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localVars[index].num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">float</span> val)</span> </span>&#123;</span><br><span class="line">        Slot slot = <span class="keyword">new</span> Slot();</span><br><span class="line">        slot.num = Float.floatToIntBits(val);</span><br><span class="line">        localVars[index] = slot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Float.intBitsToFloat(localVars[index].num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLong</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先存低 32 位</span></span><br><span class="line">        Slot slot1 = <span class="keyword">new</span> Slot();</span><br><span class="line">        slot1.num = (<span class="keyword">int</span>) (val);</span><br><span class="line">        localVars[index] = slot1;</span><br><span class="line">        <span class="comment">//再存高 32 位</span></span><br><span class="line">        Slot slot2 = <span class="keyword">new</span> Slot();</span><br><span class="line">        slot2.num = (<span class="keyword">int</span>) (val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">        localVars[index + <span class="number">1</span>] = slot2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = localVars[index].num;</span><br><span class="line">        <span class="keyword">long</span> high = localVars[index + <span class="number">1</span>].num;</span><br><span class="line">        <span class="keyword">return</span> ((high &amp; <span class="number">0x000000ffffffffL</span>) &lt;&lt; <span class="number">32</span>) | (low &amp; <span class="number">0x00000000ffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> bits = Double.doubleToLongBits(val);</span><br><span class="line">        setLong(index, bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> bits = getLong(index);</span><br><span class="line">        <span class="keyword">return</span> Double.longBitsToDouble(bits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(<span class="keyword">int</span> index, Zobject ref)</span> </span>&#123;</span><br><span class="line">        Slot slot = <span class="keyword">new</span> Slot();</span><br><span class="line">        slot.ref = ref;</span><br><span class="line">        localVars[index] = slot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Zobject <span class="title">getRef</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localVars[index].ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，我们这里并没有对 boolean、byte、short 和 char 类型定义存取方法，因为这些类型的值都是转换成 int 值类来处理的。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈的实现方式和局部变量表类似。操作数栈也是通过索引来访问的，操作数栈的大小是编译器已经确定的，所以依然可以用[]Slot 实现。这里有一个 size 字段是用于记录栈顶位置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;  <span class="comment">//初始值为 0,在运行中,代表当前栈顶的 index,还未使用,可以直接用,用完记得 size++;</span></span><br><span class="line">    <span class="keyword">private</span> Slot[] slots;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperandStack</span><span class="params">(<span class="keyword">int</span> maxStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxStack &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slots = <span class="keyword">new</span> Slot[maxStack];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"maxStack&lt;0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Slot slot = <span class="keyword">new</span> Slot();</span><br><span class="line">        slot.num = val;</span><br><span class="line">        slots[size] = slot;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> slots[size].num;</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和局部变量表类似，需要定义一些方法从操作数栈中弹出，或者往其中推入各种类型的变量。这里只列举出最简单的对于 int 变量进行存取的的部分，对于其它类型的存取和局部变量表是一样的，就不在浪费篇幅了。这里要注意的一点是：每次存取数据，都要对 size 进行相应的加减操作。</p><h2 id="局部变量表和操作数栈实例分析"><a href="#局部变量表和操作数栈实例分析" class="headerlink" title="局部变量表和操作数栈实例分析"></a>局部变量表和操作数栈实例分析</h2><p>以下面计算圆形周长的方法为例,观察局部变量和操作数栈的变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">circumference</span><span class="params">(<span class="keyword">float</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> pi = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="keyword">float</span> area = <span class="number">2</span> * pi * r;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码被 javac 编译成如下字节码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00 ldc #4</span><br><span class="line">02 fstore_1</span><br><span class="line">03 fconst_2</span><br><span class="line">04 fload_1</span><br><span class="line">05 fmul</span><br><span class="line">06 fload_0</span><br><span class="line">07 fmul</span><br><span class="line">08 fstore_2</span><br><span class="line">09 fload_2</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure><p>circumference（）方法的局部变量表大小是 3，操作数栈深度是 2;(执行方法所需的局部变量表大小和操作数栈深度是由编译器预先计算好的)</p><p>假设调用该方法时传入的参数是 1.6f,那么执行该方法时，操作数栈和局部变量表的变化如下：</p><p><img src="http://7xvxof.com1.z0.glb.clouddn.com/jvmgo_40.png" alt="circumference 方法执行过程"></p><p>传递给它的参数是 1.6f，方法开始执行前，1.6 被保存在本地变量表的#0 位置，接下来开始执行字节码：</p><p>首先是 ldc，它把 3.14f 推入栈顶</p><p>接着是 fstore_1 指令，它把栈顶的 3.14f 弹出，放到#1 号局部变量中</p><p>fconst_2 指令把 2.0f 推到栈顶</p><p>fload_1 指令把#1 号局部变量推入栈顶</p><p>fmul 指令执行浮点数乘法。它把栈顶的两个浮点数弹出，相乘，然后把结果推入栈顶</p><p>fload_0 指令把#0 号局部变量推入栈顶</p><p>fmul 继续乘法计算</p><p>fstore_2 指令把操作数栈顶的 float 值弹出，放入#2 号局部变量表</p><p>fload_2 指令把#2 号局部变量推入操作数栈顶</p><p>最后 freturn 指令把操作数栈顶的 float 变量弹出，返回给方法调用者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LayoutInflater内部原理</title>
      <link href="/2017/05/12/LayoutInflater%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2017/05/12/LayoutInflater%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h1><p>相信大家对 LayoutInflater 并不陌生，我们在使用 ListView，RecyclerView 时，经常需要将 item 的布局文件加载到 ListView 上，这就用到了 LayoutInflater，调用 inflate 方法就可以将一项 item 添加到父控件中，那么它内部是如何实现的呢？</p><p>先来看一下我们平时是怎么获取 LayoutInflater 的</p><ul><li>LayoutInflater layoutInflater = LayoutInflater.from(context);</li><li>LayoutInflater layoutInflater = (LayoutInflater) context  .getSystemService(Context.LAYOUT_INFLATER_SERVICE); </li></ul><p>其实第一种内部是调用了第二种方法，这是一个跨进程通信的过程，因为解析布局文件这个服务是系统级的服务。</p><p>在获取到 LayoutInflater 之后，就可以使用其方法了,其对外提供的 inflate 方法有若干重载方法，但是最后都是调用到了下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflate(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span><br></pre></td></tr></table></figure><p>接下来进入 inflate 方法内部，看其如何实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"INFLATING from resource: \""</span> + res.getResourceName(resource) + <span class="string">"\" ("</span></span><br><span class="line">                + Integer.toHexString(resource) + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 10 行，根据传入的布局文件 id，生成一个 Xml 解析器，LayoutInflater 其实就是使用 Android 提供的 pull 解析方式来解析布局文件的。接下来调用 inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)方法开始解析所提供的布局文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">        final Context inflaterContext = mContext;</span><br><span class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">        mConstructorArgs[0] = inflaterContext;</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                // Empty</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                        + &quot;: No start tag found!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final String name = parser.getName();</span><br><span class="line">            </span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                System.out.println(&quot;**************************&quot;);</span><br><span class="line">                System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                        + name);</span><br><span class="line">                System.out.println(&quot;**************************&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Create layout params that match root, if supplied</span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    if (!attachToRoot) &#123;</span><br><span class="line">                        // Set the layout params for temp if we are not</span><br><span class="line">                        // attaching. (If we are, we use addView, below)</span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Inflate all children under temp against its context.</span><br><span class="line">                rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                // to root. Do that now.</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Decide whether to return the root that was passed in or the</span><br><span class="line">                // top view found in xml.</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">            InflateException ex = new InflateException(e.getMessage());</span><br><span class="line">            ex.initCause(e);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            InflateException ex = new InflateException(</span><br><span class="line">                    parser.getPositionDescription()</span><br><span class="line">                            + &quot;: &quot; + e.getMessage());</span><br><span class="line">            ex.initCause(e);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // Don&apos;t retain static reference on context.</span><br><span class="line">            mConstructorArgs[0] = lastContext;</span><br><span class="line">            mConstructorArgs[1] = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 6 行，创建一个 AttributeSet 对象，该对象用来保存 xml 布局中 View 中设置的属性，只不过现在只是创建了这个类，对于该类的成员变量现在还没有进行初始化，其实这个类中持有了 xmlParser(这一点要明确)，其内部封装了 getAttributeByName 等方法，并且在接下来的解析过程中从来没有显示的解析过 view 的属性，而是在反射创建 view 的过程中，传入这个 AttributeSet 对象，想要获取什么属性，直接调用 AttributeSet 的 getAttributeByXXX 的方法即可。至于和 layout 相关的属性，都不在 view 的构造方法中获取，而是在为其设置 LayoutParams 的时候，进行获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.ViewGroup_Layout);</span><br><span class="line">    setBaseAttributes(a,</span><br><span class="line">            R.styleable.ViewGroup_Layout_layout_width,</span><br><span class="line">            R.styleable.ViewGroup_Layout_layout_height);</span><br><span class="line">    a.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 9 行，将传入的第二个参数 root 赋给 result，先不管这个方法内部做了什么，总之这个方法返回值就是 result，但是也不一定就是第二个参数 root，因为该方法中间还有可能改变 result 的值。</p><p>第 14 行，开始解析 xml 布局文件，这里是个 while 循环，循环体中是空实现，目的是要获得该 xml 的开始节点或者结尾节点。如果不是开始或者结束，那么就一直寻找 Dom 树中的下一个节点，直到找到为止。当然这里还是为了获取开始节点，因为在第 19 行还会判断找到的是不是开始节点，不是的话直接报错了。</p><p>第 24 行，获取到传入的布局文件的根节点的 name</p><p>第 33 行，如果该节点是”merge”，会进行一次判断，因为 merge 的用法是会将 merge 节点下的所有布局全部添加到其父容器中，如果我们传入的 root 为 null，或者 attachToRoot 为 false，违背了 merge 的用法，直接报错；否则会调用 rInflate 方法解析 merge 节点中的控件，rInflate 的内部实现在下面进行分析</p><p>第 42 行，如果根节点不是”merge”，那么调用<code>createViewFromTag(root, name, inflaterContext, attrs)</code>方法，创建该布局根节点所代表的 View 对象 temp，createViewFromTag 方法的内部流程在下面进行解释。</p><p>第 46 行，判断该 inflate 方法的第二个参数 root 是否为 null，如果不为空，那么调用该 root 的 generateLayoutParams 方法产生 LayoutParams</p><p>第 52 行，判断该 inflate 方法的第三个参数 attachToRoot 的值，如果为 false，那么给第 42 行返回的布局的根 View 设置第 46 行创建的 LayoutParams</p><p>第 65 行，执行 rInflateChildren(parser, temp, attrs, true)方法，解析 temp 节点内的子 view，内部执行流程在下面进行分析</p><p>第 73 行，如果同时满足 root 不为 null 并且 attachToRoot 为 true，那么执行 root.addView(temp, params)，并最终返回该 root（inflate 的第二个参数）</p><p>第 79 行，如果 root 为 null 或者 attachToRoot 为 false，那么直接返回 temp（解析的布局文件的根节点的 View 对象）</p><h1 id="LayoutInflater-方法使用不同参数产生不同的效果"><a href="#LayoutInflater-方法使用不同参数产生不同的效果" class="headerlink" title="LayoutInflater 方法使用不同参数产生不同的效果"></a>LayoutInflater 方法使用不同参数产生不同的效果</h1><p>现在有如下两个布局文件：</p><p>activity_main.xml ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/activity_main"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>button_layout.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Button"</span> &gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们并没有在 LinearLayout 中添加 Button 的标签，而是将 Button 写在另一个单独的布局文件中，然后在代码中将 button 添加到上面的 LinearLayout 中,但是使用不同的 inflate 的参数，查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">getWindow().requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">LinearLayout linearLayout = (LinearLayout) findViewById(R.id.activity_main);</span><br><span class="line">Button button;</span><br><span class="line">LayoutInflater inflater = LayoutInflater.from(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//（1）</span></span><br><span class="line">button = (Button) inflater.inflate(R.layout.button_main, <span class="keyword">null</span>);</span><br><span class="line">linearLayout.addView(button);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（2）</span></span><br><span class="line">inflater.inflate(R.layout.button_main, linearLayout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（3）</span></span><br><span class="line">button = (Button) inflater.inflate(R.layout.button_main, linearLayout, <span class="keyword">false</span>);</span><br><span class="line">linearLayout.addView(button);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果如图：</p><h2 id="inflate-layoutId-null"><a href="#inflate-layoutId-null" class="headerlink" title="inflate(layoutId, null)"></a>inflate(layoutId, null)</h2><p>使用这个方法，没有指定父容器，现象就是第一个 button 并没有按照布局文件中设定的那样，显示 300dp 的高度。根据 inflate 方法中的第 79 行，直接将解析到 button 返回，我们直接拿到这个 button 是没有用的，想要在 LinearLayout 中显示出来，还需要调用 addView 的方法，但是此时的 button 是没有 LayoutParams 的，所以直接执行 addView，那么检查到该 button 没有 LayoutParams，会给其添加一个自带的 LayoutParams，在 LinearLayout 中，产生的默认 LayoutParams 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 LayoutParams，如果不了解的话，请参考<a href="https://zachaxy.github.io/2017/05/11/%E5%AF%B9LayoutParams%E7%9A%84%E7%90%86%E8%A7%A3/">对 LayoutParams 的理解</a></p><p>我们的线性布局是纵向的，所以宽度是父容器宽度，高度是包裹内容，结果正是我们看到的第一个 button 的效果；</p><h2 id="inflate-layoutId-root"><a href="#inflate-layoutId-root" class="headerlink" title="inflate(layoutId, root )"></a>inflate(layoutId, root )</h2><p>使用这个方法，指定了父容器为 LinearLayout，inflate 方法中如果使用了两个参数的方法，那么第三个参数 attachToRoot 的值默认为 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 root 不为 null 所以 attachToRoot 为 true，满足 inflate 方法中第 73 行的条件，所以为 button 的 LayoutParams 与 LinearLayout 进行关联，从而满足了 button 的 300dp 的高度，结果就是现实的第二个 button 的效果。</p><h2 id="inflate-layoutId-root-false"><a href="#inflate-layoutId-root-false" class="headerlink" title="inflate(layoutId, root, false )"></a>inflate(layoutId, root, false )</h2><p>使用这个方法，root 不为空，但是 attachToRoot 为 false，所以调用了 inflate 方法中第 52 行的逻辑，为这个 view 添加了 root 的 LayoutParams，并返回该 view，之前也说过，一个 View 如果没有与父容器关联的 LayoutParams，那么这个 view 是没有办法使用的。所以在这里要比第二种方法多了一步手动 addView 的方法，所以这样和第二种效果是一样的，只是 attachToRoot 的值，如果为 true，inflate 时自动帮我们添加到 root 中，为 false，那么返回的 view 需要我们手动执行一次 root.addView 方法才可以，当然这里我们也可以将 view 解析出来之后，不调用 root 的 addView 方法，而是调用其它 ViewGroup 的 addView 方法，但是这样感觉有点混乱，如果想调用其它 ViewGroup 的 addView 方法，何不在 inflate 时，将 root 设置为我们真正的 ViewGroup。</p><h1 id="在-inflate-方法中炸出的几个方法"><a href="#在-inflate-方法中炸出的几个方法" class="headerlink" title="在 inflate 方法中炸出的几个方法"></a>在 inflate 方法中炸出的几个方法</h1><h2 id="createViewFromTag"><a href="#createViewFromTag" class="headerlink" title="createViewFromTag"></a>createViewFromTag</h2><blockquote><p>该方法的作用是根据解析到的布局文件的节点名（eg：RelativeLayout，TextView，com.your.coustom.view 等）创建对应的 Java 对象，在 Java 中如何根据类名创建对象呢？很显然是用反射来实现的。这就是 createViewFromTag 所完成的功能，其将解析到对应的 View 返回。</p></blockquote><p>那么接下来深入源码，看一下其具体流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,<span class="keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</span><br><span class="line">name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply a theme wrapper, if allowed and one is specified.</span></span><br><span class="line"><span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line"><span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">&#125;</span><br><span class="line">ta.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">    <span class="comment">// Let's party like it's 1995!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlinkLayout(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">    mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</span><br><span class="line">    view = onCreateView(parent, name, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">final</span> InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">+ <span class="string">": Error inflating class "</span> + name);</span><br><span class="line">          ie.initCause(e);</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">final</span> InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</span><br><span class="line">+ <span class="string">": Error inflating class "</span> + name);</span><br><span class="line">ie.initCause(e);</span><br><span class="line"><span class="keyword">throw</span> ie;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 30 行，开始解析我们的 view 了，这里是使用不同的 mFactory 来创建 View，优先顺序为：mFactory2=》mFactory=》mPrivateFactory，哪个 Factory 不为空，就用哪个，调用其 createView 方法，通过反射创建相应的对象，createView 方法就不在往下跟了，要不这篇就解不了了，后面有时间会写一篇关于插件换肤的文章，会对 createView 方法进一步深入。</p><p>总之，你要记住结论，那就是 createViewFromTag 方法根据布局文件解析到的节点名，通过反射创建相应的对象。</p><h2 id="rInflate"><a href="#rInflate" class="headerlink" title="rInflate"></a>rInflate</h2><blockquote><p>回顾调用 rinflate 方法的地方，是在解析布局文件时，根 tag 为”merge”，我们知道 merge 必须是某个布局文件的根 tag，其下包含的所有的子 view 们直接添加到其父容器中，这样就减少了一层布局的嵌套。在单独的一个布局文件中，merge 的表现类似于 FrameLayout。那么根据这个特性，解析时直接跳过 merge 这一层，进入内部，继续解析具体的 view。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void rInflate(XmlPullParser parser, View parent, Context context,</span><br><span class="line">AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">final int depth = parser.getDepth();//这个 depth 的值，估计是 2，因为 merge 作为根标签，其 depth 是 1，现在进入了 merge 的内部，所以为 2</span><br><span class="line">int type;</span><br><span class="line"></span><br><span class="line">while (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final String name = parser.getName();</span><br><span class="line"></span><br><span class="line">if (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">parseRequestFocus(parser, parent);</span><br><span class="line">&#125; else if (TAG_TAG.equals(name)) &#123;</span><br><span class="line">parseViewTag(parser, parent, attrs);</span><br><span class="line">&#125; else if (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">if (parser.getDepth() == 0) &#123;</span><br><span class="line">throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</span><br><span class="line">&#125;</span><br><span class="line">parseInclude(parser, context, parent, attrs);</span><br><span class="line">&#125; else if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">final View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line">final ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">rInflateChildren(parser, view, attrs, true);</span><br><span class="line">viewGroup.addView(view, params);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (finishInflate) &#123;</span><br><span class="line">parent.onFinishInflate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 7 行，拿到当前标签的深度，其深度在这里是 2，因为已经跳过了跟标签 merge，进去其内部了，xml 的深度示意图如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- outside --&gt;</span>     0</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>               1</span><br><span class="line">  sometext           1</span><br><span class="line">    <span class="tag">&lt;<span class="name">foobar</span>&gt;</span>         2</span><br><span class="line">      ... 2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foobar</span>&gt;</span>        2</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span>              1</span><br><span class="line"><span class="comment">&lt;!-- outside --&gt;</span>     0</span><br></pre></td></tr></table></figure><p>第 23 行，主要这里解释了如果解析到的 tag 是 include，那么并且其深度为 0，那么直接抛出异常，这表明 include 标签是不能作为根标签的。只能作为子标签，接下来开始调用 parseInclude 方法解析 include 指定的布局文件，内部依旧是类似于 createViewFromTag 的方法通过反射不断的创建 view 对象，这里不再深入。</p><p>第 31 行，这里调用了 createViewFromTag 的方法，创建了 merge 标签下的 view，并将该 view 添加到 rinflate 方法的第二个参数 root 中，其调用了 root.addView(view)，如果该 view 是一个 ViewGroup，其内部还有其它子 view，会调用 rInflateChildren 方法，继续解析该 view 下的子 view，最终结果相当于直接将 merge 标签下的子元素添加到 merge 标签 parent 中，这样就保证了不会引入额外的层级。</p><h2 id="rInflateChildren"><a href="#rInflateChildren" class="headerlink" title="rInflateChildren"></a>rInflateChildren</h2><blockquote><p>该方法被调用的时机是在当解析到一个 ViewGroup 类型的标签时（eg：LinearLayout 等），那么会调用该方法，继续解析该 ViewGroup 下的标签。其内部的实现很简单，直接调用了上面的 rinflate 方法，以当前解析的到 ViewGroup 作为该方法的第二个参数 root，进行解析。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rInflateChildren</span><span class="params">(XmlPullParser parser, View parent, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结：解析-XML-布局文件的作用"><a href="#总结：解析-XML-布局文件的作用" class="headerlink" title="总结：解析 XML 布局文件的作用"></a>总结：解析 XML 布局文件的作用</h1><p>本节以 LayoutInflater 方法的不同参数抛出问题，引出 LayoutInflater 内部的执行流程，并解释了 inflate 方法中的几个解析布局文件的关键方法，然后又根据 inflate 不同的参数，观察其不同的现象。相信此刻你对于 LayoutInflater 的使用以及其内部的执行原理已经很清楚了。接下来再做一个总结</p><p>当我们用 LayoutInflater 解析一个布局文件的时候到底做了什么，简单的一句话就是：<strong>将布局映射成一棵多叉树</strong>。</p><p>inflate 方法的核心就是根据不同的标签，反射出不同的 View 对象。那么采用何种方法，才能表现 xml 布局文件中，父容器中和子 View 的包含关系呢？</p><p>答案就是使用了 ViewGroup#addView 方法，如果解析的 View 是一个 ViewGroup，那么会将该 ViewGroup 作为 parent，继续解析内部的 view，并将其添加到了 ViewGroup#mChilddren 数组中，这个数组默认长度为 12，如果子 view 数量过多，会对该数组进行扩容，都是以 12 进行扩充。如果子 View 依然是一个 ViewGroup，那么继续执行上面的过程，这个过程就是<strong>深度优先遍历</strong>，将整个布局文件映射为一棵树，每个父节点必定是一个 ViewGroup，其对应的子节点就是在该 ViewGroup 标签下的 View，其引用保存在该 ViewGroup 的 mChildren 数组中，这样就形成了一棵多叉树，其根节点就是布局文件的根节点。</p><p>最后附上一张inflate的内部执行流程图</p><p><img src="http://opda1q948.bkt.clouddn.com/LayoutInflater.png" alt="inflate方法内部执行流程图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android UI 专题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对LayoutParams的理解</title>
      <link href="/2017/05/11/%E5%AF%B9LayoutParams%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/05/11/%E5%AF%B9LayoutParams%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="LayoutParams-是什么？"><a href="#LayoutParams-是什么？" class="headerlink" title="LayoutParams 是什么？"></a>LayoutParams 是什么？</h1><p>相信很多人都有疑惑，LayoutParams 是什么？不知道大家想过没有，如果定义一个 ViewGroup，然后在这个 ViewGroup 中放若干 view，这些 view 在 ViewGroup 中的大小关系是保存在哪里的呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/activity_main"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.zx.readsourcecode.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tv"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"文字"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一段最简单不过的布局文件，这里我们最常用的一个属性<code>android:layout_width</code>和<code>android:layout_height</code>相信大家再熟悉不过，其实这两个属性对应两个变量 width 和 height，那么这两个变量是哪个类的成员变量呢？答案就是 LayoutParams。虽然之前不知道 LayoutParams 这和类的存在，但是却一直偷偷的使用它。</p><h1 id="LayoutParams-的作用"><a href="#LayoutParams-的作用" class="headerlink" title="LayoutParams 的作用"></a>LayoutParams 的作用</h1><p> <strong>LayoutParams 是 View 用来告诉它的父控件如何放置自己的。</strong>基类 LayoutParams（也就是 ViewGroup.LayoutParams）仅仅描述了这个 View 想要的宽度和高度。在 View 的测量过程中，LayoutParams 起到了决定性的作用！</p><p>注意：<code>android:layout_width</code>和<code>android:layout_height</code>表面看起来是 TextView 的宽度和高度，相信这是很多人误解的地方，但如果是描述自己的宽高，那么属性名直接定义为<code>android:width</code>和<code>android:height</code>不就行了，为什么前面要加<code>layout_</code>的前缀？这是因为 TextView 既然放在 LinearLayout 中，那么它的宽度和高度并不是由自己决定的，而是由其父容器（这里对应 LinearLayout）来决定的。通过该属性可选的值 <code>match_parent</code>可以看出，这并不是一个具体的值，而是描述为和父容器一样宽，所以宽度是看父容器有多宽，才给子 view 设置多宽的。</p><p>而描述 View 直接用它们自己的属性就好了，如<code>textColor</code>和<code>text</code>等等，为什么还需要引入 LayoutParams 呢？因为<code>textColor</code>和<code>text</code>等这样的属性都是只与 TextView 自身有关的，无论这个 TextView 处于什么环境，这些属性都是不变的。而<code>layout_width</code>与<code>layout_marginLeft</code>这样的属性是与它的父控件息息相关的，是父控件通过 LayoutParams 提供这些”layout_”属性给孩子们用的；是父控件根据孩子们的要求（LayoutParams）来决定怎么测量。</p><p>所以在 xml 布局中，凡是以<code>layout_</code>开头的属性，均不是 view 自身的，而是它所在的父控件的 LayoutParams 类中的属性，这里的父控件一定是 ViewGroup 的一个子类。</p><h1 id="ViewGroup-LayoutParams"><a href="#ViewGroup-LayoutParams" class="headerlink" title="ViewGroup.LayoutParams"></a>ViewGroup.LayoutParams</h1><p>LayoutParams 是 ViewGroup 中的一个静态类，而每个 ViewGroup 的子类（eg：LinearLayout，FrameLayout，RelativeLayout 等）中依然有一个各自的 LayoutParams 的子类，其在 ViewGroup 的 LayoutParams 静态类的基础之上，添加了和具体布局相关的属性，比如 LinearLayout 中特有的 layout_weight 属性，用来指定特定方向的分配比例，再比如 RelativeLayout 特有的 layout_left，用来指定当前 view 和其它子 view 相对位置的属性等。进入源码中看一下 ViewGroup 中静态内部类 LayoutParams。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static class LayoutParams &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)</span><br><span class="line">    @Deprecated</span><br><span class="line">    public static final int FILL_PARENT = -1;</span><br><span class="line"></span><br><span class="line">    public static final int MATCH_PARENT = -1;</span><br><span class="line"></span><br><span class="line">    public static final int WRAP_CONTENT = -2;</span><br><span class="line"></span><br><span class="line">    public int width;</span><br><span class="line"></span><br><span class="line">    public int height;</span><br><span class="line">    </span><br><span class="line">    public LayoutParams(Context c, AttributeSet attrs) &#123;</span><br><span class="line">    TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.ViewGroup_Layout);</span><br><span class="line">    </span><br><span class="line">    setBaseAttributes(a,</span><br><span class="line">    R.styleable.ViewGroup_Layout_layout_width,</span><br><span class="line">    R.styleable.ViewGroup_Layout_layout_height);</span><br><span class="line">    </span><br><span class="line">    a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LayoutParams(int width, int height) &#123;</span><br><span class="line">        this.width = width;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其内部的成员变量只有最基本的 width 和 height，对应了布局文件中的<code>android:layout_width</code>和<code>android:layout_height</code>的值，在解析布局文件时，遇到这两个属性，就给对应的 LayoutParams 的这两个成员变量进行赋值了。</p><p>在 ViewGroup 中还自带了一个 LayoutParams 的子类 MarginLayoutParams，供不同的布局使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarginLayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">LayoutParams</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> leftMargin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> topMargin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rightMargin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bottomMargin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> startMargin = DEFAULT_MARGIN_RELATIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> endMargin = DEFAULT_MARGIN_RELATIVE;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其添加了 Margin 相关的属性，相对于布局文件的<code>android:layout_marginLeft=&quot;5dp&quot;</code>等属性。</p><p><code>LayoutParams</code>其实是父控件提供给子 view 的，好让子 view 选择如何测量和放置自己。所以在子 view 添加到父控件的那一刻，子 view 就应该有<code>LayoutParams</code>了。我们来看看几中常见的在代码中添加 View 的方式：还是上面的布局，这次我们不用 xml，而是用代码来实现一样的效果。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout linearLayout = (LinearLayout) findViewById(R.id.activity_main);</span><br><span class="line">TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">LinearLayout.LayoutParams params = <span class="keyword">new</span> LinearLayout.LayoutParams(</span><br><span class="line">        LinearLayout.LayoutParams.MATCH_PARENT,</span><br><span class="line">        LinearLayout.LayoutParams.WRAP_CONTENT);</span><br><span class="line">linearLayout.addView(textView, params);</span><br></pre></td></tr></table></figure><p>View 要是想被添加到 ViewGroup 中，是不可能脱离相应的 ViewGroup.LayoutParams，而独立存在的，不信你将布局文件中的<code>android:layout_width</code>和<code>android:layout_height</code>这两个属性删掉，编译器立即报错。</p><p>同时在代码中添加上述操作，虽然可以使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout linearLayout = (LinearLayout) findViewById(R.id.activity_main);</span><br><span class="line">TextView textView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">linearLayout.addView(textView);</span><br></pre></td></tr></table></figure><p>但是我们追到 addView 方法内部看一下，可以得出结论，调用 addView（view）的方法，对应的 ViewGroup子类会通过 generateDefaultLayoutParams（）方法自动添加一个默认的 LayoutParams。不同的 ViewGroup（这里指的是 LinearLayout）产生具体 LayoutParams 的方法不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">    params = generateDefaultLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"generateDefaultLayoutParams() cannot return null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的 ViewGroup（布局）产生具体 LayoutParams 的方法不同。看一下 LinearLayout 中的 generateDefaultLayoutParams（）是如何添加的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的添加了一个宽高均为 wrap_content 的属性。</p><p><strong>注：generateDefaultLayoutParams 方法中返回的 LayoutParams 类，是具体的 ViewGroup 子类（这里代表 LinearLayout）中的静态类 LayoutParams，而不是 ViewGroup 中的。</strong></p><p>在深入到 addView 中，看一下 view 和 LayoutParams 是如何关联的，这里删除了部分代码，只看主线；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewInner</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> preventRequestLayout)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">if</span> (child.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified child already has a parent. "</span> +</span><br><span class="line">                <span class="string">"You must call removeView() on the child's parent first."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">if</span> (!checkLayoutParams(params)) &#123;</span><br><span class="line">        params = generateLayoutParams(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//(3)preventRequestLayout 参数的默认值是 false；</span></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123;</span><br><span class="line">        child.mLayoutParams = params;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.setLayoutParams(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//(4)默认值为 -1</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = mChildrenCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//(5)</span></span><br><span class="line">    addInArray(child, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) tell our children，默认值为 false；</span></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123;</span><br><span class="line">        child.assignParent(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.mParent = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//(7)</span></span><br><span class="line">    dispatchViewAdded(child);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看一下 addViewInner 方法内部的执行流程</p><ol><li>检查 view 是否被别的 ViewGroup 添加过，如果被别的添加过，那么抛出异常</li><li>再对 layoutParams 进行检测，如果为 null，执行 generateLayoutParams(params)，这也是最后一次为 view 创建 params 了，这里添加的是 ViewGroup.LayoutParams，一般在 LinearLayout、RelativeLayout 等已有的布局中，addview 中会先执行类似的为 view 创建 params 的方法，添加的是各布局特有的 LayoutParams，但是如果是我们自定义的 ViewGroup，也许没有实现配套的 LayoutParams，所以最后用的是 ViewGroup 中自带的 LayoutParams</li><li>将 view 的 layoutParams 设置为当前的 layoutParams，在这里执行了关联</li><li>除非我们在 addView(view,index)指定了具体值，否则 index 默认值为 -1，如果是 -1 的话，这一步将 index 改为 ViewGroup 中当前 child view 的总和</li><li>ViewGroup 中有一个数组，保存着其所有子 view，这里根据 index 值添加到相应的位置，当然这里也涉及到了数组扩容问题，如果你手动指定的 index 过大，超过了当前 ViewGroup 的 mChildrenCount，那么直接报错，index 过大</li><li>为 view 分配 parent，这个 parent 就是添加该子 view 的 ViewGroup</li><li>执行了 addView 方法，那么原有的 ViewGroup 的结构势必会发生改变，这时候会执行一个回调，通知当前 ViewGroup 添加或者移除了一个 view；当然这个回调默认是 null，我们可以手动添加该回调，使用<code>setOnHierarchyChangeListener(OnHierarchyChangeListener listener)</code></li></ol><h1 id="自定义-LayoutParams"><a href="#自定义-LayoutParams" class="headerlink" title="自定义 LayoutParams"></a>自定义 LayoutParams</h1><p>前面提到，每个 ViewGroup 的子类（eg：LinearLayout，FrameLayout，RelativeLayout 等）中依然有一个各自的静态内部类 xxxLayout.LayoutParams，其继承了 ViewGroup#LayoutParams，并根据具体的布局，新增了相关属性，比如 LinearLayout 中特有的 layout_weight 属性，用来指定特定方向的分配比例，再比如 RelativeLayout 特有的 layout_left、layout_right 等，用来指定当前 view 和其它子 view 相对位置的属性等。</p><p>前面分析 addView 的流程中也介绍到子 view 要想添加到父容器中，父容器必定会给子 view 指定一个 LayoutParams，脱离了 LayoutParams，view 无法单独存在，view 可以通过其 getLayoutParams 方法获取其父容器为子 view 绑定的 LayoutParams。</p><p>使用 Android 官方提供的这些 ViewGroup（eg：LinearLayout，FrameLayout，RelativeLayout 等）在 addView 时都会为 view 设置一个 xxxLayout.LayoutParams，而在我们自定义 ViewGroup 控件的时候，如果没有为自定义的 ViewGroup 添加配套的 LayoutParams，那么最终在执行 addViewInner 方法时，会为 view 添加 ViewGroup#LayoutParams，这个 LayoutParams 是一个最基础的，只有 width 和 height 属性，如果我们想实现自定义的 ViewGroup 特殊需求，那么自定义 LayoutParams 是必不可少的。</p><p>关于如何自定义 LayoutParams，以及在自定义 LayoutParams 时要注意哪些问题，请参考实战案例<a href>自定义 ViewGroup——百分比布局</a>，这篇文章会根据具体的 ViewGroup 的功能需求，制定对应的 LayoutParams。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LayoutParams 的作用：是 View 用来告诉它的父控件如何放置自己的，理解这一点很重要，因为这是 view 在 measure 和 layout 过程中很重要的因素。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android UI 专题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(7)-读取class文件</title>
      <link href="/2017/05/10/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-7-%E8%AF%BB%E5%8F%96class%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/10/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-7-%E8%AF%BB%E5%8F%96class%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过前面几节的讲解，我们已经基本了解了 class 文件的结构,每个字段代表什么含义,占多少字节,那么明确了 Class 文件的规则,接下来就可以读取 class 文件了，本节的代码均在<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">项目</a>的 classfile 包下。</p></blockquote><hr><h1 id="Class-文件的结构"><a href="#Class-文件的结构" class="headerlink" title="Class 文件的结构"></a>Class 文件的结构</h1><p>这里再次贴出 class 文件的结构描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">  u4 magic;<span class="comment">//魔数</span></span><br><span class="line">  u2 minor_version;<span class="comment">//次版本号</span></span><br><span class="line">  u2 major_version;<span class="comment">//主版本号</span></span><br><span class="line">  u2 constant_pool_count;<span class="comment">//常量池大小</span></span><br><span class="line">  cp_info constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">//常量池</span></span><br><span class="line">  u2 access_flags;<span class="comment">//类访问标志,表明 class 文件定义的是类还是接口，访问级别是 public 还是 private，等</span></span><br><span class="line">  u2 this_class;<span class="comment">//</span></span><br><span class="line">  u2 super_class;<span class="comment">//</span></span><br><span class="line">  u2 interfaces_count;<span class="comment">//本类实现的接口数量</span></span><br><span class="line">  u2 interfaces[interfaces_count];<span class="comment">//实现的接口,存放在数组中</span></span><br><span class="line">  u2 fields_count;<span class="comment">//本来中含有字段数</span></span><br><span class="line">  field_info fields[fields_count];<span class="comment">//数组中存放这各个字段</span></span><br><span class="line">  u2 methods_count;<span class="comment">//本类中含有的方法数</span></span><br><span class="line">  method_info methods[methods_count];<span class="comment">//数组中存放着各个方法</span></span><br><span class="line">  u2 attributes_count;<span class="comment">//本类中含有的属性数量;</span></span><br><span class="line">  attribute_info attributes[attributes_count];<span class="comment">//数组中存放着各个属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ClassFile-类"><a href="#ClassFile-类" class="headerlink" title="ClassFile 类"></a>ClassFile 类</h1><p>根据上面的 class 结构类型，我们自己定义的类 ClassFile 也呼之欲出,每个字段和上述 class 结构几乎是一样的。类中的一个成员变量定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFile</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> minorVersion;</span><br><span class="line">    <span class="keyword">int</span> majorVersion;</span><br><span class="line">    ConstantPool constantPool;</span><br><span class="line">    <span class="keyword">int</span> accessFlags;</span><br><span class="line">    <span class="keyword">int</span> thisClass;</span><br><span class="line">    <span class="keyword">int</span> superClass;</span><br><span class="line">    <span class="keyword">int</span>[] interfaces;</span><br><span class="line">    MemberInfo[] fields;</span><br><span class="line">    MemberInfo[] methods;</span><br><span class="line">    AttributeInfo[] attributes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassFile</span><span class="params">(<span class="keyword">byte</span>[] classData)</span> </span>&#123;</span><br><span class="line">        ClassReader reader = <span class="keyword">new</span> ClassReader(classData);</span><br><span class="line">        read(reader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">        readAndCheckMagic(reader);  <span class="comment">//验证魔数</span></span><br><span class="line">        readAndCheckVersion(reader);<span class="comment">//校验版本</span></span><br><span class="line">        constantPool = <span class="keyword">new</span> ConstantPool(reader);<span class="comment">//创建常量池</span></span><br><span class="line">        accessFlags = reader.readUint16();<span class="comment">//获取类访问标志</span></span><br><span class="line">        thisClass = reader.readUint16();<span class="comment">//</span></span><br><span class="line">        superClass = reader.readUint16();<span class="comment">//</span></span><br><span class="line">        interfaces = reader.readUint16s();<span class="comment">//</span></span><br><span class="line">        fields = MemberInfo.readMembers(reader, constantPool);<span class="comment">//</span></span><br><span class="line">        methods = MemberInfo.readMembers(reader, constantPool);<span class="comment">//</span></span><br><span class="line">        attributes = AttributeInfo.readAttributes(reader, constantPool);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很清晰的看到,我们定义的 ClassFile 文件,可以看到成员变量和 JVM 中关于 class 文件的描述是一致的,只不过这里为了方便编码,统一用 int 类型来保存 u1,u2 和 u4 类型的值.</p><h1 id="Class-文件字节码读取辅助类"><a href="#Class-文件字节码读取辅助类" class="headerlink" title="Class 文件字节码读取辅助类"></a>Class 文件字节码读取辅助类</h1><p>接下来要解决的问题是每个字段所占的字节数不同,所以这里我们需要若干方法根据字节数读取相应的字节,所有有创建了一个<code>ClassReader</code>类,并令该类持有 class 字节码，并且在该类中保存一个 index，表明现在是从哪个字节开始读.并且提供了读取 1 字节,2 字节,4 字节,8 字节等方法,来满足<code>ClassFile</code>类中个字段对应的字节数的需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassReader</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readUint8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> res = data[index++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// u2 这里是读取一个无符号的 16 位整,java 中没有,只能用 int 来代替吧;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readUint16</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = data[index++];</span><br><span class="line">        res[<span class="number">1</span>] = data[index++];</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytesToU16(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readUint32() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        res[<span class="number">0</span>] = data[index++];</span><br><span class="line">        res[<span class="number">1</span>] = data[index++];</span><br><span class="line">        res[<span class="number">2</span>] = data[index++];</span><br><span class="line">        res[<span class="number">3</span>] = data[index++];</span><br><span class="line"><span class="comment">//        return ByteUtils.bytesToU32(res);  //如果需要转换的话,自行调用 ByteUtils 中的方法;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readUint64() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">        res[<span class="number">0</span>] = data[index++];</span><br><span class="line">        res[<span class="number">1</span>] = data[index++];</span><br><span class="line">        res[<span class="number">2</span>] = data[index++];</span><br><span class="line">        res[<span class="number">3</span>] = data[index++];</span><br><span class="line">        res[<span class="number">4</span>] = data[index++];</span><br><span class="line">        res[<span class="number">5</span>] = data[index++];</span><br><span class="line">        res[<span class="number">6</span>] = data[index++];</span><br><span class="line">        res[<span class="number">7</span>] = data[index++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] readUint16s() &#123;</span><br><span class="line">        <span class="keyword">int</span> n = readUint16();</span><br><span class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[i] = readUint16();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = data[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有了 ClassReader 这样的工具类之后,我们就可以在 ClassFile 中根据不同的字段，使用不同的 ClassReader#readXXX() 方法,来初始化成员变量,这里定义了一个 ClassFile#read() 方法来完成 ClassFile 类的初始化成员变量的任务。</p><h1 id="简单字段的实现"><a href="#简单字段的实现" class="headerlink" title="简单字段的实现"></a>简单字段的实现</h1><p>对于 ClassFile 的字段，除了常量和属性两个区域，其它的字段都可以很容易根据其占用的字节长度读出来，这对于编码来说并没有什么难度。在 ClassFile#read 方法中实现了所有字段的读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">    readAndCheckMagic(reader);</span><br><span class="line">    readAndCheckVersion(reader);</span><br><span class="line">    constantPool = <span class="keyword">new</span> ConstantPool(reader);</span><br><span class="line">    accessFlags = reader.readUint16();</span><br><span class="line">    thisClass = reader.readUint16();</span><br><span class="line">    superClass = reader.readUint16();</span><br><span class="line">    interfaces = reader.readUint16s();</span><br><span class="line">    fields = MemberInfo.readMembers(reader, constantPool);</span><br><span class="line">    methods = MemberInfo.readMembers(reader, constantPool);</span><br><span class="line">    attributes = AttributeInfo.readAttributes(reader, constantPool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于常量和属性，因为其各自又包含了许多种类，所以需要针对不同的常量，不同的属性进行不同的读取。接下来分别介绍如何实现常量和属性的读取。</p><h1 id="常量的实现"><a href="#常量的实现" class="headerlink" title="常量的实现"></a>常量的实现</h1><p>这里需要定义一个常量的抽象类 ConstantInfo，表示一个常量 item，具体的常量由其子类实现，这里对外提供一个统一的接口来根据不同的 tag，创建不同的具体常量实现类，以完成常量池的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ConstantInfo <span class="title">create</span><span class="params">(<span class="keyword">int</span> tag, ConstantPool constantPool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Integer:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantIntegerInfo();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Float:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantFloatInfo();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Long:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantLongInfo();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Double:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantDoubleInfo();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Utf8:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantUtf8Info();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_String:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantStringInfo(constantPool);</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Class:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantClassInfo(constantPool);</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Fieldref:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantMemberRefInfo(constantPool);</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_Methodref:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantMemberRefInfo(constantPool);</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_InterfaceMethodref:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantMemberRefInfo(constantPool);</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_NameAndType:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantNameAndTypeInfo();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2017/5/3 0003 下面三个类还未编码; </span></span><br><span class="line">        <span class="keyword">case</span> CONSTANT_MethodType:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantMethodTypeInfo();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_MethodHandle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantMethodHandleInfo();</span><br><span class="line">        <span class="keyword">case</span> CONSTANT_InvokeDynamic:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantInvokeDynamicInfo();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"java.lang.ClassFormatError: constant pool tag!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且提供一个抽象方法，供子类实现，因为每种常量所占的字节数并不相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">(ClassReader reader)</span></span></span><br></pre></td></tr></table></figure><p>而对于各自具体的常量，需要根据各自常量的结构来读取，其结构已经在<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-5-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B8%B8%E9%87%8F%E6%B1%A0/">手写 JVM 系列(5)-分析 class 文件-常量池</a>中进行了详细的介绍。具体实现请参照<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">项目源码</a></p><h1 id="常量池的实现"><a href="#常量池的实现" class="headerlink" title="常量池的实现"></a>常量池的实现</h1><p>有了上面各个常量的具体实现，那么接下来我们就可以构建常量池了。常量池其实就是本 class 文件中所有常量的集合。</p><p>因为常量池是根据索引来访问的，因此我们也很自然的想到用数组来表示常量池，数组类型是上面定义的常量类型，注意索引从 1 开始，0 是无效索引。常量池的初始化时在构造方法中，通过 ConstantInfo 提供的 readConstantInfo 静态方法，读取一字节 tag，根据 tag 创建不同的常量实现类，并添加到常量池数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPool</span> </span>&#123;</span><br><span class="line">    ConstantInfo[] infos;  <span class="comment">//保存类文件常量池中的所有常量,常量分为多种类型,基本类型都有对应的常量,以及字符串等;(简言之,这就是常量池的抽象)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> constantPoolCount; <span class="comment">//class 文件中常量池中的常量数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstantPool</span><span class="params">(ClassReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*读出常量池的大小;接下来根据这个大小,生成常量信息数组;</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">        1. 表头给出的常量池大小比实际大 1,所以这样的话,虽然可能生成了这么大的,但是 0 不使用,直接从 1 开始;</span></span><br><span class="line"><span class="comment">        2. 有效的常量池索引是 1~n–1。0 是无效索引，表示不指向任何常量</span></span><br><span class="line"><span class="comment">        3. CONSTANT_Long_info 和 CONSTANT_Double_info 各占两个位置。</span></span><br><span class="line"><span class="comment">           也就是说，如果常量池中存在这两种常量，实际的常量数量比 n–1 还要少，而且 1~n–1 的某些数也会变成无效索引。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        constantPoolCount = reader.readUint16();</span><br><span class="line">        infos = <span class="keyword">new</span> ConstantInfo[constantPoolCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; constantPoolCount; i++) &#123;</span><br><span class="line">            infos[i] = ConstantInfo.readConstantInfo(reader, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> ((infos[i] <span class="keyword">instanceof</span> ConstantLongInfo) || (infos[i] <span class="keyword">instanceof</span> ConstantDoubleInfo)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性的实现"><a href="#属性的实现" class="headerlink" title="属性的实现"></a>属性的实现</h1><p>对于属性的编码，和常量池的编码思路是相似的，其实这里称为“属性池”更为贴切。因为他是各种属性的集合。而 class 文件本身，方法表集合和字段表集合中均持有属性表。</p><p>同样，提供一个抽象类来表示一个属性，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">(ClassReader reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取单个属性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AttributeInfo <span class="title">readAttribute</span><span class="params">(ClassReader reader, ConstantPool constantPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> attrNameIndex = reader.readUint16();</span><br><span class="line">        String attrName = constantPool.getUtf8(attrNameIndex);</span><br><span class="line">        <span class="keyword">int</span> attrLen = ByteUtils.byteToInt32(reader.readUint32());</span><br><span class="line">        AttributeInfo attrInfo = create(attrName, attrLen, constantPool);</span><br><span class="line">        attrInfo.readInfo(reader);</span><br><span class="line">        <span class="keyword">return</span> attrInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取属性表;这个和 ConstantPool 中的方法类似,一般都是一下全部读取出来,不会只读一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AttributeInfo[] readAttributes(ClassReader reader, ConstantPool constantPool) &#123;</span><br><span class="line">        <span class="keyword">int</span> attributesCount = reader.readUint16();</span><br><span class="line">        AttributeInfo[] attributes = <span class="keyword">new</span> AttributeInfo[attributesCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributesCount; i++) &#123;</span><br><span class="line">            attributes[i] = readAttribute(reader, constantPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java 虚拟机规范预定义了 23 种属性，先解析其中的 8 种</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    23 种预定义属性可以分为三组。</span></span><br><span class="line"><span class="comment">    第一组属性是实现 Java 虚拟机所必需的，共有 5 种；</span></span><br><span class="line"><span class="comment">    第二组属性是 Java 类库所必需的，共有 12 种；</span></span><br><span class="line"><span class="comment">    第三组属性主要提供给工具使用，共有 6 种。第三组属性是可选的，也就是说可以不出现在 class 文件中。</span></span><br><span class="line"><span class="comment">    (如果 class 文件中存在第三组属性，Java 虚拟机实现或者 Java 类库也是可以利用它们的，比如使用 LineNumberTable 属性在异常堆栈中显示行号。)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AttributeInfo <span class="title">create</span><span class="params">(String attrName, <span class="keyword">int</span> attrLen, ConstantPool constantPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (attrName.equals(<span class="string">"Code"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CodeAttribute(constantPool);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"ConstantValue"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConstantValueAttribute();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"Deprecated"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DeprecatedAttribute();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"Exceptions"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExceptionsAttribute();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"LineNumberTable"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LineNumberTableAttribute();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"LocalVariableTable"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LocalVariableTableAttribute();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"SourceFile"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SourceFileAttribute(constantPool);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (attrName.equals(<span class="string">"Synthetic"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SyntheticAttribute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnparsedAttribute(attrName, attrLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部定义了抽象方法 readInfo，供各具体的属性类去读取相应的数据。而对外，提供了一个 readAttributes 的方法，来返回当前 方法表集合或者字段表集合中的的属性集合。与常量池不同的是：常量是根据不同的 tag（代表一个整数）来区分不同的常量，而属性是根据不同的 name（字符串）来区分不同的属性，所以创建属性的方法 AttributeInfo#create 方法。</p><p>而对于各自具体的属性，需要根据各自属性的结构来读取，其结构已经在<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/">手写 JVM 系列(6)-分析 class 文件-属性表</a>中进行了详细的介绍。具体实现请参照<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">项目源码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(6)-分析class文件-属性表</title>
      <link href="/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/"/>
      <url>/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>和常量池类似，各种属性表达的信息也各不相同，因此无法用统一的结构来定义。不同之处在于，常量是由 Java 虚拟机规范严格定义的，共有 14 种。但属性是可以扩展的，不同的虚拟机实现可以定义自己的属性类型。由于这个原因，Java 虚拟机规范没有使用 tag，而是使用<strong>属性名</strong>来区别不同的属性。属性数据放在属性名之后的 u1 表中，这样 Java 虚拟机实现就可以跳过自己无法识别的属性。</p></blockquote><h1 id="属性的基本结构"><a href="#属性的基本结构" class="headerlink" title="属性的基本结构"></a>属性的基本结构</h1><p>属性的结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">  u2 attribute_name_index;</span><br><span class="line">  u4 attribute_length;</span><br><span class="line">  u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个字段是属性名在常量池的索引，指向常量池中的 CONSTANT_Utf8_info 常量。</p><p>第二个字段是后面跟着的属性字节码的长度，用 u4 表示，表明属性的大小最大可以为 2^32-1。</p><p>第三个字段就是属性字节码。</p><h1 id="属性的种类"><a href="#属性的种类" class="headerlink" title="属性的种类"></a>属性的种类</h1><p>按照用途，有 23 种预定义属性，可以分为三组。</p><ol><li>第一组属性是实现 Java 虚拟机所必需的，共有 5 种；</li><li>第二组属性是 Java 类库所必需的，共有 12 种；</li><li>第三组属性主要提供给工具使用，共有 6 种。（这组属性是可选的，也就是说可以不出现在 class 文件中。如果 class 文件中存在第三组属性，Java 虚拟机实现或者 Java 类库也是可以利用它们的，比如使用 LineNumberTable 属性在异常堆栈中显示行号。）</li></ol><p>这里只介绍几个常用的属性：</p><table><thead><tr><th>属性名</th><th>位置</th><th>含义</th><th>分组</th></tr></thead><tbody><tr><td>Deprecated</td><td>ClassFile, field_info, method_info</td><td>被声明为 deprecated 的方法和字段</td><td>3</td></tr><tr><td>Synthetic</td><td>ClassFile, field_info, method_info</td><td>标示方法或字段是由编译器自动生成的</td><td>2</td></tr><tr><td>SourceFile</td><td>ClassFile</td><td>记录源文件的名称</td><td>3</td></tr><tr><td>ConstantValue</td><td>field_info</td><td>final 关键字定义的常量值</td><td>1</td></tr><tr><td>Code</td><td>method_info</td><td>Java 代码编译成的字节码指令</td><td>1</td></tr><tr><td>Exceptions</td><td>method_info</td><td>方法抛出的异常</td><td>1</td></tr><tr><td>LineNumberTable</td><td>Code</td><td>Java 源代码的行号与字节码指令的对应关系</td><td>3</td></tr><tr><td>LocalVariableTable</td><td>Code</td><td>方法的局部变量描述</td><td>3</td></tr></tbody></table><h1 id="属性的具体介绍"><a href="#属性的具体介绍" class="headerlink" title="属性的具体介绍"></a>属性的具体介绍</h1><p>由于属性种类较多，这里只选几个有代表性的属性进行讲解。</p><h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h2><p>最简单的属性，仅起标记作用，不包含任何数据。Deprecated 属性用于指出类、接口、字段或方法已经不建议使用，编译器等工具可以根据 Deprecated 属性输出警告信息。J2SE 5.0 之前可以使用 Javadoc 提供的@deprecated 标签指示编译器给类、接口、字段或方法添加 Deprecated 属性。其结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute &#123;</span><br><span class="line">  u2 attribute_name_index;</span><br><span class="line">  u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不包含任何数据，所以 attribute_length 的值必须是 0。自然也就没有了后面的 info 数组字段了。</p><h2 id="Synthetic"><a href="#Synthetic" class="headerlink" title="Synthetic"></a>Synthetic</h2><p>最简单的属性，仅起标记作用，不包含任何数据。Synthetic 属性用来标记源文件中不存在、由编译器生成的类成员，引入 Synthetic 属性主要是为了支持嵌套类和嵌套接口。其结构定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Synthetic_attribute &#123;</span><br><span class="line">  u2 attribute_name_index;</span><br><span class="line">  u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于不包含任何数据，所以 attribute_length 的值必须是 0。自然也就没有了后面的 info 数组字段了。</p><h3 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h3><p>这里要说一下，哪些方法是我们在代码里没有写，但是字节码文件会给我们加上呢? 首先构造方法，如果我们默认不写，那么字节码会自动添加上的。还有就是泛型，这里详细说明一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">get</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBridge</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;B&gt; clazz = B.class;</span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            Method m = methods[i];</span><br><span class="line">            System.out.println(getMethodInfo(m) + <span class="string">" is Bridge Method? "</span> + m.isBridge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMethodInfo</span><span class="params">(Method m)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(m.getReturnType()).append(<span class="string">" "</span>);</span><br><span class="line">        sb.append(m.getName());</span><br><span class="line">        Class[]params = m.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            sb.append(params[i].getName()).append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B 中复写了 A 中的 get 方法，那么在 main 方法中，打印 B 中的方法数，应该就是一个吧，那接下来看一下打印结果：</p><blockquote><p>[class java.lang.String get] is Bridge Method? false</p><p>[class java.lang.Object get] is Bridge Method? true </p></blockquote><p>会不会感到诧异，怎么会多出一个返回值为 Object 的 get 方法？</p><p>这个是 java5 中的泛型所带来的结果了。针对上面的这段代码分析下：<br>在 java5 之前，你可以往一个集合里扔任何你想扔的对象。但是从集合中取对象却变得很难。你不知道你下个取到的对象将会是什么具体类型的。因为取出来的对象是 Object 类型的，不知道转成什么类型，所以只能使用所有 Object 的方法了，这样就毫无意义了。所以在 java5 中提供了泛型这一新特性。我们在写代码的时候可以指定集合可以存放对象的类型。然后<strong>将类型检查的事情交给编译器去做</strong>，减少了程序员的工作。<br>​    </p><p>上面代码中&lt;&gt;中的 T 和 String 就是指定类的参数类型。T 代表一种泛型，告诉编译器，一旦有类指定了 T 这个参数的实际类，那么 get 方法返回的类型也必须为同一个类（当然也可以是这个类的子类；这个也是 java5 中的协变式返回新特性），如果不是，就必须报错提示；将原来的运行时可能出现的错误提前到编译期了。那么，假设你是 java5 编译器的设计者，你会如何来设计让编译器能实现这个特性，同时能保证编译出来的字节码可以在老版本的 jdk 中运行呢？java5 编译器中作了个很巧妙的设计——桥接方法。 </p><p>那么编译器是如何编译这个抽象类 A 的呢？</p><p>对于 A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">get</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会直接将其转换为下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Object <span class="title">get</span><span class="params">(Object t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个过程称为类型擦除，将泛型类型参数全部替换为 Object。</p><p>对于 B 类，它继承了 A 类，指定了 T 参数为 String。如果还按照以前那么编译，那编译的类就是： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在运行时肯定会报错，因为 B 继承了 A，而 A 又是 asbtract 类，B 还没 overriding A 中 Object get()方法。如何解决这个错误呢？java5 编译器在编译的时候做了些手脚。当编译器发现你指定了类型参数，便会在编译的字节码中添加一个桥接方法。所以代码变成了下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个就是编译器添加的方法</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(Object s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Object) get((String) s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们实际在调用 B 的 get 方法时，调用的其实是第二个方法，因为我们的参数传入的是 String。而如果是使用了多态，调用了 A.get,那么调用的将是 B 的第一个 get 方法。</p><ul><li><p>第一个 get 方法的描述符是：(Ljava/lang/Object;)Ljava/lang/Object;</p><p>access_flag:0x0001(public)</p></li><li><p>第二个 get 方法的描述符是：(Ljava/lang/String;)Ljava/lang/String;</p><p>access_flag:0x1041(public Synthetic bridge)</p></li></ul><h2 id="SourceFile"><a href="#SourceFile" class="headerlink" title="SourceFile"></a>SourceFile</h2><p>SourceFile 是可选定长属性，只会出现在 ClassFile 结构中，用于指出源文件名。其结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">  u2 attribute_name_index;</span><br><span class="line">  u4 attribute_length;</span><br><span class="line">  u2 sourcefile_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attribute_length 的值必须是 2。因为这个长度就是下面一个字段 sourcefile_index 的长度，这个索引是常量池的索引，常量池长度是用 u2 来表示的，所以该索引决不能超出 u2 的最大值，因此最大用两字节表示，所以 attribute_length 值固定为 2。</p><p>sourcefile_index 是常量池索引，指向<code>CONSTANT_Utf8_info</code>常量。而<code>CONSTANT_Utf8_info</code>中的字符串就是当前源文件的文件名。</p><h2 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h2><p>ConstantValue 是定长属性，只会出现在 field_info 结构中，用于表示常量表达式的值。其作用是通知虚拟机自动为静态变量赋值。只有被 static 修饰的变量（类变量）才可以使用这项属性。</p><p>其结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面有三种情况：</p><ul><li>int a1 = 123；</li><li>static int a2 = 123;</li><li>final static int a3 = 123</li></ul><p>对于非 static 变量，eg：a1，其赋值是在实例构造器<code>&lt;init&gt;</code>方法中完成的。</p><p>而对于 static 变量，eg：a2，a3，有两种赋值方式。</p><ol><li>在类构造器<code>&lt;clinit&gt;</code>方法中。</li><li>使用 ConstantValue 属性。</li></ol><p>目前 Sun Javac 的选择是：前提都是针对于用 static 修饰的静态变量。如果是用 final static 修饰的话，并且这个变量是基本类型或者 String，那么使用 2 赋值。否则使用 1 赋值。</p><p>因此这里的 constantvalue_index 是指向常量池中一个字面量类别（CONSTANT_Integer、CONSTANT_Float、CONSTANT_Long、CONSTANT_Double、CONSTANT_Utf8 五种中的一种）的索引，该常量中保存着变量的值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Code 是变长属性，只存在于 method_info 结构中。Code 属性中存放字节码等方法相关信息。其结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上面的 exception_table，其结构定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  u2 start_pc;</span><br><span class="line">    u2 end_pc;</span><br><span class="line">    u2 handler_pc;</span><br><span class="line">    u2 catch_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 方法中的代码经过 Javac 编译器处理之后，最终变成<strong>字节码指令</strong>存储在 Code 属性内。Code 属性出现在方法表的属性集合之中，但是并非所有的方法都必须存在 Code 这个属性。譬如接口或者抽象类中的方法就不存在 Code 属性。</p><p>接下来对其中的字段做一个介绍：</p><ul><li>attribute_name_index：指向 CONSTANT_Utf8_info 类型常量的索引，这个常量值固定为“Code”，代表了该属性的属性名称。</li><li>attribute_length：代表该属性的长度，包括从 attribute_name_index 开始到 attributes[]数组结束。</li><li>max_stack：代表操作数栈的深度的最大值。在方法执行的任意时刻，操作数栈都不能超过这个深度。</li><li>max_locals：代表了局部变量表所需的存储空间大小。在这里 max_locals 的单位是 Slot，Slot 是虚拟机为局部变量非配内存所使用的最小单位。对于 byte、char、short、int、float、boolean、returnAddress 等长度不超过 32 位的数据，每个局部变量占用一个 Slot，而 double 和 long 这种 64 位的数据则需要两个 Slot 来存放。</li><li>code_length：指示下面的 code 字节码数组的长度。虽然这是一个 u4 类型，理论上最大值可以达到 2^32-1，但是 Java 虚拟机明确规定一个方法中的指令不能超过 65535 条字节码指令，也就是说它实际是使用了 u2 的长度。</li><li>code[code_length]：存放的是 Java 源程序编译后生成的 <strong>字节码指令</strong> ，关于字节码指令，会在<a href="https://zachaxy.github.io/2017/05/13/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-9-%E6%8C%87%E4%BB%A4%E9%9B%86/">手写JVM系列(9)-指令集</a>一节详细说明。</li><li>exception_table_length：指示下面的异常表数组的长度。</li><li>exception_table[exception_table_length] 关于异常处理，会在<a href>后面的文章</a>中进行详细说明。</li><li>attributes_count：指示下面的属性表数组的长度。</li><li>attribute_info attributes[attributes_count]：Code 本身就已经是属性了，在这个属性的字段中还包括一些其它的属性…那么就存在这个表中。</li></ul><h3 id="关于-max-locals"><a href="#关于-max-locals" class="headerlink" title="关于 max_locals"></a>关于 max_locals</h3><p>max_locals 给出局部变量表大小。在这里 max_locals 的单位是 Slot，Slot 是虚拟机为局部变量非配内存所使用的最小单位。对于 byte、char、short、int、float、boolean、returnAddress 等长度不超过 32 位的数据，每个局部变量占用一个 Slot，而 double 和 long 这种 64 位的数据则需要两个 Slot 来存放。</p><p>局部变量表中存放的内容</p><ul><li>方法参数（包括实例方法中隐藏参数 this）</li><li>显式异常处理器的参数（catch 块所定义的异常）</li><li>方法体中递归的局部变量</li></ul><p>但是这里要注意的是：并非在方法中用到了多少个局部变量，就把这些局部变量所占的 Slot 的数量作为 max_locals 的值，因为局部变量表中的 Slot 是可以重用的，当代码执行超出了某一局部变量的<strong>作用域</strong>之后，这个 Slot 就可以被其它局部变量所使用了，所以 Javac 编译器会根据变量的作用域来分配 Slot 给各个变量使用，然后计算出 max_locals 的大小。</p><p><strong>方法体内部使用的 this 从何而来？</strong></p><p>大家注意到没有，定义在类中的非静态方法内部，可以使用 this 来访问当前的对象内的属性，它的实现方法是在 Javac 编译的时候把 this 添加到每个非静态方法的方法参数中，所以在方法内访问的 this 其实是本方法的参数。我们自己定义一个<code>void func()</code>的方法，使用 javap 命令查看其 Code 字节码，会发现这个 func 方法的<code>Args_size=1</code>,原因就在这，这个参数就是编译器默认为我们添加进去的<code>this</code></p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>这里将的 Exception 属性和 Code 属性是一级的。并不是 Code 属性中的异常属性表。</p><p>这里的 Exception 属性的作用是列举方法中通过<code>throws</code>关键字后面列举的异常。其结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exceptions_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 number_of_exceptions;</span><br><span class="line">    u2 exception_index_table[number_of_exceptions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 number_of_exceptions 项表示方法可能抛出的异常的数量。后面跟的是一个 exception_index_table，该数组中每个元素的长度均为 u2，因为该数组中保存的是一个指向常量池中 CONSTANT_Class_info 型的常量的索引，代表该异常的类型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(5)-分析class文件-常量池</title>
      <link href="/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-5-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-5-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常量池占据了 class 文件很大一部分数据，里面存放着各式各样的常量信息，包括数字和字符串常量、类和接口名、字段和方法名等。本节将详细介绍常量池和各种常量。</p></blockquote><h1 id="常量池在-class-文件中格式"><a href="#常量池在-class-文件中格式" class="headerlink" title="常量池在 class 文件中格式"></a>常量池在 class 文件中格式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">  ...</span><br><span class="line">  u2 constant_pool_count;<span class="comment">//常量池大小</span></span><br><span class="line">  cp_info constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">//常量池</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先读出常量池的大小，这是一个 u2 类型的数据，因此，这也表明了常量池最大为 2^16-1，如果你不是故意为难虚拟机，将工程中所有的代码都写到一个 class 文件中，相信这已经足够用了。</p><p>接下来根据这个大小,生成常量信息数组，注意：</p><ol><li>表头给出的常量池大小比实际大 1,所以这样的话,虽然可能生成了这么大的,但是 0 不使用,直接从 1 开始;</li><li>有效的常量池索引是 1~n–1。0 是无效索引，表示不指向任何常量</li><li>CONSTANT_Long_info 和 CONSTANT_Double_info 各占两个位置。也就是说，如果常量池中存在这两种常量，实际的常量数量比 n–1 还要少，这也导致了 1~n–1 的某些数也会变成无效索引。</li></ol><h1 id="常量池分类"><a href="#常量池分类" class="headerlink" title="常量池分类"></a>常量池分类</h1><p>常量池中的常量分为两类：字面量 和 符号引用</p><ul><li><p>字面量:文本字符串,声明为 final 的常量值等</p><ul><li><p>数字常量</p></li><li><p>字符串常量</p><p>​</p></li></ul></li><li><p>符号引用:Javac 在编译的时候,没有像 c 语言那样的”连接”这一步,而是在加载 class 文件的时候动态加载,拿到该符号引用指向的字符串,再使用反射,加载相应的类.</p><ul><li>类</li><li>接口</li><li>字段</li><li>方法</li></ul></li></ul><p>字面量是可以直接获取到其值的,而符号引用是通过索引直接或者间接指向 CONSTANT_Utf8_info 常量,然后拿到其字面量的;</p><h1 id="常量池具体类型"><a href="#常量池具体类型" class="headerlink" title="常量池具体类型"></a>常量池具体类型</h1><p>常量池具体可以分为以下 14 中类型，其基本结构都是由一个 u1 的 tag，后面跟一个具体类型的数据组成。</p><p><img src="http://oi8e3sh89.bkt.clouddn.com/image/jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%B8%B8%E9%87%8F%E9%A1%B9%E7%BB%93%E6%9E%84%E8%A1%A8.png" alt="常量池中的 14 种常量项的结构总表"></p><p>按照常量池的分类一节，将这 14 中分为两类</p><ul><li>字面量：<ul><li>CONSTANT_Integer</li><li>CONSTANT_Float</li><li>CONSTANT_Long</li><li>CONSTANT_Double</li><li>CONSTANT_Utf8</li></ul></li><li>符号引用：剩余的 10 种。</li></ul><p>下面分别从字面量大类和符号引用大类中各选两个有代表性的常量进行讲解。</p><h2 id="CONSTANT-Integer"><a href="#CONSTANT-Integer" class="headerlink" title="CONSTANT_Integer"></a>CONSTANT_Integer</h2><p>CONSTANT_Integer_info 使用 4 字节存储整数常量，其结构定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Integer_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u4 bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们在读到 tag 为 CONSTANT_Integer 时，接下来需要读取 4 字节的数据，从而拼接成这一个整数。</p><p>float，long，double 和 int 是类似的，读到对应的 tag，分别去读 4,8,8 字节的数据拼接起来，就是实际的数值。</p><h2 id="CONSTANT-Utf8"><a href="#CONSTANT-Utf8" class="headerlink" title="CONSTANT_Utf8"></a>CONSTANT_Utf8</h2><p>CONSTANT_Utf8 类型代表的是常量池中真正的字符串，其结构定义如下，读取到对应的 tag 后，后面是一个 u2 的数据，表明字符串的长度 len，接下来是长度为 len 的字节，代表真正的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 length;</span><br><span class="line">  u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里要注意的是，字符串在 class 文件中是以 MUTF-8（Modified UTF-8）方式编码的。MUTF-8 编码方式和 UTF-8 大致相同，但并不兼容。<br>差别有两点：一是 null 字符（代码点 U+0000）会被编码成 2 字节：0xC0、0x80；二是补充字符（Supplementary Characters，代码点大于U+FFFF 的 Unicode 字符）是按 UTF-16 拆分为代理对（Surrogate Pair）分别编码的。具体转换方法请看<a href="https://github.com/zachaxy/JVM/blob/master/Java/src/classfile/ConstantUtf8Info.java" target="_blank" rel="noopener">源码</a>，这里的转换方法是直接根据 java.io.DataInputStream.readUTF（）方法改写的。将读到的 byte 数组经过转码之后得到其代表的具体字符串。</p><p>常量类型中有一个 ConstantStringInfo，这个常量的名字迷惑性比较强，但是它里面并没有保存真正的字符串，而是保存了一个指向常量池中的索引，这个索引对应的常量类型一定是 CONSTANT_Utf8，这个常量中的字符串才是 ConstantStringInfo 中想表达的字符串。</p><h2 id="CONSTANT-Class"><a href="#CONSTANT-Class" class="headerlink" title="CONSTANT_Class"></a>CONSTANT_Class</h2><p>CONSTANT_Class_info 常量表示类或者接口的符号引用，指向是接口或者类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 name_index 是常量池索引，指向 <code>CONSTANT_Utf8_info</code> 常量。所以如果想真正的拿到当前 class 的全限定名，需要通过 name_index 先得到常量池中的 <code>CONSTANT_Utf8_info</code>，然后在获取其中的值。</p><h2 id="CONSTANT-NameAndType"><a href="#CONSTANT-NameAndType" class="headerlink" title="CONSTANT_NameAndType"></a>CONSTANT_NameAndType</h2><p>CONSTANT_NameAndType_info 给出字段或方法的名称和描述符。CONSTANT_Class_info 和 CONSTANT_NameAndType_info 加在一起可以唯一确定一个字段或者方法。其结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 name_index;</span><br><span class="line">  u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段或方法名由 name_index 给出，字段或方法的描述符由 descriptor_index 给出。name_index 和 descriptor_index 都是常量池索引，指向 CONSTANT_Utf8_info 常量。字段和方法名就是代码中出现的（或者编译器生成的）字段或方法的名字。</p><p>Java 虚拟机规范定义了一种简单的语法来描述字段和方法，可以根据下面的规则生成描述符。</p><ol><li><p>类型描述符。</p><ul><li>基本类型 byte、short、char、int、long、float 和 double 的描述符是单个字母，分别对应 B、S、C、I、J、F 和 D。注意，long 的描述符是 J 而不是 L。</li><li>引用类型的描述符是“L＋类的完全限定名＋分号”</li><li>数组类型的描述符是“[＋数组元素类型描述符”</li></ul></li><li><p>字段描述符就是字段的类型描述符。</p></li><li><p>方法描述符格式是：“（按参数顺序的参数类型描述符）+返回值类型描述符”，其中 void 返回值由单个字母 V 表示。</p></li></ol><h1 id="常量池类型总结"><a href="#常量池类型总结" class="headerlink" title="常量池类型总结"></a>常量池类型总结</h1><p>可以把常量池中的常量分为两类：字面量（literal）和符号引用（symbolic reference）。字面量包括数字常量和字符串常量，符号引用包括类和接口名、字段和方法信息等。除了字面量，其他常量都是通过索引指向 CONSTANT_Utf8_info 常量来获取其对应的字符串。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(4)-分析class文件</title>
      <link href="/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-4-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-4-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面一节已经介绍了如何获取了字节文件的字节流,那么在获取到字节流之后,就要读取并解析字节码了,这一节会介绍 class 文件的结构.本节的代码均在<strong>classfile包</strong>下,源码<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">在这里</a></p></blockquote><h1 id="class文件的基本结构"><a href="#class文件的基本结构" class="headerlink" title="class文件的基本结构"></a>class文件的基本结构</h1><p>构成 class 文件的基本数据单位是字节，可以把整个 class 文件当成一个字节流来处理。稍大一些的数据由连续多个字节构成，这些数据在class文件中以<strong>大端（big-endian）方式存储</strong>。为了描述class文件格式，Java虚拟机规范定义了<code>u1</code>、<code>u2</code>和<code>u4</code>三种数据类型来表示1、2和4字节<strong>无符号整数</strong></p><p>class文件中相同类型的多条数据一般按表（table）的形式存储（包括接下来要讲的常量池，属性表，接口索引集合，字段表集合，方法表集合）,表由表头和表项（item）构成，表头是 u2 或 u4 整数。假设表头是 n，后面就紧跟着 n 个表项数据。</p><p>class文件的结构描述:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">  u4 magic;<span class="comment">//魔数</span></span><br><span class="line">  u2 minor_version;<span class="comment">//次版本号</span></span><br><span class="line">  u2 major_version;<span class="comment">//主版本号</span></span><br><span class="line">  u2 constant_pool_count;<span class="comment">//常量池大小</span></span><br><span class="line">  cp_info constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">//常量池</span></span><br><span class="line">  u2 access_flags;<span class="comment">//类访问标志,表明class文件定义的是类还是接口，访问级别是public还是private，等</span></span><br><span class="line">  u2 this_class;<span class="comment">//</span></span><br><span class="line">  u2 super_class;<span class="comment">//</span></span><br><span class="line">  u2 interfaces_count;<span class="comment">//本类实现的接口数量</span></span><br><span class="line">  u2 interfaces[interfaces_count];<span class="comment">//实现的接口,存放在数组中</span></span><br><span class="line">  u2 fields_count;<span class="comment">//本来中含有字段数</span></span><br><span class="line">  field_info fields[fields_count];<span class="comment">//数组中存放这各个字段</span></span><br><span class="line">  u2 methods_count;<span class="comment">//本类中含有的方法数</span></span><br><span class="line">  method_info methods[methods_count];<span class="comment">//数组中存放着各个方法</span></span><br><span class="line">  u2 attributes_count;<span class="comment">//本类中含有的属性数量;</span></span><br><span class="line">  attribute_info attributes[attributes_count];<span class="comment">//数组中存放着各个属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解读-class-文件"><a href="#解读-class-文件" class="headerlink" title="解读 class 文件"></a>解读 class 文件</h1><p>接下来依次对 class 文件中的各个字段做一个介绍:</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><blockquote><p>很多文件格式都会规定满足该格式的文件必须以某几个固定字节开头，这几个字节主要起标识作用，叫作魔数（magic number）。例如 PDF 文件以 4 字节“%PDF”（0x25、0x50、0x44、0x46）开头，ZIP 文件以 2 字节“PK”（0x50、0x4B）开头。class 文件的魔数是“0xCAFEBABE”。<br>开头的四字节,起标识作用.Java 虚拟机规范规定，如果加载的 class 文件不符合要求的格式，Java 虚拟机实现就抛出<code>java.lang.ClassFormatError</code>异常。</p></blockquote><p>校验魔数使用的方法:<code>ClassFile#readAndCheckMagic()</code></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>次版本号(m):2 字节</li><li>主版本号(M):2 字节</li></ul><p>完整的版本号可以表示成“M.m”的形式。次版本号只在 J2SE 1.2 之前用过，从 1.2 开始基本上就没什么用了（都是 0）。主版本号在 J2SE 1.2 之前是 45，从 1.2 开始，每次有大的 Java 版本发布，都会加 1。 </p><p>校验版本使用的方法:<code>ClassFile#readAndCheckVersion()</code></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>版本号之后是常量池，但是由于常量池比较复杂，所以放到<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-5-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B8%B8%E9%87%8F%E6%B1%A0/">手写JVM系列(5)-分析class文件-常量池</a>中介绍。</p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池之后,紧接着是两字节的访问标志（access_flags），这个标示用来识别<strong>类或者接口</strong>的访问信息，两字节供 16 位，目前只定义了 8 位，没有用到的一律用 0 来填充，以备以后的拓展使用。</p><table><thead><tr><th align="left">标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td>0x0001</td><td>是否为 public 类型</td></tr><tr><td align="left">ACC_FINAL</td><td>0x0010</td><td>是否被声明为 final，只有类可设置</td></tr><tr><td align="left">ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的这个标志都必须为 1</td></tr><tr><td align="left">ACC_INTERFACE</td><td>0x0200</td><td>标示这是一个接口</td></tr><tr><td align="left">ACC_ABSTRACT</td><td>0x0400</td><td>是否为 abstract 类型，对于接口或者抽象类来说，此标志为真，其他类值为假</td></tr><tr><td align="left">ACC_SYNTHETIC</td><td>0x1000</td><td>标志这个类并非由用户代码产生的</td></tr><tr><td align="left">ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td align="left">ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h2 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h2><p>访问标志之后是 u2 类型的类索引数据，用于确定这个类的全限定名。该 u2 类型的索引值指向常量池中一个类型为 CONSTANT_Class_info 的类描述符常量,再通过 CONSTANT_Class_info 类型的常量中的索引值,可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p><p>类索引说白了就是一个指向常量池的索引值，那么直接用一个 int 值来表示即可。</p><h2 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h2><p>类索引之后是 u2 类型的父类索引数据，用于确定这个类的父类的全限定名。由于 Java 语言不允许多继承，所以其父类索引只有一个。除了 java.lang.Obect 之外,所有的 Java 类都有父类，所以除了 java.lang.Obect 的父类索引为 0，其余都不为 0。</p><p>该 u2 类型的索引值指向常量池中一个类型为 CONSTANT_Class_info 的类描述符常量,在通过 CONSTANT_Class_info 类型的常量中的索引值,可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p><p>同理，父类索引也是直接用一个 int 值来表示。</p><h2 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h2><p>父类索引之后是 u2 类型数据的接口索引集合。用来表述这个类实现了哪些接口。按照 implements 语句后面的接口顺序从前向后在接口索引集合中。</p><p>入口的第一项是 u2 类型的接口计数器，表示接口索引表的大小，如果该类没有实现接口，则计数器为 0，后面的接口索引表不占用任何字节。</p><p>因为有可能实现了多个接口，所以使用一个数组来盛放实习了接口在常量池中的索引值。</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>接口索引集合之后是字段表集合。虚拟机规范给出的字段结构定义如下，字段表用来描述类或接口中声明的变量。包括静态变量和非静态变量。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">  u2 access_flags;<span class="comment">//字段的访问修饰符</span></span><br><span class="line">  u2 name_index;<span class="comment">//常量池索引，代表字段的简单名称</span></span><br><span class="line">  u2 descriptor_index;<span class="comment">//常量池索引，代表字段描述符</span></span><br><span class="line">  u2 attributes_count;<span class="comment">//字段的额外附加属性数量</span></span><br><span class="line">  attribute_info attributes[attributes_count];<span class="comment">//字段的额外的附加属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段表中第一个字段 u2 是访问修饰符，这和前面讲的类访问符标志很相似，下表列举下字段的访问标志可选项：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为 volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否为 transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否是 enum 类型</td></tr></tbody></table><p>在实际情况中访问标志的使用时有限制的，比如 ACC_PUBLIC、ACC_PRIVATE 和 ACC_PROTECTED 三个标志只能选其一，ACC_FINAL 和 ACC_VOLATILE 只能选其一等，这些都是由 Java 本身的语言规范所决定的。</p><p>随着 access_flags 标志后的两项索引值是 name_index 和 descriptor_index。他们都是对常量池的引用，分别代表着字段的名称和描述。</p><p>字段的简单名称：不含类型的字段名称。 （eg：int  i,其简单名称为 i）</p><p>字段的描述符：用来描述字段的数据类型。(eg: int i,其描述符为 I)</p><p>​                                    描述符标识字符含义:</p><p><img src="http://i.imgur.com/G01YtQJ.png" alt></p><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述。如定义一个<code>String[][]</code>类型的二维数组，其描述符为：<code>[[Ljava/lang/String;</code></p><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。</p><p>在 descriptor_index 之后跟随着一个 u2 类型的数据 len，描述后面一个长度为 len 的属性表数组，这个数组用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。当然这个属性数组中保存的并不是真正的属性，而是属性表的索引。关于属性表，将在<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/">手写JVM系列(6)-分析class文件-属性表</a>中单独介绍。</p><p><strong>注：字段表集合中不会列出从超类或者父接口中继承而来的字段，但是有可能列出原来 Java 代码中不存在的字段，譬如在内部类中为了保持外部类的访问性，会自动添加一个指向外部类实例的字段。</strong></p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>字段表之后是方法表集合，和字段表集合的描述几乎是一样的（因此我在代码中对方法表和字段表使用同一个类 MemberInfo 来表示的），其结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">  u2 access_flags;<span class="comment">//方法的访问修饰符</span></span><br><span class="line">  u2 name_index;<span class="comment">//常量池索引，代表方法的简单名称</span></span><br><span class="line">  u2 descriptor_index;<span class="comment">//常量池索引，代表方法描述符</span></span><br><span class="line">  u2 attributes_count;<span class="comment">//方法的额外附加属性数量</span></span><br><span class="line">  attribute_info attributes[attributes_count];<span class="comment">//方法的额外的附加属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法表的第一个字段是访问修饰符，和字段表访问修饰符类似，不同的是：因为 volatile 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有这这两项，但是添加了 synchronized，native，strictfp，abstract 等可用来修饰方法的关键字，具体如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否为 protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否为 static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否为 final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否为 synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否是由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NAVIVE</td><td>0x0100</td><td>方法是否为 native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否为 abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x0800</td><td>方法是否为 strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生</td></tr></tbody></table><p>随着 access_flags 标志后的两项索引值是 name_index 和 descriptor_index。他们都是对常量池的引用，分别代表着方法的名称和描述。</p><p>方法的简单名称：不含类型和返回值的方法名称。</p><p>方法的描述符：描述方法的参数列表（数量，类型，顺序）和返回值。</p><p>以  eg：int func (int i，String s) 为例子,其简单名称为 func，方法描述符为：可参照上面的描述符标识字符含义图。</p><p>方法的简单名称：func</p><p>方法的描述符：(ILjava/lang/String)I</p><p>在 descriptor_index 之后跟随着一个 u2 类型的数据 len，描述后面一个长度为 len 的属性表数组，这个数组用于存储一些额外的信息，方法可以在属性表中描述零至多项的额外信息。和字段不同的是，字段只需要一个变量名和对应值就可以了，但是方法内部是包含代码的，这段代码在字节码中是如何表示的呢？答案是放在了方法属性表中的 Code 属性中，和字段表一样，方法表中的属性数组中并不保存真正的属性，而是保存的属性表的索引，关于属性表，将在<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/">手写JVM系列(6)-分析class文件-属性表</a>中单独介绍。</p><p><strong>注意：如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的信息。和字段表类似的是，方法表中可能会出现编译器会自动添加的方法，最典型的就是：类构造器<code>&lt;clinit&gt;</code>和实例构造器<code>&lt;init&gt;</code></strong></p><p>关于方法的重载</p><p> 重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名就是一个方法中各个参数在常量池中的字段符号引用集合，而返回值不会包含在特征签名中。但是如果两个方法具有相同的名称和特征签名，只是返回值不同，那么也可以合法共存于同一个 Class 文件中的。但是编译器是会阻止这一行为的，如果两个方法仅仅是返回值不同，编译器会直接报错。所以只能通过字节注入的方式，实现返回值不同的两个方法。</p><h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p>方法表集合之后是属性表，但是由于属性表比较复杂，所以放到<a href="https://zachaxy.github.io/2017/05/09/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-6-%E5%88%86%E6%9E%90class%E6%96%87%E4%BB%B6-%E5%B1%9E%E6%80%A7%E8%A1%A8/">手写JVM系列(6)-分析class文件-属性表</a>中介绍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(3)-搜索class文件</title>
      <link href="/2017/05/08/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-3-%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/08/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-3-%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节的目的是根据<code>-cp</code>命令指定的class路径以及后面的<code>ClassName</code>,找到对应的class文件,然后简单的打印出该 class 文件的字节码.完整源码<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">classpath包中</a></p></blockquote><a id="more"></a><h1 id="关于classpath"><a href="#关于classpath" class="headerlink" title="关于classpath"></a>关于classpath</h1><p><code>Java</code>虚拟机规范并没有规定虚拟机应该从哪里寻找类，因此不同的虚拟机实现可以采用不同的方法。Oracle的Java虚拟机实现根据类路径（class path）来搜索类。按照搜索的先后顺序,类路径分为以下三部分:</p><ul><li>启动类路径(bootstrap classpath):默认对应jre\lib目录，Java标准库(大部分在rt.jar里)位于该路径</li><li>扩展类路径(extension classpath):默认对应jre\lib\ext目录，使用Java扩展机制的类位于这个路径</li><li>用户类路径(user classpath):自己实现的类，以及第三方类库则位于用户类路径</li></ul><blockquote><p>这里特别说一下:用户类路径的<strong>默认值</strong>就是当前目录,这也是平时我们配置Java开发环境时,网上很多教程会说要添加一个<code>classpath</code>变量,并将其变量值设置为 <code>.</code> (表示当前路径),其实这个根本没有必要,因为虚拟机默认是在当前路径下寻找class文件的.所以在刚开始学习Java编程时,使用文本编辑器写代码,只需要配置一个<code>JAVA_HOME</code>即可,如果是用<code>IDE</code>,那么恐怕连<code>JAVA_HOME</code>都不需要,只要你安装了<code>JDK</code>,在<code>IDE</code>中配置其路径即可,至于<code>classpath</code>,都是由<code>IDE</code>的脚本自动写好的,不同的<code>IDE</code>有自己的路径,我们只需要在<code>IDE</code>中写好代码,点击运行即可.</p></blockquote><p>我们这里编写的<code>JVM</code>是脱离<code>IDE</code>的,所以不能指望<code>IDE</code>来帮我们寻找路径,经过上面的分析,一个想法就是配置一个<code>classpath</code>的环境变量,将所有的<code>class</code>文件都丢到这个路径下,但是这样做并不灵活,更好的办法是给<code>java</code>命令传递<code>-classpath</code>（或简写为-cp）选项。<code>-classpath/-cp</code>选项的优先级更高，可以覆盖<code>CLASSPATH环境变量</code>。</p><h2 id="java命令中的classpath-选项"><a href="#java命令中的classpath-选项" class="headerlink" title="java命令中的classpath 选项"></a>java命令中的classpath 选项</h2><p> <code>-classpath/-cp</code>选项既可以指定目录，也可以指定<code>JAR</code>文件或者<code>ZIP</code>文件</p><h2 id="添加指向JDK启动类路径"><a href="#添加指向JDK启动类路径" class="headerlink" title="添加指向JDK启动类路径"></a>添加指向JDK启动类路径</h2><p><code>Java</code>虚拟机将使用JDK的启动类路径来寻找和加载<code>Java</code>标准库中的类，因此需要某种方式指定<code>jre</code>目录的位置。命令行选项是个不错的选择，所以增加一个非标准选<code>-Xjre</code>选项。但是这一选项并不是必须的，目前已经实现了读取<code>JAVA_HOME</code>来寻找启动类路径的功能，所以<code>-Xjre</code>选项是在没有配置<code>JAVA_HOME</code>环境变量的情况下，使用的。如果本地机器上有该环境变量，则无需指定<code>-Xjre</code></p><p>注意这个选项的效果类似于<code>-classpath</code>,只不过这个选项是我们为了实现<code>JVM</code>自己添加的选项,并不是<code>java</code>自带的,其功能是指向<strong><code>JDK</code>启动类路径</strong>,而<code>-cp</code>是指定<strong>用户类路径</strong>.</p><p>但是不管怎样,最终的结果都是根据其执行的路径和后面所跟的类名,找到对应的<code>class</code>文件</p><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><blockquote><p>搜索class文件所实现的功能源码都在项目的<a href="https://github.com/zachaxy/JVM/tree/master/Java/src/classpath" target="_blank" rel="noopener">classpath包</a>下.</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>首先考虑一下在命令行使用时的可能的场景:</p><ol><li>直接指定路径,后面跟类名:<code>java -cp aaa/bbb/ccc  ddd  arg1  arg2</code></li><li>指定类所在的jar文件的路径,后面跟类名:<code>java -cp aaa/bbb/ccc.jar  ddd arg1  arg2</code></li><li>指定一个模糊路径,后面跟类名:<code>java -cp aaa/bbb/*  ddd  arg1  arg2</code></li><li>指定若干个路径,后面跟类名(指定的类存在指定的某一条路径中,如果都存在那么以第一条为准):<code>java -cp aaa1/bbb/ccc;aaa2/bbb/ccc;aaa3/bbb/ccc;  ddd  arg1  arg2</code></li></ol><h2 id="抽象类-Entry"><a href="#抽象类-Entry" class="headerlink" title="抽象类 Entry"></a>抽象类 Entry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//路径分隔符,在window下,使用 ; 分割开的  在Unix/Linux下使用: 分割开的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathListSeparator = System.getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Windows"</span>) ? <span class="string">";"</span> : <span class="string">":"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责寻找和加载class文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className class文件的相对路径，路径之间用斜线 / 分隔，文件名有.class后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回className的字符串表示形式;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">printClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法,根据传入的path的形式不同,</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 命令行得到的路径字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建具体的Entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Entry <span class="title">createEntry</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path.contains(pathListSeparator)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CompositeEntry(path, pathListSeparator);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.contains(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WildcardEntry(<span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.contains(<span class="string">".jar"</span>) || path.contains(<span class="string">".JAR"</span>) || path.contains(<span class="string">".zip"</span>) || path.contains(<span class="string">""</span> +</span><br><span class="line">                    <span class="string">".ZIP"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ZipJarEntry(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DirEntry(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体实现类"><a href="#具体实现类" class="headerlink" title="具体实现类"></a>具体实现类</h2><ul><li>DirEntry</li><li>ZipJarEntry</li><li>WildcardEntry</li><li>CompositeEntry</li></ul><p>这四个类是<code>Entry</code>的具体实现类,分别对应使用场景中的四种情况,下面会分析四种情况所要解决的问题,这里只贴出<code>DirEntry</code>的代码,先于篇幅原因,其它三种情况的具体实现,请查看本项目<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">源码</a></p><h3 id="DirEntry"><a href="#DirEntry" class="headerlink" title="DirEntry"></a>DirEntry</h3><p>这应该是最简单的一种使用场景了,构造方法中传入的字符串表示目录形式的类路径,这里拿到的直接就是指定的路径,那么先判断该路径是否存在,如果存在,那么和<code>className</code>拼接起来,使用<code>IO</code>流读取其中的字节码,并返回.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirEntry</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    String absDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirEntry</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (dir.exists()) &#123;</span><br><span class="line">            absDir = dir.getAbsolutePath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">byte</span>[] readClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(absDir, className);</span><br><span class="line">        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        out = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((size = in.read(temp)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(temp, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">printClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> absDir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZipJarEntry"><a href="#ZipJarEntry" class="headerlink" title="ZipJarEntry"></a>ZipJarEntry</h3><p>这种使用场景是指定了一个<code>zip文件</code>或者<code>jar包</code>的情况,那么需要解决的问题是如何拿到压缩文件中的文件,这里主要使用了<code>java.util.zip</code>包下的类来拿到文件,使用zipFile来读取文件和读取普通的文件夹类似,这里只管把zip文件当成文件夹就好</p><p>这里有一点要注意的是:</p><p>如果是<code>zip</code>文件,在获取<code>ZipEntry</code>的时候<code>ZipEntry ze = zipFile.getEntry(zipName + &quot;/&quot; + className)</code></p><p>如果是<code>jar</code>包,在获取<code>ZipEntry</code>的时候,<code>ZipEntry ze = zipFile.getEntry(className)</code></p><h3 id="WildcardEntry"><a href="#WildcardEntry" class="headerlink" title="WildcardEntry"></a>WildcardEntry</h3><p>这种使用场景是指定了一个形如<code>aa/bb/*</code>的路径,这种路径表明我们的<code>class</code>文件在<code>aa/bb/</code>路径下的<code>jar</code>包中,所以我们只要遍历该路径下的所有以<code>.jar</code>结尾的文件,然后调用<code>ZipJarEntry</code>的实现方法,即可以获得字节码.</p><h3 id="CompositeEntry"><a href="#CompositeEntry" class="headerlink" title="CompositeEntry"></a>CompositeEntry</h3><p>这种使用场景是包含多个路径的情况,(eg:a1/b1/c1;a2/b2/c2;a3/b3/c3),那么遇到这种情况,需要将字符串分割成不同的子串,注意分割符在不同的系统下是不同的,这里仅仅实现<code>windows</code>,其它情况下视为<code>unix</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathListSeparator = System.getProperty(<span class="string">"os.name"</span>).contains(<span class="string">"Windows"</span>) ? <span class="string">";"</span> : <span class="string">":"</span>;</span><br></pre></td></tr></table></figure><p>当然分成的子串分别对应一个<code>DirEntry</code>,再调用<code>DirEntry</code>的方法来获取字节码.</p><h2 id="classpath对外的统一使用接口"><a href="#classpath对外的统一使用接口" class="headerlink" title="classpath对外的统一使用接口"></a>classpath对外的统一使用接口</h2><p>上面我们已经实现了对于 classpath 路径的解析,这里在进行一步封装,提供一个对外的统一接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPath</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分别存放三种类路径</span></span><br><span class="line">    Entry bootClasspath;</span><br><span class="line">    Entry extClasspath;</span><br><span class="line">    Entry userClasspath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//parse()函数使用 -Xjre 选项解析启动类路径和扩展类路径</span></span><br><span class="line">    <span class="comment">// 使用-classpath/-cp选项解析用户类路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPath</span><span class="params">(String jreOption, String cpOption)</span> </span>&#123;</span><br><span class="line">        parseBootAndExtClasspath(jreOption);</span><br><span class="line">        parseUserClasspath(cpOption);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里参数传进来的是: C:\Program Files\Java\jdk1.8.0_20\jre</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parseBootAndExtClasspath</span><span class="params">(String jreOption)</span> </span>&#123;</span><br><span class="line">        String jreDir = getJreDir(jreOption);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可能出现的情况是: jre/lib/*</span></span><br><span class="line">        String jreLibPath = jreDir + File.separator + <span class="string">"lib"</span> + File.separator + <span class="string">"*"</span>;</span><br><span class="line">        bootClasspath = <span class="keyword">new</span> WildcardEntry(jreLibPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可能出现的情况是: jre/lib/ext/*</span></span><br><span class="line">        String jreExtPath = jreDir + File.separator + <span class="string">"lib"</span> + File.separator + <span class="string">"ext"</span> + File.separator + <span class="string">"*"</span>;</span><br><span class="line">        extClasspath = <span class="keyword">new</span> WildcardEntry(jreExtPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getJreDir</span><span class="params">(String jreOption)</span> </span>&#123;</span><br><span class="line">        File jreFile;</span><br><span class="line">        <span class="keyword">if</span> (jreOption != <span class="keyword">null</span> &amp;&amp; jreOption != <span class="string">""</span>) &#123;</span><br><span class="line">            jreFile = <span class="keyword">new</span> File(jreOption);</span><br><span class="line">            <span class="keyword">if</span> (jreFile.exists()) &#123;</span><br><span class="line">                <span class="keyword">return</span> jreOption;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jreFile = <span class="keyword">new</span> File(<span class="string">"jre"</span>);</span><br><span class="line">        <span class="keyword">if</span> (jreFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> jreFile.getAbsolutePath();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String java_home = System.getenv(<span class="string">"JAVA_HOME"</span>);</span><br><span class="line">        <span class="keyword">if</span> (java_home != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> java_home + File.separator + <span class="string">"jre"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can not find jre folder!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parseUserClasspath</span><span class="params">(String cpOption)</span> </span>&#123;</span><br><span class="line">        userClasspath = Entry.createEntry(cpOption);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readClass(String className) &#123;</span><br><span class="line">        className = className + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = bootClasspath.readClass(className);</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            data = extClasspath.readClass(className);</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            data = userClasspath.readClass(className);</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't find class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userClasspath.printClassName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法:传入解析到的 <code>-Xjre</code>来的路径和<code>-cp</code>的路径,当然在<code>Cmd</code>类中,这两个路径的初始值都是空字符串,而不是<code>null</code>,然后根据二者的值进行解析</p><p>之前也说过寻找 class 文件是由优先级的,依次是:<code>bootClasspath</code>-&gt; <code>extClasspath</code> -&gt;  <code>userClasspath</code>那么我们怎么实现这个加载顺序呢? </p><p>首先:在<code>Cmd</code>类中,这两个路径的初始值是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String XjreOption = <span class="string">""</span>;</span><br><span class="line">String cpOption = <span class="string">""</span>;</span><br></pre></td></tr></table></figure><p>这里优先使用用户输入的 -Xjre 选项作为 jre 目录。如果没有输入该选项，则在当前目录下寻找 jre 目录。如果找不到，尝试使用 JAVA_HOME 环境变量。最终返回<code>bootClasspath</code>和<code>extClasspath</code>.</p><p>然后再根据 <code>-cp</code>的值得到一个<code>userClasspath</code>,然后再根据这三个<code>Entry</code>的顺序来加载类文件,一旦加载到,直接返回。</p><p>最终,使用<code>readClass</code>()方法就可以返回我们要加载的类文件字节数组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(2)-参数解析</title>
      <link href="/2017/05/07/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-2-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/05/07/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-2-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这一章节开始<code>JVM</code>的编写,首先解决第一个问题,就是如何运行java程序，回想最开始学java时，写一个Hello.java的程序，使用<code>javac Hello.java</code>将源代码转换为class文件，然后使用<code>java Hello</code>运行程序。JVM是只认class文件的，如果想让JVM运行该Hello程序，就要通过java命令。本节将介绍java命令的常用方法，并实现java命令的解析。最终通过命令参数，读取对应的class数据。本节的代码均在<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">classpath包</a>下</p><a id="more"></a><h1 id="java-命令简介"><a href="#java-命令简介" class="headerlink" title="java 命令简介"></a>java 命令简介</h1><p><code>Java</code>应用程序需要一个入口点，这个入口点就是我们熟知的<code>main()</code>方法。如果一个类包含<code>public static void main(String[] args)</code>方法，这个类就可以用来启动Java应用程序，我们把这个类叫作主类.这个类是需要我们用命令行手动向JVM提供的;</p><p>Java命令一般有以下几种形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java [-options] class [args]</span><br><span class="line">java [-options] -jar jarfile [args]</span><br><span class="line">javaw [-options] class [args]</span><br><span class="line">javaw [-options] -jar jarfile [args]</span><br></pre></td></tr></table></figure><p>可以向 <code>java</code> 命令传递三组参数：选项、主类名（或者JAR文件名）<br>和 main() 方法参数。选项由减号<code>-</code>开头。通常，第一个非选项参数给出主类的完全限定名（fully qualified class name）。但是如果用户提供了<code>–jar</code>选项，第一个非选项参数表示<code>JAR</code>文件名，<code>java</code>命令必须从这个JAR文件中寻找主类。<code>javaw</code>命令和<code>java</code>命令几乎一样，唯一的差别在于，<code>javaw</code>命令不显示命令行窗口，因此特别适合用于启动<code>GUI</code>（图形用户界面）应用程序。</p><p>可以看到命令中都带有一个<code>[-options]</code>代表可选项, java命令行常用选项如下:</p><table><thead><tr><th align="center">选项</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">-version</td><td align="center">输出版本信息</td></tr><tr><td align="center">-?/-help</td><td align="center">输出帮助信息</td></tr><tr><td align="center">-cp/-classpath</td><td align="center">指定用户类路径</td></tr><tr><td align="center">-Dproperty=value</td><td align="center">设置Java系统属性</td></tr><tr><td align="center">-Xms&lt;size&gt;</td><td align="center">设置初始堆空间大小</td></tr><tr><td align="center">-Xmx&lt;size&gt;</td><td align="center">设置最大堆空间大小</td></tr><tr><td align="center">-Xss&lt;size&gt;</td><td align="center">设置线程栈空间大小</td></tr></tbody></table><p>当然,java命令行里提供的选项有很多,这里并不打算全部实现,只是挑几个比较重要的去实现.</p><p>接下来我打算实现以下几种命令:</p><ol><li><code>java -version</code></li><li><code>java -?</code></li><li><code>java -help</code></li><li><code>java -cp your/classpath yourClassName arg1 arg2 ...</code> </li><li><code>java -classpath your/classpath yourClassName arg1 arg2 ...</code></li></ol><h1 id="命令行解析功能编码"><a href="#命令行解析功能编码" class="headerlink" title="命令行解析功能编码"></a>命令行解析功能编码</h1><p>定义<code>Cmd</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cmd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isRightFmt = <span class="keyword">true</span>;     <span class="comment">//是否是正确的格式;</span></span><br><span class="line">    <span class="keyword">boolean</span> helpFlag;        <span class="comment">//是否是help 查看帮助</span></span><br><span class="line">    <span class="keyword">boolean</span> versionFlag;    <span class="comment">//是否是查看版本</span></span><br><span class="line">    String cpOption = <span class="string">""</span>;  <span class="comment">//classPath 的路径;          java -cp(-classpath) xxx</span></span><br><span class="line">    String clazz;  <span class="comment">//要编译的class 文件;</span></span><br><span class="line">    String[] args; <span class="comment">//执行clazz文件需要的参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cmd</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        parseCmd(strs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseCmd</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            isRightFmt = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先判断开头是不是 java ,如果连这个都不是,直接退出吧,提示正确的使用方法;</span></span><br><span class="line">        <span class="keyword">if</span> (!args[<span class="number">0</span>].equals(<span class="string">"java"</span>)) &#123;</span><br><span class="line">            isRightFmt = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-help"</span>) || args[<span class="number">1</span>].equals(<span class="string">"-?"</span>)) &#123;</span><br><span class="line">                helpFlag = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-version"</span>)) &#123;</span><br><span class="line">                versionFlag = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-cp"</span>) || args[<span class="number">1</span>].equals(<span class="string">"classpath"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果走到这一步,那么命令行必定是java -cp aa/bb test 11 22 33 的形式,所以应该至少有4项;</span></span><br><span class="line">                    isRightFmt = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                index = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.cpOption = args[<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-Xjre"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                 <span class="comment">//如果走到这一步,那么命令行必定是java -Xjre "C:\Program Files\Java\jdk1.8.0_20\jre" java.lang.Object 的形式,所以应该至少有4项;</span></span><br><span class="line">                    isRightFmt = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                index = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">this</span>.XjreOption = args[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.clazz = args[index - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">this</span>.args = <span class="keyword">new</span> String[args.length - index];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.args[i - index] = args[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//命令行格式错误,输出帮助信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Usage: java [-options] class [args...]\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了要解析的成员变量,注意这里包含了一个我们自己定义的<code>-Xjre</code>的选项,其具体含义见<a href>下一节</a>,其它选项含义参见注释,主要功能在<code>parseCmd()</code>方法中实现解析参数,根据对应的位置的选项,然后在主函数中去使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cmd cmd = <span class="keyword">new</span> Cmd(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cmd.isRightFmt) &#123;</span><br><span class="line">        cmd.printUsage();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd.versionFlag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"java version \"1.8.0_20\"\n"</span></span><br><span class="line">                    + <span class="string">"Java(TM) SE Runtime Environment (build 1.8.0_20-b26)\n"</span></span><br><span class="line">                    + <span class="string">"Java HotSpot(TM) 64-Bit Server VM (build 25.20-b23, mixed mode)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd.helpFlag || cmd.args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cmd.printUsage();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startJVM(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检验命令行格式是否正确,如果不正确,输出使用信息,如果是查看版本,输出版本信息,这里暂时提供了一个临时的字符串,此功能待后续实现.如果是查看帮助信息,同样也使出使用信息.其它情况,传递给一个方法<code>startJVM()</code>实现真正的开启虚拟机的逻辑,当然,此方法现在暂时内部是空实现,待后续实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JVM系列(1)-准备工作</title>
      <link href="/2017/05/06/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>/2017/05/06/%E6%89%8B%E5%86%99JVM%E7%B3%BB%E5%88%97-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章主要根据张秀宏老师的—— 《自己动手写 java 虚拟机》一书所做的笔记。该书实现了大部分 JVM 的功能，包括class文件解析、类加载、指令集、解释器、方法调用、数组和字符串的处理、异常处理等。这本书可以说是了解 Java 虚拟机最浅显易懂的书籍，随书提供了每个章节的代码，可以完美运行。但是这本书所附带的代码是用 go 语言书写的，如果想要看懂这本书的代码，首先要学会 go 语言的基本语法。这边博客记录了在阅读这本书之前的准备工作。我在练习中是根据张老师的代码用 Java 语言又实现了一遍。虽然用 Java 语言在实现一个自己的虚拟机，然后跑在自带的虚拟机上有点滑稽，但是重点还是了解虚拟机内部的基本原理。</p></blockquote><p>贴出张秀宏老师这本书的<a href="https://github.com/zxh0/jvmgo-book" target="_blank" rel="noopener">代码</a></p><a id="more"></a><p>如果你想跟着张秀宏老师的代码学习 JVM，那么下面的内容正是为你准备的。而如果你不想花时间学习另一门语言，那么可以参考我用 Java  实现的相同功能的<a href="https://github.com/zachaxy/JVM" target="_blank" rel="noopener">代码</a>，下面关于 go 的准备工作，可以忽略。</p><h1 id="安装-Go-开发环境"><a href="#安装-Go-开发环境" class="headerlink" title="安装 Go 开发环境"></a>安装 Go 开发环境</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://studygolang.com/dl" target="_blank" rel="noopener">Go 语言中文网</a>,这个下载速度快一点,下载最新版本之后一路<code>next</code>即可。</p><p>安装后，其实安装脚本已经自动帮我们把 Go 的安装路径添加到系统的环境变量中了， 查看系统环境变量，发现多了一个 <code>GOROOT</code>,其值为:<code>C:\go</code>(默认的安装路径)并且在<code>path</code>中,也自动把 <code>GOROOT\bin</code>添加了进来,因此直接打开命令行窗口,输入<code>go version</code>命令,就会输出安装的<code>go</code>的版本信息.</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>既然上一步安装<code>Go</code>时已经添加了环境变量了,那么接下来还要配置什么呢?</p><p><code>Go</code>希望我们把所有的代码都存在在同一个目录下,这就好比我们用<code>eclipse</code>时需要一个<code>workspace</code>,但是<code>eclipse</code>中的<code>workspace</code>可以有多个,而<code>Go</code>希望在一台主机上只有一个<code>workspace</code>,所以我们在这里要指定一个,例如<code>D:\workspace</code>,这个位置随意,文件夹名字随意,然后和<code>Go</code>进行关联,这里的关联方法就是在环境变量中,添加一个<code>GOPATH</code>,其值为刚刚设定的<code>D:\workspace</code>，其指明了除<code>GOROOT</code>之外的包含 Go 项目源代码和二进制文件的目录。这和<code>Java</code>中的 classpath 有些类似。当然你可以为<code>GOPATH</code>指定多个路径作为 workspace 的，但是这里还是建议一个就好。</p><p>接下来,在<code>D:\workspace</code>中添加一个目录<code>src</code>,这一步是必须的,所有的<code>Go</code>源代码都必须放在这个<code>src</code>目录下,那有人问,如果我有多个项目,所有源代码都放在这个目录下,怎么分清哪个源代码归属于哪个项目呢? 方法很简单,就是在<code>src</code>目录下再用不同的文件夹作为分隔,一个项目一个文件夹,自然就分开了;</p><h2 id="Go-语言的包结构"><a href="#Go-语言的包结构" class="headerlink" title="Go 语言的包结构"></a>Go 语言的包结构</h2><p><code>Go</code>语言以包为单位组织源代码，包可以嵌套，形成层次关系。书中编写的<code>Go</code>源文件全部放在<code>jvmgo</code>包中，其中每一章的源文件又分别放在自己的子包中。包层次目录结构有一个简单的对应关系，比如，第 1 章的代码在<code>jvmgo\ch01</code>目录下。除第 1 章以外，每一章都是先复制前一章代码，然后进行修改和完善。每一章的代码都是独立的，可以单独编译为一个可执行文件。</p><p>所形成的目录结构是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- D:\workspace</span><br><span class="line">- src</span><br><span class="line">- jvmgo</span><br><span class="line">- ch01</span><br><span class="line">- ch02</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之前也说过在 src 下，通过文件夹将不同的项目分割开。这里的例子是使用了个二级文件夹来区分的，每个项目都是放在<code>src/jvmgo/chXXX</code>下的，我们平时用一级目录当然也是可以的。那么其目录看起来应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- D:\workspace</span><br><span class="line">- src</span><br><span class="line">        - ch01</span><br><span class="line">        - ch02</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在每一个章节的 chX(go 的工程)中,都必须有一个<code>main</code>的包,这个包中的某个文件必须要包含一个<code>main</code>方法,因为这里每个文件夹被看做一个独立的工程。这个也很好理解,因为<code>Java</code>工程中,每个<code>Java</code>都可以有一个<code>public static void main(String[] args)</code>方法,这一点不足为奇,但是要注意的是,一旦你选定某个文件夹为一个项目(eg:jvmgo/ch05),并且使用<code>go install jvmgo\ch05</code></p><p>来生成一个 exe 文件, 那么这个目录下只能有一个<code>main</code>方法,不能有多个,否则就报错,类似于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\src\jvmgo\ch05\main2.go:3: main redeclared in this block</span><br><span class="line">        previous declaration at E:\workspace\src\jvmgo\ch05\main.go:8</span><br></pre></td></tr></table></figure><p>这是因为我在<code>main.go</code>中声明了一个<code>main</code>方法,又在<code>main2.go</code>中声明了一个<code>main</code>方法,所以就报了重复定义的错误。</p><p>还有一点要说明的是:可以直接在命令行输入<code>go install your/dir/name</code>系统会自动从<code>GOROOT/src</code>和<code>GOPATH/src</code>两个文件中找<code>your/dir/name</code>,而不用非进入到<code>GOPATH/src</code>路径下执行,而且如果<code>your/dir/name</code>在上述两个路径中均存在,那么前者优先级更高。</p><p>前面是使用<code>go install</code>命令生成可执行文件,但是如果你使用 <code>go run xxx.go</code>,那么不用保证 xxx.go 所在的包中<code>main</code>方法是唯一的,<code>main</code>包中其它文件也可以包含<code>main</code>方法,因为你运行的是单个文件,不过这只是自己平时练习时用,真正的项目都不会只有单个文件那么简单。</p><p>关于 Go 语言的包结构，下面两篇文章是不错的参考。</p><p><a href="http://blog.studygolang.com/2012/12/go%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">GO 项目的目录结构</a></p><p><a href="http://blog.csdn.net/zwqjoy/article/details/78788918" target="_blank" rel="noopener">GOROOT、GOPATH 和 project 目录说明</a></p><h1 id="快速入门-Go-语言"><a href="#快速入门-Go-语言" class="headerlink" title="快速入门 Go 语言"></a>快速入门 Go 语言</h1><p>因为本项目是想用<code>Java</code>实现书中的<code>JVM</code>项目,而书中所提供的是<code>Go</code>的源码,所以这里只要求能看懂<code>Go</code>的代码就可以,不必深入细节,相信看到这篇文章,想学习<code>JVM</code>,那么你的<code>Java</code>语言一定已经很熟练了,那么再快速学习一门语言是很快的,这里推荐<a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">Go 的官方教程</a>,一天就能看完,一定要有耐心。</p><p>上面提供的网站很不稳定,如果人品好的话,打开之后,赶紧一口气学完;运气差点肯定就打不开,没关系,这里有离线的版本,效果是一样的;</p><p>如果你已经安装好了<code>Go</code>的开发环境,那么直接打开命令行,输入<code>go tool tour</code>,浏览器就会自动打开一个页面,和在线版是一样,而且速度很快,你可以在右侧的代码区编写自己的代码并运行,这里代码的改动都是保存在本地的。</p><h1 id="go-常用命令"><a href="#go-常用命令" class="headerlink" title="go 常用命令"></a>go 常用命令</h1><ul><li>go build：编译出可执行文件，默认位置是和 main 方法所在的文件同目录下。</li><li>go run</li><li>go install：先执行<code>go build</code>命令，然后把最终编译成的可执行文件放到 GOPATH/bin 目录下。</li><li>go get：从指定源上面下载或者更新指定的代码和依赖(git clone)，并对他们进行编译和安装(go install)。</li></ul><p>依然用上面的例子来说明，例如我们下得到第 1 章（每一章都是一个单独的项目，相互之前没有关系）的一个可执行程序。</p><h2 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h2><p>构建编译由导入路径命名的包，以及它们的依赖关系，但它<strong>不会安装结果</strong></p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build [-o 输出名] [-i] [编译标记] [包名]</span><br></pre></td></tr></table></figure><p>其具体参数可以参考下面给出的参考链接，这里简单提一下 go build 的使用：</p><ol><li>当编译单个 main 包（文件），则生成可执行文件。</li><li>当编译单个或多个包非主包时（不包含 main 方法），只构建编译包，<strong>但丢弃生成的对象（.a）</strong>，<strong>仅用作检查包可以构建</strong>。</li><li>当编译包时，会自动忽略’_test.go’的测试文件。</li></ol><p>在命令行进入到<code>GOPATH/src/jvmgo/ch01</code>路径，执行：<code>go build main.go</code>，这样就会产生一个 main.exe 的可执行文件(默认情况下这个文件的名字为源文件名字去掉.go 后缀)，其与 main.go 在同一目录下。但是如果你真的这样做是无法生成 main.exe 可执行文件的，因为 build 命令构建单个文件时，虽然满足上面的条件 1，但是该文件中还使用了其它的文件中的方法。我们平时自己写一个简单的打印 helloword 的程序，所有代码都在一个文件中，用该命令是可以得到一个可执行文件的，但是如果我们的文件中依赖了其它文件中的方法，那么这时候就会报错，找不到 xxx 方法。所以这个命令平时使用的不是很多，用的最多的还是 install 命令。</p><p>参考：<a href="https://studygolang.com/articles/9463" target="_blank" rel="noopener">go build</a></p><h2 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h2><p>和 go build 类似，用来运行单个包含 main 方法的文件，其不生成 exe 文件，而是直接在命令行中运行该 main 文件。该命令常用来测试一些功能。</p><h2 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h2><p>在命令行任意路径下执行：<code>go install jvmgo/ch01</code>，这样就会在<code>GOPATH/bin</code>路径下产生一个 ch01.exe(install 命令以 main 方法所在的上一级目录名作为可执行程序名)的可执行文件。之前我们也提到了，必须在 GOPATH 路径下手动创建一个 src 的文件夹，并将我们写的所有的 go 文件都刚在该路径下，但执行了上面的 install 命令后，发现在 GOPATH 下除了 src，多出了两个文件夹。下面解释下这三个文件夹的作用。</p><ul><li><em>src</em> 包含项目的<em>源代码</em>文件；</li><li><em>pkg</em> 包含编译后生成的<em>包/库</em>文件；</li><li><em>bin</em> 包含编译后生成的<em>可执行</em>文件。</li></ul><p>这里特别要提一下的是 pkg 文件夹，其所放的内容是声明？我们知道大型项目中都不可能将所有代码都写在一个文件中的，而是要分包。那么各个包在 go install 时，会被编译成 xxx.a，类似 C 中的链接库。</p><p>但是 go install 也是有坑的，详见：<a href="https://studygolang.com/articles/8" target="_blank" rel="noopener">go install 的工作方式</a></p><h1 id="go-中的文件夹名和包名"><a href="#go-中的文件夹名和包名" class="headerlink" title="go 中的文件夹名和包名"></a>go 中的文件夹名和包名</h1><p>在 Java 中，类的包名和文件路径必须是对应的，而在 go 中则没有这种硬性规定，但是为了规范代码，Google 官方还是强烈建议我们写 go 代码时，文件夹名和包名保持一致。如果不一致，例如我们有一个文件夹，名为 A，其下有个 go 文件，自定义的包名是 B（<strong>每个子目录中只能存在一个 package，否则编译时会报错</strong>），那么在其它文件中使用该文件中的方法时，需要<code>import A</code>，而在代码中使用其方法时，则使用<code>B.func()</code>。所以这还是强烈建议，<strong>包名和所在文件夹名保持一致</strong>。</p><p>这里有一个特殊的包，叫做<code>main</code>，在执行 go install 命令时，如何找到整个程序的入口呢？光有 main 方法是不行的，包含 main 方法的 go 文件，其包名必须也是<code>main</code>，同时所有包名为<code>main</code>的 go 文件中，只能有一个 main 方法。只有满足以上所有要求，才会得到可执行文件，如果 main 方法不在<code>main</code>下，执行 go install ，go 会将所有包都视为 library，在 pkg 下生成对应的 xxx.a 文件，而不会有可执行文件。</p><h1 id="关于开发工具"><a href="#关于开发工具" class="headerlink" title="关于开发工具"></a>关于开发工具</h1><p>这里推荐使用 <code>Intellij idea + 插件</code>的方式,这里主要是为了看代码方便,可以很方便的实现方法之间的跳转,</p><h2 id="go-插件安装"><a href="#go-插件安装" class="headerlink" title="go 插件安装"></a>go 插件安装</h2><p>打开<code>idea</code>的<code>setting-&gt;plugin</code>,搜索<code>go</code>,点击下方的<code>Browse repositorise</code>,找到<code>Go language(golang.org)support plugin</code>,<a href="https://github.com/go-lang-plugin-org" target="_blank" rel="noopener">官网地址</a>,安装后重启编译器插件才可以用。</p><p>其实用 idea+插件的方式，查看 go 的代码已经很舒服了，不用额外再配置其他 ide，毕竟我们的主要精力还是能看懂 go 的代码，并不写任何 go 代码。</p><p><strong>注意：安装 go 插件，需要 idea 的版本为2016.2，我在开发中使用的 idea 为 COMMUNITY  2016.2.5，最新版本的 idea 无法安装 go 插件！</strong></p><h2 id="bytecode-插件安装"><a href="#bytecode-插件安装" class="headerlink" title="bytecode 插件安装"></a>bytecode 插件安装</h2><p>既然虚拟机是和 class 文件打交道的，就免不了查看字节码的内容，这里提供一个好用的查看字节码的插件——<code>jclasslib Bytecode viewer</code>，安装方式同 go 插件的安装。</p><p>使用方法：首先要单独编译<strong>当前窗口</strong>的 java 文件，使其生成 class 文件，然后在编译器的<code>View</code>中选择<code>show Bytecode with jclasslib</code>。</p><h2 id="用-idea-看源码"><a href="#用-idea-看源码" class="headerlink" title="用 idea 看源码"></a>用 idea 看源码</h2><p>为了配合<code>idea</code>阅读《自己动手写 java 虚拟机》的源码,这里最简单的做法:</p><ol><li>新建一个 go 项目,命名为<code>jvmgo</code>,路径为<code>GOPATH/src</code></li><li>需要看哪一章的源码,就把作者对应的 <code>jvmgo/</code>文件夹下的<code>ch01</code>(以第一章为例),复制到上一步新建的项目路径下,最终结果应该是:<code>GOPATH/src/jvmgo/ch01</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配--RK算法</title>
      <link href="/2017/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-RK%E7%AE%97%E6%B3%95/"/>
      <url>/2017/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-RK%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种哈希函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，理论匹配时间是O((n-m+1)m)。这里要乘以m是考虑到对hash值相同的进行一次校验;</p><p>由于hash冲突的存在，当hash值相同的时候，还是需要朴素算法来进行必要的比较,所以时间复杂性为O（m<em>n）。但是*</em>现实中**hash冲突出现的可能性不是很大，所以相比较而言，复杂性还是比较小的，仅仅为O(m+n)</p></blockquote><h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><ul><li>待匹配的字符串<code>s</code></li><li>待匹配的子串<code>m</code></li><li><code>m</code>的长度为<code>M</code></li><li><code>R</code>进制:如果字符串中所有的字符都是小写英文字母,那么就是26进制,如果都是数字,那么就是10进制,如果没有说明,那么就以<code>ASCII表</code>256进制来计算</li><li><code>Q</code>随机的大素数,在不溢出的情况下选择一个尽可能大的素数</li><li><code>RM</code>这里并不是<code>R*M</code>而是 $R^{M-1}$%Q</li><li><code>hash()</code>函数,对<code>m</code>进行运算,得到目标hash值</li><li><code>targetHash = hash(m)</code></li></ul><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>这里以下面参数为例,讲解RK算法的基本思想;</p><ul><li><code>s=3141592653589793</code></li><li><code>m=26535</code></li><li><code>M=5</code></li><li><code>Q=997</code></li><li><code>hash(x) = x % Q</code></li><li><code>targetHash = 26535 % 997 = 613</code></li></ul><p>那么在接下来的匹配中可以得出</p><table><thead><tr><th align="center">i</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th><th align="center">11</th><th align="center">12</th><th align="center">13</th></tr></thead><tbody><tr><td align="center">0</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">508</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">201</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">715</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">971</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">442</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">929</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">613  (匹配)</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><ol><li>从<code>s</code>第0位开始,取前<code>M</code>位,用<code>hash()</code>方法计算出其值与<code>targetHash</code>进行对比</li><li>如果相等,那么这<code>M</code>位可能会匹配上,</li><li>如果不相等,那么<code>s</code>后移一位,继续计算相应<code>M</code>为的<code>hash()</code>,进行对比</li></ol><p>以上过程只是对RK算法的一个简单描述,注意到每次也是后移一位,计算<code>hash()</code>值,因为我们的s中都是数字,可以很方便的来计算出<code>hash</code>值,如果是字母的话,计算hash值可能就不是那么容易了,这也是RK算法要解决的核心问题,因为我们大部分情况下面对的都是字符串,我们需要将字符串转换为对应的数值,如何转换呢?那就是接下来用到的散列函数</p><h1 id="计算散列函数"><a href="#计算散列函数" class="headerlink" title="计算散列函数"></a>计算散列函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      h = (R * h + key.charAt(i)) % Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的目标是计算一次<code>m</code>的<code>targetHash</code>,计算一次<code>s</code>的前<code>M</code>位的<code>hash</code>,仅此两次调用,那么我们不是每次都要将<code>s</code>的游标后移一位,在计算其hash值吗?这就是RK算法巧妙的地方,如果当前不匹配,那么后移一位,其hash值</p><p>*<em>注意: *</em>再次强调<code>Q</code>一定要是一个尽可能大的素数,以减少冲突;</p><h1 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h1><p>RK算法的基础是对于所有位置<code>i</code>,不调用hash()方法,高效计算文本中<code>i+1,</code></p><p>我们用 $t_i$表示<code>s.charAt(i)</code>,那么<code>s</code>其实于<code>i</code>,长度为<code>M</code>的数值(注意此处并不是hash值)为:</p><p>$$x_i = t_iR^{M-1}+t_{i+1}R^{M-2}+…+t_{i+M-1}R^0$$              <code>(1)</code></p><p>$h(x_i)=x_i mod Q$                                    <code>(2)</code></p><p>$$x_{i+1}=(x_i-t_iR^{M-1})R+t_{i+M}$$                    <code>(3)</code></p><p><code>(a + b) % c = ((a % c)+(b % c)) % c</code>                <code>(4)</code></p><p><code>(a - b) % c = ((a % c)-(b % c)) % c</code>                <code>(5)</code></p><p><code>(a * b) % c = ((a % c)*(b % c)) % c</code>                <code>(6)</code></p><p>基于以上公式,可以方便的得到<code>search()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回匹配成功的索引;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = txt.length();</span><br><span class="line">    <span class="keyword">long</span> txtHash = hash(txt, M); <span class="comment">//计算txt文本的前M位的hash值</span></span><br><span class="line">    <span class="keyword">if</span> (targetHash == txtHash &amp;&amp; check(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//在开始位置处就匹配成功;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">//+Q并不影响对其本质的区别;因为 Q % Q = 0</span></span><br><span class="line">        txtHash = (txtHash + Q - RM * txt.charAt(i - M) % Q) % Q;  <span class="comment">//是为了防止出现负数吧...</span></span><br><span class="line">        txtHash = (txtHash * R + txt.charAt(i)) % Q;</span><br><span class="line">        <span class="keyword">if</span> (targetHash == txtHash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(i - M + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: zhangxin</span></span><br><span class="line"><span class="comment"> * Time: 2017/4/12 0012.</span></span><br><span class="line"><span class="comment"> * Desc: 基于指纹的字符匹配算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> targetHash;  <span class="comment">//模拟字符串的散列值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;          <span class="comment">//模拟字符串的长度;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Q;          <span class="comment">//大素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> R = <span class="number">256</span>;    <span class="comment">//字母表大小;这里最好设置为可以定制的吧;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> RM;        <span class="comment">//R^(M-1)%Q;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = pat.length();</span><br><span class="line">        Q = <span class="number">997</span>; <span class="comment">//或者你自己写一个随机的素数表;</span></span><br><span class="line">        RM = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里是从1开始,到M-1,[1,M-1],一共M-1个数;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">            RM = (R * RM) % Q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targetHash = hash(pat, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            res = (R * res + key.charAt(i)) % Q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法一般不用,从概率上来说,不用再check,如果你不放心,可以添加上字符逐一对比的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回匹配成功的索引;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="keyword">long</span> txtHash = hash(txt, M); <span class="comment">//计算txt文本的前M位的hash值</span></span><br><span class="line">        <span class="keyword">if</span> (targetHash == txtHash &amp;&amp; check(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//在开始位置处就匹配成功;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//+Q并不影响对其本质的区别; Q%Q=0</span></span><br><span class="line">            txtHash = (txtHash + Q - RM * txt.charAt(i - M) % Q) % Q;  <span class="comment">//是为了防止出现负数吧...</span></span><br><span class="line">            txtHash = (txtHash * R + txt.charAt(i)) % Q;</span><br><span class="line">            <span class="keyword">if</span> (targetHash == txtHash) &#123;</span><br><span class="line">                <span class="keyword">if</span> (check(i - M + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点:</p><ol><li>它可以用来检测抄袭，因为它能够处理多模式匹配(多个不同长度的<code>m</code>)；</li><li>虽然在理论上并不比暴力匹配法更优，但在实际应用中它的复杂度仅为O(n+m);</li><li>如果能够选择一个好的哈希函数，它的效率将会很高，而且也易于实现。</li></ol><p>缺点:</p><ol><li>有许多字符串匹配算法的复杂度小于O(n+m)；</li><li>有时候它和暴力匹配法一样慢，并且它需要额外空间。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配--KMP算法</title>
      <link href="/2017/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2017/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Knuth-Morris-Pratt 字符串查找算法</strong>（常简称为“<strong>KMP算法</strong>”）可在一个主“文本字符串”<code>s</code>内查找一个“词”<code>m</code>的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。</p></blockquote><h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><p>待查找的字符串:s<br>要匹配的字符串:m    </p><h1 id="普通的做法"><a href="#普通的做法" class="headerlink" title="普通的做法"></a>普通的做法</h1><p>字符串匹配算法最常规的思路是在s中一个字符一个字符的与m中的第一个字符比较,匹配了说明找到了源头(i)这个i接下来很可能会与m完全匹配的,再比较各自接下来一个字符,如果匹配不上,说明上次找的i不是我们想要的源头,接着怎么办?从i+1开始,看i+1是否有可能是这个源头.</p><h2 id="普通做法的缺点"><a href="#普通做法的缺点" class="headerlink" title="普通做法的缺点"></a>普通做法的缺点</h2><p>时间复杂度高,造成这个的原因是因为在匹配过程中,虽然没有完全匹配上.但是很可能已经匹配了一部分,已经匹配上了的这一小部分并没有被充分利用起来;</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><blockquote><p>充分利用在匹配过程中,没有完全匹配上但是已经匹配上一部分的资源.</p></blockquote><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念:"></a>几个概念:</h2><p>下面的概念都是针对一个字符串而言的,eg:一个字符串为abc</p><p>前缀:a,ab,包含首字符,但不包含末字符的字符串;<br>后缀:c,bc,包含末字符,但不包含首字符的字符串;       </p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="构造辅助数组"><a href="#构造辅助数组" class="headerlink" title="构造辅助数组"></a>构造辅助数组</h3><ol><li>拿到m字符串,生成一个与m等长的整型数组next[]</li><li>初始化next[0] = -1,next[1] = 0</li><li>从2开始遍历m,next[i]的值就是 字符串 m[0~i-1] 的相同的最长前缀和最长后缀的长度</li></ol><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><ul><li>开始匹配,定义两个游标,si和mi,初始均为0</li><li>如果能匹配上,si++,mi++</li><li>如果匹配不上,注意此时的隐含条件是mi之前的已经匹配上了,我们想下次移动的时候不是把m移动到上次匹配s的起止位置之后的一个字符处,而是看m[0~i-1]中的前缀和后缀是不是有一样的地方,这样就可以重复利用,这不就是next数组的作用吗?因此查看此时的next数组,将mi = next[mi];接下来当然从si和mi继续匹配,看能否匹配了</li><li>如果next[mi] == -1,表明连m的第一个字符都匹配不上,那么只能si++;</li></ul><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: zhangxin</span></span><br><span class="line"><span class="comment"> * Time: 2016/12/16 0016.</span></span><br><span class="line"><span class="comment"> * Desc:KMP算法;</span></span><br><span class="line"><span class="comment"> * 核心是next[]数组的计算,以及在匹配过程中如何使用next,感性上的理解是需要移动数组的,但在实际的使用中时只需要修改si与mi即可;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndexOf</span><span class="params">(String s, String m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || m == <span class="keyword">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ms = m.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> si = <span class="number">0</span>; <span class="comment">//str中当前i的位置;其实真正的游标是si,你想匹配字符串的时候,主标是s掌控的;</span></span><br><span class="line">        <span class="keyword">int</span> mi = <span class="number">0</span>;<span class="comment">//match中当前i的位置;</span></span><br><span class="line">        <span class="keyword">int</span>[] next = getNextArray(ms);</span><br><span class="line">        <span class="keyword">while</span> (si &lt; ss.length &amp;&amp; mi &lt; ms.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ss[si] == ms[mi]) &#123;</span><br><span class="line">                <span class="comment">//当前字符能匹配上,si,mi都前移一位;</span></span><br><span class="line">                si++;</span><br><span class="line">                mi++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[mi] == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//匹配不上,mi=0,第一个字符都匹配不上,si前移一位;</span></span><br><span class="line">                si++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//前面还是有部分能匹配上的,mi=next[mi];si不变;</span></span><br><span class="line">                mi = next[mi];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mi == ms.length ? si - mi : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 获取nextArr数组</span></span><br><span class="line"><span class="comment">     * nextArr[0] = -1;因为如果第一个字符都匹配不上,那么match整体后移1位;</span></span><br><span class="line"><span class="comment">     * nextArr[1] = 0;因为第一个字符没有前缀也没有后缀,肯定是0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ms match字符串对应的字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray(<span class="keyword">char</span>[] ms) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[ms.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">2</span>; <span class="comment">//当前位置;</span></span><br><span class="line">        <span class="keyword">int</span> cn = <span class="number">0</span>; <span class="comment">//前缀开始匹配的位置;</span></span><br><span class="line">        <span class="keyword">while</span> (pos &lt; next.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[pos - <span class="number">1</span>] == ms[cn]) &#123;</span><br><span class="line">                next[pos++] = ++cn;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//遇到某个字符匹配不上了,那么直接下次不能再用之前的了,而是将cn置0</span></span><br><span class="line">                <span class="comment">// next先不设置,cn==0后,再去进入循环,从头匹配;也许能匹配的上;</span></span><br><span class="line">                <span class="comment">//cn = next[cn]; 不看这一句,删掉;</span></span><br><span class="line">                cn = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[pos++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"abcabcababaccc"</span>;</span><br><span class="line">        String match = <span class="string">"ababa"</span>;</span><br><span class="line">        <span class="comment">/*str = "abxxxabwwab";</span></span><br><span class="line"><span class="comment">        match = "xab";*/</span></span><br><span class="line">        System.out.println(getIndexOf(str, match));</span><br><span class="line">        System.out.println(str.indexOf(match));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-数组深入分析"><a href="#next-数组深入分析" class="headerlink" title="next[]数组深入分析"></a>next[]数组深入分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">分析 match = &quot;ababa&quot;  =&gt; next[5]</span><br><span class="line">next[i]的含义:match[0~i-1]组成的字符串,最长前缀(不包含最后一个字符)和最长后缀(不包含第一个字符)匹配上的长度;</span><br><span class="line">初始化:</span><br><span class="line">next[0] = -1;显然match[0~0-1]无意义,令其等于-1,代表第一个字符都匹配不上,match直接右移一位</span><br><span class="line">next[1] = 0;显然match[0~1-1]就是match[0],只有一个字符,没有前缀也没有后缀;所以next[1]=0;</span><br><span class="line">接下来开始匹配了,match[2]这个位置前面已经有两个字符了,可能前两个字符相等,那么next[2]=1,不相等,next[2]=0</span><br><span class="line">可以发现的是,第一次匹配一定是match[i-1]和match[0]匹配;接下来如果再能匹配,因为match[i-1]和match[0]已匹配,match[i]和match[1]也能匹配了</span><br><span class="line"></span><br><span class="line">ababa的next数组;</span><br><span class="line">    0 1 2 3 4</span><br><span class="line">    a b a b a</span><br><span class="line">   -1 0 0 1 2</span><br><span class="line"></span><br><span class="line">接下来拿ababcccc与ababe来匹配,ababe的next数组为&#123;-1,0,0,1,2&#125;,和上面的ababa是一样的;</span><br><span class="line">一开始是可以匹配的,当si = mi = 4 时,匹配不上了,这个时候的隐含条件就是m中的[0~mi-1]是都能匹配上的</span><br><span class="line">这时候找next[mi],next[4]=2,说明mi之前的字符串中前两个和最后两个可以匹配上,所以下次比的时候,si = 4,mi = 2,从m[3]字符处开始匹配;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/2017/04/13/Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/2017/04/13/Dijkstra%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Dijkstra算法,给出一个邻接矩阵和一个起始点,返回这个其实点到邻接矩阵中各个点的最短距离</p><p>使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树（一个节点到其他所有节点的最短路径）。<br>该算法常用于路由算法或者作为其他图算法的一个子模块。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p></blockquote><hr><p>基本用法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> M = Integer.MAX_VALUE; <span class="comment">//此路不通</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//邻接矩阵,单向连接;</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">10</span>, M, <span class="number">30</span>, <span class="number">100</span>&#125;,</span><br><span class="line">                &#123;M, <span class="number">0</span>, <span class="number">50</span>, M, M&#125;,</span><br><span class="line">                &#123;M, M, <span class="number">0</span>, M, <span class="number">10</span>&#125;,</span><br><span class="line">                &#123;M, M, <span class="number">20</span>, <span class="number">0</span>, <span class="number">60</span>&#125;,</span><br><span class="line">                &#123;M, M, M, M, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置起始点,这里将0设置为起始点,接下来要做的动作是寻找整个图中所有点距离0最近的距离;</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最短路径的数组,长度为0,保存了0到n个点的最短距离,当然第一个值是0到0的距离,距离为0;</span></span><br><span class="line">        <span class="keyword">int</span>[] shortPath = dijkstra(weight, start);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印0到各点最近的距离;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortPath.length; i++)</span><br><span class="line">            System.out.println(<span class="string">"从"</span> + start + <span class="string">"出发到"</span> + i + <span class="string">"的最短距离为："</span> + shortPath[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 有向图的权重矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start  一个起点编号start（从0编号，顶点存在数组中）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个int[] 数组，表示从start到它的最短路径长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span>[][] weight, <span class="keyword">int</span> start) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = weight.length;         <span class="comment">//顶点个数</span></span><br><span class="line">        <span class="keyword">int</span>[] shortPath = <span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">//保存start到其他各点的最短路径,最后作为返回值被返回;</span></span><br><span class="line">        String[] path = <span class="keyword">new</span> String[n];  <span class="comment">//保存start到其他各点最短路径的字符串描述;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化从start到各个节点的最优路径图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            path[i] = start + <span class="string">"--&gt;"</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//或者用一个boolean类型的数组表示,是否已经访问过;</span></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];   <span class="comment">//标记当前该顶点的最短路径是否已经求出,1表示已求出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化，第一个顶点已经求出</span></span><br><span class="line">        shortPath[start] = <span class="number">0</span>;</span><br><span class="line">        visited[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//最外层循环,一共n个节点,要找到start节点到其他n-1个节点的最短距离,因此这里需要循环n-1次;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">1</span>; count &lt; n; count++) &#123;   <span class="comment">//要加入n-1个顶点</span></span><br><span class="line">            <span class="keyword">int</span> k = -<span class="number">1</span>;        <span class="comment">//选出一个距离初始顶点start最近的未标记顶点,暂时记为k;</span></span><br><span class="line">            <span class="keyword">int</span> dmin = Integer.MAX_VALUE;  <span class="comment">//临时距离;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//内循环找到一个距离start最近的点;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; weight[start][i] &lt; dmin) &#123;</span><br><span class="line">                    dmin = weight[start][i];</span><br><span class="line">                    k = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//至此已经找到了一个距离start的最短点;</span></span><br><span class="line">            <span class="comment">//将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin</span></span><br><span class="line">            shortPath[k] = dmin;</span><br><span class="line">            visited[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以k为中间点，修正从start到未访问各点的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">//start不能到i;但是start可以到k,k可以到i,</span></span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; weight[k][i] != M &amp;&amp; weight[start][k] + weight[k][i] &lt; weight[start][i]) &#123;</span><br><span class="line">                    weight[start][i] = weight[start][k] + weight[k][i];</span><br><span class="line">                    path[i] = path[k] + <span class="string">"--&gt;"</span> + i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印最短路径们;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"从"</span> + start + <span class="string">"出发到"</span> + i + <span class="string">"的最短路径为："</span> + path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"====================================="</span>);</span><br><span class="line">        <span class="keyword">return</span> shortPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进:基本用法中为了更好的展示,使用了邻接矩阵,这需要更大的内存空间,一个改进方法是使用邻接链表;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Vertex&gt; nodes = <span class="keyword">new</span> HashMap&lt;String, Vertex&gt;();</span><br><span class="line">    nodes.put(<span class="string">"a"</span>, <span class="keyword">new</span> Vertex(<span class="string">"a"</span>));</span><br><span class="line">    nodes.put(<span class="string">"b"</span>, <span class="keyword">new</span> Vertex(<span class="string">"b"</span>));</span><br><span class="line">    nodes.put(<span class="string">"c"</span>, <span class="keyword">new</span> Vertex(<span class="string">"c"</span>));</span><br><span class="line">    nodes.put(<span class="string">"d"</span>, <span class="keyword">new</span> Vertex(<span class="string">"d"</span>));</span><br><span class="line">    nodes.put(<span class="string">"e"</span>, <span class="keyword">new</span> Vertex(<span class="string">"e"</span>));</span><br><span class="line"></span><br><span class="line">    nodes.get(<span class="string">"a"</span>).map.put(nodes.get(<span class="string">"b"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"a"</span>), nodes.get(<span class="string">"b"</span>), <span class="number">10</span>));</span><br><span class="line">    nodes.get(<span class="string">"a"</span>).map.put(nodes.get(<span class="string">"d"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"a"</span>), nodes.get(<span class="string">"d"</span>), <span class="number">30</span>));</span><br><span class="line">    nodes.get(<span class="string">"a"</span>).map.put(nodes.get(<span class="string">"e"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"a"</span>), nodes.get(<span class="string">"e"</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    nodes.get(<span class="string">"b"</span>).map.put(nodes.get(<span class="string">"c"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"b"</span>), nodes.get(<span class="string">"c"</span>), <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    nodes.get(<span class="string">"c"</span>).map.put(nodes.get(<span class="string">"e"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"c"</span>), nodes.get(<span class="string">"e"</span>), <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    nodes.get(<span class="string">"d"</span>).map.put(nodes.get(<span class="string">"c"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"d"</span>), nodes.get(<span class="string">"c"</span>), <span class="number">20</span>));</span><br><span class="line">    nodes.get(<span class="string">"d"</span>).map.put(nodes.get(<span class="string">"e"</span>), <span class="keyword">new</span> Edge(nodes.get(<span class="string">"d"</span>), nodes.get(<span class="string">"e"</span>), <span class="number">60</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点,没有什么特别之处,和一个String的类型一样;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    HashMap&lt;Vertex, Edge&gt; map = <span class="keyword">new</span> HashMap&lt;Vertex, Edge&gt;();  <span class="comment">//key:以Vertex为end边的节点,当前节点到key的距离;</span></span><br><span class="line"></span><br><span class="line">    Vertex(String key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边,包含了一个起始和一个终止节点,已经一个边的长度;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    Vertex start;</span><br><span class="line">    Vertex end;</span><br><span class="line">    <span class="keyword">int</span> Len;</span><br><span class="line">    <span class="keyword">boolean</span> used;</span><br><span class="line"></span><br><span class="line">    Edge(Vertex start, Vertex end, <span class="keyword">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.Len = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先算法</title>
      <link href="/2017/04/10/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/"/>
      <url>/2017/04/10/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>BFS（Breadth First Search）广度优先遍历，从图的某一结点出发，首先依次访问该结点的所有邻接顶点 Vi1, Vi2, …, Vin 再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。</p></blockquote><p>广度优先一般使用队列来完成,不需要使用递归,相对来说比较简单,接下来是一个广度优先算法的一个模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="comment">// 记录顶点是否被访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] flag;</span><br><span class="line"><span class="comment">// 顶点</span></span><br><span class="line"><span class="keyword">private</span> String[] vertexs = &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span> &#125;;</span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] edges = &#123; </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的广度遍历操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[number];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">            flag[i] = <span class="keyword">true</span>;</span><br><span class="line">            System.out.print(vertexs[i] + <span class="string">" "</span>);</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; number; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (edges[j][k] == <span class="number">1</span> &amp;&amp; flag[k] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        flag[k] = <span class="keyword">true</span>;</span><br><span class="line">                        System.out.print(vertexs[k] + <span class="string">" "</span>);</span><br><span class="line">                        queue.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是用九个顶点的图来作为示例,首先,创建一个标志数组,用来标示该顶点有没有被访问过,接下来,从第一个顶点开始(其实任意一个顶点都可以),将该顶点加入到队列中,接下来开启循环,拿出队列头部的一个节点,如果该队列有邻接的节点,那么将邻接节点添加到队列中,直到有所节点都被访问完为止.</p><blockquote><p>运行结果:</p><p>A-&gt;B-&gt;F-&gt;G-&gt;C-&gt;I-&gt;E-&gt;D-&gt;H</p></blockquote><p>广度优先遍历一个典型的题目就是按照二叉树的层次打印节点的值.</p><p>当然也可以解决最短路径的问题,如果只要求输出最短路径的长度,这个时间复杂度是比深度优先好的,但是如果要把最短的路径打印出来,广度优先就显得无能为力了,还是要用深度优先.还是前一篇文章<a href="https://zachaxy.github.io/2017/04/10/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/">深度优先算法</a>中走迷宫的例子,我们这次使用广广度优先,只输出最短路径的值,不打印具体路径;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="string">"&lt;&gt;"</span> + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;Pair&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> preCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> curCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//首先把当前层的全部都拿出来</span></span><br><span class="line">        <span class="keyword">while</span> (preCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Pair pair = queue.poll();</span><br><span class="line">          <span class="comment">//如果走到的右下角,打印层次,结束程序</span></span><br><span class="line">            <span class="keyword">if</span> (pair.i == arr.length - <span class="number">1</span> &amp;&amp; pair.j == arr[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(level);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">if</span> (pair.i + <span class="number">1</span> &lt; arr.length &amp;&amp; !dp[pair.i + <span class="number">1</span>][pair.j] &amp;&amp; arr[pair.i + <span class="number">1</span>][pair.j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pair.i + <span class="number">1</span>][pair.j] = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair(pair.i + <span class="number">1</span>, pair.j));</span><br><span class="line">                curCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向右</span></span><br><span class="line">            <span class="keyword">if</span> (pair.j + <span class="number">1</span> &lt; arr[<span class="number">0</span>].length &amp;&amp; !dp[pair.i][pair.j + <span class="number">1</span>] &amp;&amp; arr[pair.i][pair.j + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pair.i][pair.j + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair(pair.i, pair.j + <span class="number">1</span>));</span><br><span class="line">                curCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">if</span> (pair.i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !dp[pair.i - <span class="number">1</span>][pair.j] &amp;&amp; arr[pair.i - <span class="number">1</span>][pair.j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pair.i - <span class="number">1</span>][pair.j] = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair(pair.i - <span class="number">1</span>, pair.j));</span><br><span class="line">                curCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">if</span> (pair.j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !dp[pair.i][pair.j - <span class="number">1</span>] &amp;&amp; arr[pair.i][pair.j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[pair.i][pair.j - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair(pair.i, pair.j - <span class="number">1</span>));</span><br><span class="line">                curCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preCount = curCount;</span><br><span class="line">        curCount = <span class="number">0</span>;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先算法</title>
      <link href="/2017/04/10/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/"/>
      <url>/2017/04/10/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DFS（Depth First Search）深度优先搜索，为每个顶点设立一个“访问标志”。首先将图中每个顶点的访问标志设为 FALSE, 之后搜索图中每个顶点，如果未被访问，则以该顶点为起始点，进行遍历。</p><p>若当前访问的顶点的邻接顶点有未被访问的，则任选一个访问之。反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕；</p></blockquote><p>在使用<code>DFS</code>时,可能有两种情景,一种是使用<code>邻接矩阵</code>,一种是使用<code>邻接链表</code>;</p><p>使用<code>邻接矩阵</code>的表示形式,其实只需要一半的空间就可以了,因为<code>edges[i][j]</code>和<code>edges[j][i]</code>的值是相同的(这里只考虑无向图)</p><p>情景一:</p><blockquote><p>给出了一个图,图中有九个顶点,分别为A~I,那么用深度遍历的方法,得到A到I的一条路径;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">9</span>;  <span class="comment">//其实是个9*9的数组;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span>[] flag;</span><br><span class="line">   <span class="keyword">private</span> String[] vertexs = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联通图,如果为1,表示二者相连,为0表示不相连;</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span>[][] edges = &#123;</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">           &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">           &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//DFS深度优先递归</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[number];  <span class="comment">//标记数组,用来标记是否有</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (flag[i] == <span class="keyword">false</span>) &#123;<span class="comment">// 当前顶点没有被访问</span></span><br><span class="line">               DFS(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       flag[i] = <span class="keyword">true</span>;<span class="comment">// 第i个顶点被访问</span></span><br><span class="line">       System.out.print(vertexs[i] + <span class="string">" "</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (flag[j] == <span class="keyword">false</span> &amp;&amp; edges[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">               DFS(j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果:</p><p>A B C D E F G H I</p></blockquote><p>分析:通过连通图矩阵分析可知,顺序是:A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H 到了H之后走不下去了,回溯,G,F,E,D,到D的时候才有了直指I的路径;</p><p>情景二:走迷宫问题;</p><blockquote><p>给出一个二维数组,用来表示一个迷宫,如果<code>dp[i][j]=1</code>则表示前是一面墙,如果是0,则表示是一条路,那么求从左上角到右下角的最短路径;</p></blockquote><p>解决思路依然是使用深度优先遍历,但是要注意的是,现在的节点数不是在一维的,而是二维的,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length][arr[<span class="number">0</span>].length]; <span class="comment">//默认全是false;如果访问过标记为true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Pair&gt; path = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Pair&gt; path0 = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你想要找路径的的长度,并且把路径打印出来,那么就使用深度优先;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    path.add(<span class="keyword">new</span> Pair(i, j));</span><br><span class="line">    <span class="comment">//深度优先</span></span><br><span class="line">    dp[i][j] = <span class="keyword">true</span>;<span class="comment">//先将自己设置为true;然后再找四周的;</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length - <span class="number">1</span> &amp;&amp; j == arr[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        min = Math.min(min, count);</span><br><span class="line">        path0.clear();</span><br><span class="line">        path0.addAll(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !dp[i - <span class="number">1</span>][j] &amp;&amp; arr[i - <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i - <span class="number">1</span>, j, count);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        dp[i - <span class="number">1</span>][j] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arr.length &amp;&amp; !dp[i + <span class="number">1</span>][j] &amp;&amp; arr[i + <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i + <span class="number">1</span>, j, count);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        dp[i + <span class="number">1</span>][j] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; !dp[i][j - <span class="number">1</span>] &amp;&amp; arr[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i, j - <span class="number">1</span>, count);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        dp[i][j - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右</span></span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; arr[<span class="number">0</span>].length &amp;&amp; !dp[i][j + <span class="number">1</span>] &amp;&amp; arr[i][j + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(i, j + <span class="number">1</span>, count);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        dp[i][j + <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="string">"&lt;&gt;"</span> + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    System.out.println(min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要注意的是:这里使用了大量的static的全局变量path0,还有一个临时的全局变量path,临时的path是每次走时的路径,如果走到了终点,就和之前的最短路径比较,如果本次路径更短,那么就将path0设置为本次路径;</p><p>还有在遍历了一个位置之后,要把其标志位还原为false,这是因为你按照某个方向进行深度遍历下去,发现此路不通,或者不是最优解,那么你就需要按照原路回退,回退的意思就是把之前访问的flag设置为flase;同时临时路径path也要将本次访问的节点删除;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava源码详解-线程切换原理</title>
      <link href="/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="线程调度深入"><a href="#线程调度深入" class="headerlink" title="线程调度深入"></a>线程调度深入</h1><p>一个基本线程调度的例子:事件在IO线程产生,然后再UI线程被消费;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="subscribeOn-原理"><a href="#subscribeOn-原理" class="headerlink" title="subscribeOn()原理"></a>subscribeOn()原理</h2><p><code>subscribeOn()</code>用来指定<code>Observable</code>在哪个线程中执行事件流，也就是指定<code>Observable</code>中<code>OnSubscribe</code>(计划表)的<code>call()</code>方法在那个线程发射数据。下面通过源码分析<code>subscribeOn()</code>是怎样实现线程的切换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//忽略这个 if 分支吧</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重点看这个:this指的是调用线程切换方法subscribeOn()的Observerble ,</span></span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subscribeOn()方法是 Observerble 中的方法,一旦调用了该方法,就会创建出一个新的 Observerble 对象;当然还是通过create(OnSubscribe)方法来创建Observerble ;</p><p>再来看一下新创建的这个Observerble 对象中的OnSubscribe的实现类内部是如何实现的;OperatorSubscribeOn是OnSubscribe的实现类,自然也要实现call方法来触发事件了.同时一旦换了新的Observerble ,那么最终的观察者订阅的自然也就是新的Observerble 了,这一点一定要明确;那么自然call方法中的参数也就持有了原始观察者的引用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;   <span class="comment">//调度器</span></span><br><span class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;  <span class="comment">//原始Observable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数,传入原始的被观察者和线程调度器;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)原始观察者订阅了新的Observable后,将先执行此call方法(还记得订阅函数是如何实现的吗?)</span></span><br><span class="line">  <span class="comment">//这个参数的final的,其实是为了给内部类调用,内部类已经在其他线程了;</span></span><br><span class="line">  <span class="comment">//传入的参数是原始观察者;和上一篇操作符的原理类似,也是在call方法中创建了一个代理观察者,使其与原始被观察者订阅</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.Worker inner = scheduler.createWorker();  <span class="comment">//创建了一个worker对象,内部持有一个线程池</span></span><br><span class="line">        subscriber.add(inner);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)call方法中使用传入的调度器创建的Worker对象的schedule方法切换线程,传入的Action0会作为一个参数传入runnable中</span></span><br><span class="line">        <span class="comment">//runnable的run方法中会调用action0的call方法,然后runnable又被添加到线程池中被执行;</span></span><br><span class="line">          inner.schedule(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> Thread thread = Thread.currentThread();</span><br><span class="line">          <span class="comment">//(3)根据外层call中传来的原始观察者,创建了一个新的观察者(代理观察者),而且代理观察者持有原始观察者的引用</span></span><br><span class="line">                    Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//(5) 新的(代理)观察者收到数据后直接发送给原始观察者</span></span><br><span class="line">                        subscriber.onNext(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">//(4)在切换的线程中，新的观察者订阅原始Observable，用来接收数据</span></span><br><span class="line">              <span class="comment">//代理观察者能收到数据的前提是因为代理观察者订阅了原始被观察者;</span></span><br><span class="line">              <span class="comment">//其实这个订阅的动作是在新线程中执行的.</span></span><br><span class="line">                source.unsafeSubscribe(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>call</code>方法中通过<code>scheduler.createWorker().schedule(Action0)</code>完成线程的切换.</p><p>简单说:这里在subscribeOn()方法中新创建了一个Observable对象(代理Observable),于是发生了原始观察者与代理被观察者订阅的情况,于是代理被观察者中的call()方法被先执行,但是代理被观察者哪里有数据呢,还不是用老方法,又创建了一个代理观察者,然后让代理观察者与原始被观察者进行订阅,一旦发生订阅,数据就发出来了,数据发出来给了代理观察者,代理观察者的onNext()方法中有调用了原始观察者的onNext()方法;这不就解决了嘛,可是如何实现的线程切换呢?</p><p>提前说一下:这个Action0对象时作为参数传入一个Runnable实例中,然后将该runnable对象传入线程池,这样就实现了线程的切换,也就是说这个Action0()中的所有动作都是在新的线程池中执行的;</p><p>上述说说的一切动作都是在scheduler.createWorker().schedule(new Action0(XXX));都是在这个Action0()中发生的.</p><p>这里涉及到两个对象:<code>Scheduler</code>和<code>Worker</code>,究竟这是怎么实现的线程切换呢?</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>其实在subscribeOn(Scheduler  scheduler)方法中传入的参数就是 Scheduler 对象;</p><p>由于RxJava中有多种调度器，我们就看一个简单的<code>Schedulers.newThread()</code>，其他调度器的思路是一样的.</p><p>先看一下<code>Schedulers</code>这个类,<code>Schedulers</code>就是一个调度器的管理器,大管家;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedulers</span> </span>&#123;</span><br><span class="line">    <span class="comment">//各种调度器对象,看着眼熟吧.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler computationScheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler ioScheduler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler newThreadScheduler;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//单例，Schedulers被加载的时候，上面的各种调度器对象已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Schedulers INSTANCE = <span class="keyword">new</span> Schedulers();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造方法,在构造方法中初始化各种调度器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Schedulers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RxJavaSchedulersHook hook = RxJavaPlugins.getInstance().getSchedulersHook();</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//这里只关注创建一个新的线程的调度器</span></span><br><span class="line">        Scheduler nt = hook.getNewThreadScheduler();</span><br><span class="line">        <span class="keyword">if</span> (nt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newThreadScheduler = nt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//①.创建newThreadScheduler对象</span></span><br><span class="line">            newThreadScheduler = RxJavaSchedulersHook.createNewThreadScheduler();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//下面其余的线程不管.......................................</span></span><br><span class="line">    <span class="comment">//下面是Compute线程的创建  </span></span><br><span class="line">      Scheduler c = hook.getComputationScheduler();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            computationScheduler = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            computationScheduler = RxJavaSchedulersHook.createComputationScheduler();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//下面是IO线程的创建;</span></span><br><span class="line">        Scheduler io = hook.getIOScheduler();</span><br><span class="line">        <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ioScheduler = io;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ioScheduler = RxJavaSchedulersHook.createIoScheduler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//②. 获取NewThreadScheduler对象,也就是我们在使用调度调用的该方法来获取一个新线程的调度器;</span></span><br><span class="line">  <span class="comment">//我们平时使用线程切换时,就是调用的 Schedulers.io(),Schedulers.newThread()等方法来获取一个Scheduler对象的!!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">newThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE.newThreadScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟踪<code>RxJavaSchedulersHook.createNewScheduler()</code>，看看<code>newThreadScheduler</code>究竟是如何创建的?</p><p>我们发现无论是IO线程,Compute线程,还是NewThread线程调度器,都是<code>RxJavaSchedulersHook.createXXX()</code>方法创建出来了,其内部是用工厂方法实现的.</p><p>最终会找到一个叫<code>NewThreadScheduler</code>的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewThreadScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewThreadWorker(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终看到<code>NewThreadScheduler</code>就是我们调用<code>subscribeOn(Schedulers.newThread() )</code>传入的调度器对象，通过上面的分析,我们已经明白了<code>Scheduler</code> 的产生原理</p><p><strong>产生<code>Scheduler</code> 并不是最终目的,而是通过<code>Scheduler</code> 产生 <code>Worker</code>,然后调用<code>Worker.schedule(Action0)</code>实现线程的切换.</strong></p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>通过上面的分析,我们已经明白了<code>Scheduler</code> 的产生原理,产生<code>Scheduler</code> 并不是最终目的,而是通过<code>Scheduler</code> 产生 <code>Worker</code>,然后调用<code>Worker.schedule(Action0)</code>实现线程的切换.</p><p>每个调度器对象都有一个<code>createWorker</code>方法用于创建一个<code>Worker</code>对象，而<code>NewThreadScheduler</code>对应创建的<code>Worker</code>是一个叫<code>NewThreadWorker</code>的对象.</p><p>而在上面的分析中我们也看到了, <code>OperatorSubscribeOn</code>类中调用了</p><p><code>final Scheduler.Worker inner = scheduler.createWorker()</code>方法来得到一个 Worker,然后又调用 <code>inner.schedule(Action0)</code>实现线程的切换</p><p>接下来我们跟进<code>schedule()</code>方法查看其内部的实现原理.同样,这里的<code>Worker</code> 依然是以最简单的<code>NewThreadWorker</code> 为例.这里删减了部分代码,只留取对整体结构有用的部分.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor;   <span class="comment">//线程池,在下面构造函数中进行初始化.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewThreadWorker</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">1</span>, threadFactory);</span><br><span class="line">        executor = exec;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//默认调用的是这个方法;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> schedule(action, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scheduleActual(action, delayTime, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重要：其实 worker.schedule()最终调用的是这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledAction <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//别紧张,源码中直接将传入的 action return回来了... 这一步相对于什么也没做;</span></span><br><span class="line">        Action0 decoratedAction = schedulersHook.onSchedule(action);</span><br><span class="line">        <span class="comment">//ScheduledAction就是一个Runnable对象，在run()方法中调用了Action0.call()</span></span><br><span class="line">        ScheduledAction run = <span class="keyword">new</span> ScheduledAction(decoratedAction);</span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            f = executor.submit(run);   <span class="comment">//将Runnable对象放入线程池中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = executor.schedule(run, delayTime, unit);  <span class="comment">//延迟执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        run.add(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> run;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>OperatorSubscribeOn</code>计划表中通过<code>NewThreadWorker.schedule(Action0)</code>，将<code>Action0</code>作为参数传入一个<code>Runnable</code>的实现类:<code>ScheduledAction</code>,然后将这个runnable放入到一个线程池中执行，这样就实现了线程的切换。</p><p>简单说:最原始的<code>subscribeOn()</code>—调用了—-<code>create(new OperatorSubscribeOn&lt;T&gt;(this, scheduler))</code>—-创建一个代理被观察者—-&gt;<code>OperatorSubscribeOn()</code>中实现了<code>call()</code>方法—-&gt;call()方法中调用了<code>NewThreadWorker.schedule(Action0)</code>—-<code>Action0</code>被包装称一个<code>RUnnable</code>对象,然后<code>schedule()</code>方法内部使用了线程池,创建一个新的线程,并将包装的<code>Runnable</code>对象传递进去,这样就实现了线程的切换</p><p>步骤:</p><ol><li>原始被观察者调用subscribeOn()方法准备切换线程,(这时候还没切换呢.)产生一个代理被观察者</li><li>原始订阅者订阅代理被观察者(明面代码上你能看得到的)</li><li>代理被观察者的<code>onSubscribe.call()</code>方法执行,提供了一个<code>Runnable</code>对象,也就是线程已经被切换了</li><li><strong>新线程</strong>中产生一个新的代理观察者,代理观察者订阅原始被观察者(接下来的动作也都是在新线程中执行)</li><li>原始被观察者发射数据,这个动作已经是在新线程中执行了</li><li>代理观察者收到数据,再将数据转发给原始观察者</li></ol><p>看这张图,帮助理解<br><img src="http://note.youdao.com/yws/public/resource/3a378f8ba029c8148bde85d73d9704c7/xmlnote/1853E77FF7BA42C5ABBAA8B9671EB41B/70" alt="image"></p><blockquote><p>此处用到了多线程的知识,多线程这一块还需要总结整理;</p></blockquote><h3 id="多次subscribeOn-的情况"><a href="#多次subscribeOn-的情况" class="headerlink" title="多次subscribeOn()的情况"></a>多次subscribeOn()的情况</h3><p>我们发现，每次使用<code>subscribeOn</code>都会产生一个新的<code>Observable</code>，并产生一个新的计划表<code>OnSubscribe</code>，目标Subscriber最后订阅的将是最后一次<code>subscribeOn</code>产生的新的<code>Observable</code>。在每个新的<code>OnSubscribe</code>的<code>call</code>方法中都会有一个产生一个新的线程，在这个新线程中订阅上一级<code>Observable</code>，并创建一个新的<code>Subscriber</code>接受数据，最终原始<code>Observable</code>将在第一个新线程中发射数据，然后传送给给下一个新的观察者，直到传送到目标观察者，所以多次调用<code>subscribeOn</code>只有第一个起作用（这只是表面现象，其实每个<code>subscribeOn</code>都切换了线程，只是最终目标<code>Observable</code>是在第一个<code>subscribeOn</code>产生的线程中发射数据的）</p><p>也就是说多次调用<code>subscribeOn()</code>方法其实不是只有第一次方法其作用,而是每次都起作用,这里说的第一次起作用其实说的是最原始的数据发射是在第一次subscribeOn()指定的线程,只不过我们很少关注中间数据的处理过程而已;</p><p>一张图理解多订阅的过程:</p><p><img src="http://note.youdao.com/yws/public/resource/3a378f8ba029c8148bde85d73d9704c7/xmlnote/2AF59C14A4AC422F83E220C8C14059A8/68" alt="image"></p><p>下面是多次线程切换的伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第3个subscribeOn产生的新线程</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Subscriber s1 = <span class="keyword">new</span> Subscriber();</span><br><span class="line">        <span class="comment">//第2个subscribeOn产生的新线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Subscriber s2 = <span class="keyword">new</span> Subscriber();</span><br><span class="line">                <span class="comment">//第1个subscribeOn产生的新线程</span></span><br><span class="line">                <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Subscriber&lt;T&gt; s3 = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">                                subscriber.onNext(t);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="comment">//①. 最后一个新观察者订阅原始Observable</span></span><br><span class="line">                        Observable.subscribe(s3);</span><br><span class="line">                        <span class="comment">//②. 原始Observable将在此线程中发射数据</span></span><br><span class="line"></span><br><span class="line">                              <span class="comment">//③. 最后一个新的观察者s3接受数据</span></span><br><span class="line"></span><br><span class="line">                              <span class="comment">//④. s3收到数据后，直接发送给s2，s2收到数据后传给s1,...最后目标观察者收到数据</span></span><br><span class="line">                         &#125; </span><br><span class="line">                &#125;.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h1 id="observeOn原理"><a href="#observeOn原理" class="headerlink" title="observeOn原理"></a>observeOn原理</h1><blockquote><p>还是需要进一步的整理</p></blockquote><p>observeOn调用的是lift操作符。lift操作符创建了一个代理的Observable，用于接收原始Observable发射的数据，然后在Operator中对数据做一些处理后传递给目标Subscriber。observeOn一样创建了一个代理的Observable，并创建一个代理观察者接受上一级Observable的数据，代理观察者收到数据之后会开启一个线程，在新的线程中，调用下一级观察者的onNext、onCompete、onError方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, RxRingBuffer.SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">      <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用observeOn(Scheduler scheduler)方法时,也是传入了一个scheduler,这和subscribeOn()方法如出一辙,,随着不断深入的调用,其最终使用 lift()操作符创建了一个Observable 对象.这里先不管lift,接着上面的lift()中创建了一个OperatorObserveOn类,其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="comment">//创建代理观察者，用于接收上一级Observable发射的数据,而这个child就是原始观察者.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ImmediateScheduler) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</span><br><span class="line">            parent.init();</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//-----------------------------------我是分割线-------------------------------------------------------- </span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  先不管前面的复杂逻辑了,总之现在有了代理被观察者和代理观察者,像map那样发生了订阅,然后原始被观察者开始发数据了</span></span><br><span class="line"><span class="comment">  在代理观察者中,自然也有onNext,onCompleted(),onError()方法,但是在这三个方法后都调用了 schedule()函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">//代理观察者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.Worker recursiveScheduler;</span><br><span class="line">        <span class="keyword">final</span> NotificationLite&lt;T&gt; on;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Object&gt; queue;</span><br><span class="line">        <span class="comment">//接受上一级Observable发射的数据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!queue.offer(on.next(t))) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> MissingBackpressureException());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//在代理观察者中,自然也有onNext,onCompleted(),onError()方法,但是在这三个方法后都调用了 schedule()函数</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启新线程处理数据,切换线程就是在这里,重要的方法.</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">                recursiveScheduler.schedule(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// only execute this from schedule()</span></span><br><span class="line">        <span class="comment">//在新线程中将数据发送给目标观察者,注意这里是观察者,其call方法是因为实现了Action0接口,什么时候调用呢?</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> missed = <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">long</span> currentEmission = emitted;</span><br><span class="line">            <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</span><br><span class="line">            <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</span><br><span class="line">            <span class="keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="keyword">this</span>.on;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    localChild.onNext(localOn.getValue(v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得<code>subscribeOn()</code>时传入的<code>Scheduler</code>吗,这个<code>observeOn()</code>也传入了一个<code>Scheduler</code>,和之前一样,通过这个<code>scheduler产生一个Worker</code>,然后调用<code>Worker.schedule(Action0)</code>实现线程的切换.与<code>subscribeOn()</code>不同的是,这个线程切换时在代理观察者执行<code>onNext()</code>中执行的,也就是说先把线程切换过去,然后代理观察者在执行的 <code>actual.onNext()</code>方法.</p><p>我们可以参照多次subscribeOn()的图解示例,可以把第二次subscribeOn()替换成observeOn(),那么在产生的第二个代理观察者给原始观察者发消息时,本来是在其onNext()方法中直接调用原始观察者的onNext()的,但是由于有observeOn(),所以在执行onNext的时候进行了线程切换,然后在调用原始观察者的onNext()</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只要涉及到操作符，其实就是生成了一套代理的<code>Subscriber</code>(观察者)、<code>Observable</code>(被观察者)和<code>OnSubscribe</code>(计划表)。<code>Observable</code>最典型的特征就是链式调用，我们暂且将每一步操作称为一级。代理的<code>OnSubscribe</code>中的<code>call</code>方法就是让代理<code>Subscriber</code>订阅上一级<code>Observable</code>，直到订阅到原始<code>Observable</code>发射数据，代理<code>Subscriber</code>收到数据后，可能对数据做一些操作也有可能切换线程，然后将数据传送给下一级<code>Subscriber</code>，直到目标观察者接收到数据，目标观察者在那个线程接受数据取决于上一个<code>Subscriber</code>在哪一个线程调用目标观察者的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava源码详解-操作符原理</title>
      <link href="/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="深入操作符"><a href="#深入操作符" class="headerlink" title="深入操作符"></a>深入操作符</h1><p>操作符的实现原理?他是如何拦截事件，然后变换处理之后，最后传递到观察者手中的呢？</p><p>这里依然以 map()为例,看看map背后到底做了什么:</p><p>这个例子更好理解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始被观察者观察的是字符串</span></span><br><span class="line"><span class="comment">//原始观察者观察到的是整数;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始被观察者,真正负责发数据的;</span></span><br><span class="line">Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"1"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"2"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"3"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代理被观察者,是由原始的被观察者衍生出来的;</span></span><br><span class="line">Observable&lt;Integer&gt; observableProxy = observable.map(<span class="keyword">new</span> Func1&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"转换工厂..."</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始的观察者;</span></span><br><span class="line">Subscriber subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是真正的观察者-&gt; "</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">observableProxy.subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>首先看一下这个<code>map</code>方法内部是如何实现的:首先明确一点:map方法返回的是一个代理被观察者,所以其实是原始观察者订阅了代理被观察者,这是整个前提!!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建了全新代理的的Observable，构造函数传入的参数是OnSubscribe</span></span><br><span class="line">        <span class="comment">//OnSubscribeMap显然是OnSubscribe的一个实现类，</span></span><br><span class="line">        <span class="comment">//也就是说，OnSubscribeMap需要实现call()方法</span></span><br><span class="line">        <span class="comment">//构造函数传入了原始的被观察者Observable对象,也就是说代理被观察者持有一个</span></span><br><span class="line">  <span class="comment">//原始 被观察者的一个引用;</span></span><br><span class="line">        <span class="comment">//和一个开发者自己实现的Func1的实例,就是map的转化方法</span></span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeMap&lt;T, R&gt;(<span class="keyword">this</span>, func)); <span class="comment">//this是原始被观察者;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为map 实现的功能是 将 a 转换为 b,a/b均是被观察者,所以map中又创建了一个 Observable 的对象;</p><p>map背后究竟做了什么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//牢牢记住,这个OnSubscribeMap本质上还是一个OnSubscribe对象,用来创建被观察者时传入的,这是整个前提!</span></span><br><span class="line"><span class="comment">//上面也看到了 map()方法中又创建了一个新的被观察者(代理被观察者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//用于保存原始的Observable对象</span></span><br><span class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</span><br><span class="line">    <span class="comment">//还有我们传入的那个Func1的实例,func1中提供了转换  a-&gt;b 方法; 是通过 Func1 中的 T call()方法实现的</span></span><br><span class="line">    <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeMap</span><span class="params">(Observable&lt;T&gt; source, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.transformer = transformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现了call方法，我们知道call方法传入的Subscriber</span></span><br><span class="line">  <span class="comment">//mad,这个call 方法一定要和 Func1 中的 转换方法 call 区分开,这个 call 方法是用来发送事件的;</span></span><br><span class="line">    <span class="comment">// 这个代理的被观察者的call方法有什么用呢?还用问,被观察者没有call方法还玩个毛.</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//和原来不同的是,这个call中并不是调用观察者的next()方法.而是产生一个新的观察者=&gt;代理观察者;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//然后产生一个新的的订阅关系=&gt;原始被观察者和代理观察者的订阅</span></span><br><span class="line">    <span class="comment">//就是订阅之后，外部传入真实的的观察者,观察者什么时候传进来的?答:最终就是这个代理被观察者订阅的原始的观察者啊,所以这个o就是原始观察者;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// o 是原始观察者.</span></span><br><span class="line">        <span class="comment">//把外部传入的真实观察者传入到MapSubscriber，构造一个 代理的观察者</span></span><br><span class="line">        <span class="comment">//parent是代理观察者;</span></span><br><span class="line">        MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//给原始的观察者添加一个订阅;改了啊,改了,原始的观察者现在订阅代理观察者了,mad;</span></span><br><span class="line">       <span class="comment">//其实下面这句话可以忽略,没啥实际意义;</span></span><br><span class="line">        o.add(parent);</span><br><span class="line">        <span class="comment">//让外部的Observable去订阅这个代理的观察者</span></span><br><span class="line">      <span class="comment">//其实是: 代理观察者去订阅原始的观察者</span></span><br><span class="line">        source.unsafeSubscribe(parent);  <span class="comment">//!!!!核心在这一步,正是由于这一步,原始被观察者就发送数据了;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Subscriber的子类，用于构造一个代理的观察者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//这个Subscriber保存了原始的观察者</span></span><br><span class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; actual;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//我们自己在外部自己定义的Func1,转换方法 a-&gt;b</span></span><br><span class="line">        <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> done;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MapSubscriber</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; actual, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.actual = actual; <span class="comment">//原始观察者;</span></span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;  <span class="comment">//转换方法;</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="comment">//原始的Observable发送的onNext()等事件</span></span><br><span class="line">        <span class="comment">//都会首先传递到代理观察者这里?为什么,在哪里实现的?</span></span><br><span class="line">      <span class="comment">//其实并没有什么所谓的传递,事件只是一个变量,直接用就可以了;</span></span><br><span class="line">      <span class="comment">//看上面代理被观察者中的call方法,最后不是将 原始被观察者 与 代理观察者绑定了嘛...</span></span><br><span class="line">      <span class="comment">//有道理 √</span></span><br><span class="line">      <span class="comment">//本来啊,是被观察者</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            R result;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//mapper其实就是开发者自己创建的Func1，</span></span><br><span class="line">                <span class="comment">//call()开始变换数据</span></span><br><span class="line">              <span class="comment">//t是事件,事件只是一个变量,直接用就可以,并不存在事件的传递;</span></span><br><span class="line">              <span class="comment">//这里只是将一个变量转换为另一种类型的变量;</span></span><br><span class="line">                result = mapper.call(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(ex);</span><br><span class="line">                unsubscribe();</span><br><span class="line">                onError(OnErrorThrowable.addValueAsLastCause(ex, t));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用真实的观察者的onNext()</span></span><br><span class="line">            <span class="comment">//从而在变换数据之后，把数据送到真实的观察者手中</span></span><br><span class="line">            actual.onNext(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//onError()方法也是一样</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                RxJavaHooks.onError(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            actual.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            actual.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(Producer p)</span> </span>&#123;</span><br><span class="line">            actual.setProducer(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理被观察者存在的意义:之前我在想,如果经过map转换的话,只是需要一个代理观察者就好了,为什么还需要一个代理被观察者,其实代理被观察者在这里有两个使命:</p><ul><li>并不是所有的代码都是按照流式一下写下来的,可能是分别创建观察者,被观察者,然后订阅,这个时候map的转换需要产生一个代理被观察者</li><li>代理被观察者与原始观察者进行订阅,代理被观察者中的call方法是先执行的,那么它的call()方法内部实现了什么呢?就是原始被观察者和代理被观察者的订阅,因为代理被观察者是没有数据源的,只有在这里call()中进行订阅,原始被观察者才会发出数据,给代理被观察者用func1转换方法处理,处理后再发送原始观察者;</li></ul><ol><li><p>问题1:这个代理观察者的观察者参数是什么时候传进来的?</p><p>答:不要心急,记住总的原则是:观察者是在订阅的时候传入进来的.我们可以这样理解,本来我们创建被观察者和观察者,然后订阅.现在多了一个 map 操作,经过map操作后,被观察者就变了,变成了这个代理被观察者,这时候我们忘掉原始的观察者吧.原始的观察者只负责产生原始的事件源,何况这个代理被观察者中还持有原始被观察者的引用.那么在这个代理被观察者的call方法中其实是使用原始被观察者的call发原始数据,只不过发之前先不给观察者,而是自己调用func1来把事件转换一下;</p></li></ol><p>map(Func1 func1);</p><p>首先我们看在使用map时,需要传入一个 Func1 实例,其实 Func1 是一个接口,需要实现的方法是一个 call()方法,正是靠这个call 方法实现的转换;</p><p>接下来看 map 内部是怎么实现的,其创建了一个 Observable 实例并返回;这也很好理解,进行了 map 转换后还是一个被观察的对象;,</p><p>return create(new OnSubscribeMap&lt;T, R&gt;(this, func));</p><p>跟进去这个创建的流程中,前面也分析了创建一个 Observable 对象不能 new,而是使用一个 create()方法,并传入一个 OnSubscribe 的实例;同理 map 中创建的 Observable 对象也一样,只是这个传入的是 OnSubscribeMap 对象,这是 OnSubscribe 接口的一个实现类, OnSubscribeMap 需要两个参数,第一个参数是原始的被观察着,第二个参数是用来转换的 Func1 对象,之前也讲过,每个 被观察者中都持有一个 OnSubscribe,这个接口要求实现一个 call 方法,这个call方法是用来触发事件开始执行的,我们用了map新键的一个被观察者,对象被转换后,也需要一个新的触发机制,就在这个call中实现.</p><p>接下来看一下 OnSubscribeMap 中时如何实现 call() 方法的,在这个call方法中传入的是观察者,嗯,没错,传入的是观察者,这里新键了一个观察者,我们称之为代理观察者,</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里面一共涉及到了四个对象</p><ul><li>被观察者</li><li>代理被观察者</li><li>观察者</li><li>代理观察者</li></ul><ol><li><p>被观察者通过 map 转换后产生了新的 代理被观察者,并持有原始被观察者的引用与转换的方法</p></li><li><p>(map方法产生的)代理被观察者 与 原始观察者产生订阅(明面上的,你看得到)</p></li><li><p>通过上一步的订阅,代理被观察者就持有了原始观察者的引用</p></li><li><p>代理被观察者的call方法中创建一个代理观察者</p></li><li><p>代理观察者与原始被观察者进行订阅</p></li><li><p>通过上一步的订阅,原始观察者发送消息给 代理观察者,发来的是 String</p></li><li><p>代理观察者是代理被观察者的内部类,自然也可以访问代理被观察者的属性—转换方法</p></li><li><p>代理观察者在其<code>onNext()</code>方法中获取到<code>String</code>,然后通过转换方法将 String 装换为 int</p></li><li><p>代理观察者通过原始观察者的引用,将 int传给观察者(其实这时的代理观察者又有点被观察者的意思,它调用了原始观察者的 onNext(int) 方法)</p></li><li><p>整个流程结束;</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava源码详解-订阅原理</title>
      <link href="/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="深入观察者与被观察者模式"><a href="#深入观察者与被观察者模式" class="headerlink" title="深入观察者与被观察者模式"></a>深入观察者与被观察者模式</h2><p>下面以一个经典的例子进行讲解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个被观察者（开关）</span></span><br><span class="line"> Observable switcher=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            subscriber.onNext(<span class="string">"On"</span>);</span><br><span class="line">            subscriber.onNext(<span class="string">"Off"</span>);</span><br><span class="line">            subscriber.onNext(<span class="string">"On"</span>);</span><br><span class="line">            subscriber.onNext(<span class="string">"On"</span>);</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//创建一个观察者（台灯）</span></span><br><span class="line"> Subscriber light=<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//被观察者的onCompleted()事件会走到这里;</span></span><br><span class="line">            Log.d(<span class="string">"DDDDDD"</span>,<span class="string">"结束观察...\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//出现错误会调用这个方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//处理传过来的onNext事件</span></span><br><span class="line">            Log.d(<span class="string">"DDDDD"</span>,<span class="string">"handle this---"</span>+s)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//订阅</span></span><br><span class="line">switcher.subscribe(light);</span><br></pre></td></tr></table></figure><p>针对上面的代码提出两个问题:</p><ol><li>被观察者中的Observable.OnSubscribe是什么，有什么用?</li><li>call(subscriber)方法中，subscriber哪里来的?</li><li>为什么只有在订阅之后，被观察者才会开始发送消息?</li></ol><h2 id="Observable-类深入"><a href="#Observable-类深入" class="headerlink" title="Observable 类深入"></a>Observable 类深入</h2><p>首先看一下OnSubscribe是什么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面也提到Acton1这个接口，内部只有一个待实现call()方法</span></span><br><span class="line"><span class="comment">//没啥特别，人畜无害</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OnSubscribe继承了这个Action1接口,自己并没有增加新的方法;</span></span><br><span class="line"><span class="comment">//但是新增了 Subscriber 类的泛型要求,也就是说只能用在订阅者中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// OnSubscribe仍然是个接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面也提到<code>Acton1</code>这个接口，内部只有一个待实现<code>call()</code>方法.<br><code>OnSubscribe</code>接口继承了这个<code>Action1</code> 接口,但是自己并没有增加新的方法;只是把泛型限定在了 <code>Subscriber</code>,也就是说必须传入观察者对象;<br>那么也就是说，<code>OnSubscribe</code>本质上也是和<code>Action1</code>一样的接口，只不过它专门用于<code>Observable</code>内部。</p><p>那么将<code>OnSubscribe</code> 接口传入<code>Observable</code> 后,该接口干什么?</p><p>答:用来触发事件的发生,在<code>call()</code>内部调用观察者的 <code>onNext()</code>方法!!!</p><p>要注意的是在 <code>Observable</code> 被观察者的类中，<code>OnSubscribe</code>是它唯一的属性,<br>同时也是<code>Observable</code>构造函数中唯一必须传入的参数，也就是说，只要创建了<code>Observable</code>，那么内部也一定有一个 <code>OnSubscribe</code> 实体对象。</p><p>当然,<code>Observable</code>是没有办法直接new的,我们只能通过create(),just()等等方法创建,这些方法背后去调用了<code>new Observable(onSubscribe)</code></p><p>再来大体看一下 <code>Observable</code>这个类的骨架:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//唯一的属性</span></span><br><span class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，因为protected，我们只能使用create函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSubscribe = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create(onSubscribe) 内部调用构造函数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Observer-类深入"><a href="#Observer-类深入" class="headerlink" title="Observer 类深入"></a>Observer 类深入</h2><p>Observer是一个接口,其内部有三个方法:</p><ul><li>void onCompleted():处理被观察者发送完事件后的逻辑</li><li>void onError(Throwable e):处理出错逻辑</li><li>void onNext(T t):处理事件,有一个事件就执行一次</li></ul><p>顺便说一下 Subscriber,其实 Observer的实现类,但也是抽象的,主要是也实现了Subscription接口,所以相对于 Observer接口添加了一些新的方法,也有一些除了这两个接口之外自定义的方法,都自己实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span></span></span><br></pre></td></tr></table></figure><p>看一下其中的主要方法:</p><p>Observer中的方法:(Observer中的方法在Subscriber中均未实现,需要开发者自己实现,只有这个三个Subscriber没有实现)</p><ul><li>void onCompleted():处理被观察者发送完事件后的逻辑</li><li>void onError(Throwable e):处理出错逻辑</li><li>void onNext(T t):处理事件,有一个事件就执行一次</li></ul><p>Subscription中的方法:</p><ul><li>void unsubscribe():取消订阅,停止接受被观察者发来的消息;</li><li>boolean isUnsubscribed():是否取消了订阅被观察者发的消息;</li></ul><p>Subscriber自身的方法:</p><ul><li><p>void add(Subscription s):添加一个订阅对象</p></li><li><p>void onStart():是一个空实现,开发者可以自己实现该方法,该方法被调用的时机是在被观察者与观察者产生订阅,但是此时被观察者还为发出任何消息</p></li></ul><h2 id="subscribe-subscriber-方法深入"><a href="#subscribe-subscriber-方法深入" class="headerlink" title="subscribe(subscriber)方法深入"></a>subscribe(subscriber)方法深入</h2><p>当创建了 Observable 和 Observer 之后，调用subscribe(subscriber)方法产生订阅关系时，发生了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给被观察者传入了观察者对象</span></span><br><span class="line"><span class="comment">//这个方法是有返回值的,其类型是Subscription,熟悉吗?这是上面Subscriber对象实现的某一个接口;我们经常拿到这个引用,然后调用其unsubscribe()方法防止内存泄露啊!!!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">    <span class="comment">//调用了下面的方法,将observer类型包装成subscribe类型</span></span><br><span class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> ObserverSubscriber&lt;T&gt;(observer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//往下调用</span></span><br><span class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实最终是调用了这个方法</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//注:这个方法是在被观察者中的方法,执行订阅函数,那么此时被观察者就持有了观察者的引用了</span></span><br><span class="line">  <span class="comment">//也就是说现在被观察者可以调用观察者的任何方法了;</span></span><br><span class="line">  <span class="comment">//被观察者持有观察者的引用,这是整个观察者模型最关键的地方;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//刚产生订阅关系的时候,这时被观察者还未发送消息,先执行观察者的onStart()方法</span></span><br><span class="line">    subscriber.onStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a significant depth to already huge call stacks.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里简单讲，对onSubscribe进行封装，不必紧张。</span></span><br><span class="line">      <span class="comment">//该方法的源码单纯的将 onSubscribe 对象返回了,什么也没做,所以你可以忽略这一步;</span></span><br><span class="line">        OnSubscribe onSubscribe=RxJavaHooks.onObservableStart(observable, observable.onSubscribe);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个才是重点！！！</span></span><br><span class="line">        <span class="comment">//这个调用的具体实现方法就是我们创建观察者时</span></span><br><span class="line">        <span class="comment">//写在Observable.create()中的call()呀</span></span><br><span class="line">        <span class="comment">//而调用了那个call(),就意味着事件开始发送了</span></span><br><span class="line">        onSubscribe.call(subscriber);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//源码中该方法的实现是:单纯的把subscriber返回了;</span></span><br><span class="line">      <span class="comment">//其实在真正使用时我们并不关心订阅函数的返回值,反正该方法中被观察者发送消息,观察者处理消息的逻辑已经执行了;</span></span><br><span class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看到这里，我们就可以对上面三个问题做统一的回答了：</p><ol><li>onSubscribe是Observable内部唯一属性，是连接Observable和subscriber的关键，相当于连接台灯和开关的那根电线,主要是其内部的call()方法,在该方法中发送了消息;</li><li>call(Subscriber&lt;? super String&gt; subscriber)中的subscriber，就是我们自己创建的那个观察者</li><li>只有在订阅的时候，才会发生onSubscribe.call(subscriber)，进而才会开始调用onNext(),onComplete()等。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava源码详解-基本使用</title>
      <link href="/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/04/03/RxJava%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者-VS-被观察者"><a href="#观察者-VS-被观察者" class="headerlink" title="观察者 VS 被观察者"></a>观察者 VS 被观察者</h1><p>以灯泡和开关为例子,这个例子中,开关是被观察者,灯泡是观察者,灯泡观察到开关执行了响应的操作,才执行响应的亮/灭的响应;</p><p>被观察者(Observable):事件的产生源头<br>观察者(Observer):事件的处理方;注册感兴趣的事件,一旦事件发生改变,观察者再做出相应的响应</p><p>在事件的起点到终点的传递过程中,我们可以进行相应的转换/加工/过滤等操作</p><p>在源码中,你可能会看到观察者有时候用Observer,有时候用Subscriber<br>其实:Observer是观察者的接口， Subscriber是实现这个接口的抽象类,<br>因此两个类都可以被当做观察者，由于 Subscriber 在 Observer 的基础上做了一些拓展，加入了新的方法，一般会更加倾向于使用Subscriber。<br><code>abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription</code></p><h1 id="RxJava-的使用"><a href="#RxJava-的使用" class="headerlink" title="RxJava 的使用"></a>RxJava 的使用</h1><h1 id="创建被观察者"><a href="#创建被观察者" class="headerlink" title="创建被观察者"></a>创建被观察者</h1><p>这里分为三种方法:普通模式,偷懒模式1,偷懒模式2</p><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><p>这里分为两种方法:普通模式,偷懒模式1;</p><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>建立观察者和被观察者的联系<br><code>switcher.subscribe(light);</code></p><p>这里可能存在一些疑惑,一般的写法是观察者订阅被观察者,而 RxJava 怎么反过来了<br>是这样的，台灯观察开关，逻辑是没错的，而且正常来看就应该是light.subscribe(switcher)才对，之所以“开关订阅台灯”，是为了保证 <strong>流式API调用风格</strong></p><p>注: <strong>当调用订阅操作即调用Observable.subscribe(Observe)方法的时候，被观察者才真正开始发出事件</strong></p><h3 id="关于流式API调用风格"><a href="#关于流式API调用风格" class="headerlink" title="关于流式API调用风格"></a>关于流式API调用风格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这就是RxJava的流式API调用</span><br><span class="line">Observable.just(&quot;On&quot;,&quot;Off&quot;,&quot;On&quot;,&quot;On&quot;)</span><br><span class="line">    //在传递过程中对事件进行过滤操作</span><br><span class="line">     .filter(new Func1&lt;String, Boolean&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Boolean call(String s) &#123;</span><br><span class="line">                    return s！=null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    .subscribe(mSubscriber);</span><br></pre></td></tr></table></figure><p>上面就是一个非常简易的RxJava流式API的调用：同一个调用主体一路调用下来，一气呵成。<br>所以为了保证流式API的调用风格,才用了这种反人类的逻辑;</p><p>由于被观察者产生事件，是事件的起点，那么开头就是用Observable这个主体调用来创建被观察者，产生事件，<br>为了保证流式API调用规则，就直接让Observable作为唯一的调用主体，一路调用下去。</p><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>操作符的分类:</p><ul><li>转换类操作符:(map flatMap concatMap flatMapIterable switchMap scan groupBy…)；</li><li>过滤类操作符:(fileter take takeLast takeUntil distinct distinctUntilChanged skip skipLast …)；</li><li>组合类操作符:(merge zip join combineLatest and/when/then switch startSwitch…)。</li></ul><p>接下来就挑选几个常用的操作符进行讲解:</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>提供一对一的转换,例如提供的是 url 路径,需要的是对应的 bitmap</p><h2 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h2><p>将每个Observable产生的事件里的信息再包装成新的Observable传递出来,并且破除的多层嵌套的难题,<br>因为FlatMap可以再次包装新的Observable,而每个Observable都可以使用from(T[])方法来创建自己，这个方法接受一个列表，然后将列表中的数据包装成一系列事件。</p><p>还记得创建被观察者时的 from 方法吗,被观察者提供一个数组给 from 方法,被观察者都能将数组中的每个元素转换为被观察者,然后执行观察者的方法.</p><p>flatMap 每使用一个 from 方法,就该表一次 for 循环,将一个数组中的元素转换为单个被观察者,仅仅使用from,就该表一层循环,多层嵌套的循环就使用多次from()方法<br>是的代码看起来并没有嵌套的那么复杂,背后的原理就是使用from</p><p>所谓 flat就是:我们传入的是一个年级(包含多个班,每个班都多个同学,打印每个同学的姓名),第一步用form已经将年级拆成了多个班,但这不是终极目的,而是在将每个班的每个同学对应过来;回想之前的处理逻辑,每产生一个事件,不等待,直接发出去,但是现在不同,要等一个班的from结束之后(攒齐这个班所有同学,然后再一次发出去),接下来在解析下一个班</p><h2 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h2><p>concatMap()解决了flatMap()的交叉问题，它能够把发射的值连续在一起.</p><h2 id="flatMapIterable"><a href="#flatMapIterable" class="headerlink" title="flatMapIterable"></a>flatMapIterable</h2><p>flatMapIterable()和flatMap()几乎是一样的，不同的是flatMapIterable()它转化的多个Observable是使用Iterable作为源数据的。(示例代码如下)并没有看出来什么区别,还是使用flatmap吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(communities)</span><br><span class="line">        .flatMapIterable(<span class="keyword">new</span> Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> community.houses;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h2><p>switchMap()和flatMap()很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。(也不懂什么使用场景,只知道是只监听当前的事件,只要一发送,过去的事件不在监听,只管理现在的事件)</p><h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><p>scan()对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .scan(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> integer + integer2;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.print(integer+“ ”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果是:1,3,6,10,15<br>1 = 1<br>3 = 1+2<br>6 = 3+3<br>10 = 6+4<br>15 = 10+5;<br>实现的函数是两个整数相加,第一个整数时,默认第0个数是0,后面进来一个数就和当前计算的结果相加;</p><h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>groupBy()将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。这只是在顺序上进行了调整,在观察者方收到数据的顺序是相同key的是临近的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</span><br><span class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</span><br><span class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</span><br><span class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</span><br><span class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</span><br><span class="line">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable.from(houses)</span><br><span class="line">        .groupBy(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//生成key的规则,根据communityName相同的分为一组;</span></span><br><span class="line">                <span class="keyword">return</span> house.communityName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起</span><br><span class="line">小区:中粮·海景壹号; 房源描述:毗邻汤臣一品</span><br><span class="line">小区:中粮·海景壹号; 房源描述:南北通透，豪华五房</span><br><span class="line">小区:竹园新村; 房源描述:满五唯一，黄金地段</span><br><span class="line">小区:竹园新村; 房源描述:顶层户型，两室一厅</span><br></pre></td></tr></table></figure><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a><strong>Filter</strong></h2><p><strong>filter(Func1)</strong>用来过滤观测序列中我们不想要的值，只返回满足条件的值</p><p>还是拿前面文章中的小区Community[] communities来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(communities)</span><br><span class="line">        .filter(<span class="keyword">new</span> Func1&lt;Community, Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> community.houses.size()&gt;<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</span><br><span class="line">        System.out.println(community.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><p><strong>take(int)</strong>用一个整数n作为一个参数，从原始的序列中发射前n个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(communities)</span><br><span class="line">    .take(<span class="number">10</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</span><br><span class="line">        System.out.println(community.name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>但是后面的数据怎么办?</strong></p><h2 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h2><p><strong>takeLast(int)</strong>同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。</p><h2 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h2><p><strong>takeUntil(Observable)</strong>订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，takeUntil()返回的Observable会停止发射原始Observable并终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Long&gt; observableA = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">Observable&lt;Long&gt; observableB = Observable.interval(<span class="number">800</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">observableA.takeUntil(observableB)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">                System.out.println(aLong);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出:0,1</p><p><strong>takeUntil(Func1)</strong>还可以通过Func1中的call方法来判断是否需要终止发射数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">                .takeUntil(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> integer &gt;= <span class="number">5</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>输出结果:1,2,3,4</p><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>异步是相对于主线程来讲的子线程操作，在这里我们不妨使用线程调度这个概念更加贴切。</p><p>Scheduler:调度器,用于线程控制</p><ul><li>Scheduler.immediate()  默认当前线程,不写就是这个,一般不写</li><li>Scheduler.newThread()  每次都创建新线程去执行,消耗大,不建议用</li><li>Scheduler.io()  IO密集型任务(eg:异步阻塞IO操作),默认是一个 CacheThreadScheduler,从线程池中去取一个线程,</li><li>Scheduler.computation() CPU密集计算线程,线程池中的线程数和CPU核心数一致,多用于处理图形界面大量的计算或者事件循环;</li><li>Scheduler.trampoline() 当其它排队的任务完成后,当前线程排队开始执行;</li><li>AndroidScheduler.mainThread() Android 的 UI 线程</li></ul><p>实际上线程调度只有subscribeOn（）和observeOn（）两个方法。对于初学者，只需要掌握两点：</p><ol><li>subscribeOn（）它指示Observable在一个指定的调度器上创建（只作用于被观察者创建阶段）。只能指定一次，如果指定多次则以第一次为准</li><li>observeOn（）指定在事件传递（加工变换）和最终被处理（观察者）的发生在哪一个调度器。可指定多次，每次指定完都在下一步生效。</li></ol><p>线程调度掌握到这个程度，在入门阶段时绝对够用的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(getFilePath())</span><br><span class="line">          <span class="comment">//指定在新线程中创建被观察者 Observable</span></span><br><span class="line">         .subscribeOn(Schedulers.newThread())</span><br><span class="line">     <span class="comment">//将接下来执行的线程环境指定为io线程,必须要先制定下面操作的线程,然后再指定操作;</span></span><br><span class="line">         .observeOn(Schedulers.io())</span><br><span class="line">           <span class="comment">//map就处在io线程</span></span><br><span class="line">         .map(mMapOperater)</span><br><span class="line">           <span class="comment">//将后面执行的线程环境切换为主线程，</span></span><br><span class="line">           <span class="comment">//但是这一句 observeOn 依然执行在io线程</span></span><br><span class="line">         .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">         <span class="comment">//指定线程无效，但这句代码本身执行在主线程,一个操作只能制定一个 subscribeOn,多了以第一个为准;</span></span><br><span class="line">         .subscribeOn(Schedulers.io())</span><br><span class="line">         <span class="comment">//执行在主线程</span></span><br><span class="line">         .subscribe(mSubscriber);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 框架源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全背包问题</title>
      <link href="/2017/03/31/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2017/03/31/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>有n种物品，每种物品有无限个，每个物品的重量为weight[i]，每个物品的价值为value[i]。 现在有一个背包，它所能容纳的重量为total，问：当你面对这么多有价值的物品时，你的背包所能带走的最大价值是多少？</p></blockquote><ul><li>n:物品数量</li><li>weight[] :每个物品的重量</li><li>value[]: 每个物品的价值</li><li>total:背包的最大承重</li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>完全背包问题和之前的 <a href="https://zachaxy.github.io/2017/03/30/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">01背包问题</a>思路是类似的,只不过完全背包问题中对每个物品的数量没有了限制,可以无限使用。这里直接使用最优解的方法做了，如果你对如何从普通解到最优解的转换还不熟悉，请参考 <a href="https://zachaxy.github.io/2017/03/30/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">01背包问题</a>；</p><p>使用一个<code>dp[n][total+1]</code>数组,其中<code>dp[j]</code>表示在背包最大承重为j的情况下的最优解. 那么<code>dp[i][j]</code>的值如何确定呢?</p><p>首先:确定当前最大的承重是<code>j</code>,那么用不用物品<code>i</code>呢?</p><p>如果不使用<code>i</code>,那么<code>dp[i][j] = dp[i-1][j]</code></p><p>如果使用<code>i</code>,那么<code>dp[i][j] = dp[i][j-w[i]]+v[i]</code></p><h1 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//开始套路</span></span><br><span class="line">  <span class="keyword">int</span> n;  <span class="comment">//一共有n件物品</span></span><br><span class="line">  <span class="keyword">int</span> total; <span class="comment">//背包的总重量为total</span></span><br><span class="line"></span><br><span class="line">  n = <span class="number">5</span>;</span><br><span class="line">  total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] w = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>[] v = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化第一行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w[<span class="number">0</span>]; i &lt; total + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - w[<span class="number">0</span>]] + v[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一列就不初始化了吧</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) &#123;</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">        dp[i][j] = Math.max(dp[i][j], dp[i][j - w[i] + v[i]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(dp[n-<span class="number">1</span>][total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="压缩空间"><a href="#压缩空间" class="headerlink" title="压缩空间"></a>压缩空间</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始套路</span></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">//一共有n件物品</span></span><br><span class="line">    <span class="keyword">int</span> total; <span class="comment">//背包的总重量为total</span></span><br><span class="line"></span><br><span class="line">    n = <span class="number">5</span>;</span><br><span class="line">    total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] w = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] v = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w[<span class="number">0</span>]; i &lt; total + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - w[<span class="number">0</span>]] + v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w[i] + v[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里面的初始化第一行不是必须的,直接进行下面的<code>for</code>循环也是可以的,只需要把外层<code>for</code>的初始值改为<code>0</code>即可;我这里只不过是习惯了写动态规划的套路,在这样做的,如果你喜欢更简洁的写法,请看下面.</p><h1 id="更简洁的写法"><a href="#更简洁的写法" class="headerlink" title="更简洁的写法"></a>更简洁的写法</h1><p>改进后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始套路</span></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">//一共有n件物品</span></span><br><span class="line">    <span class="keyword">int</span> total; <span class="comment">//背包的总重量为total</span></span><br><span class="line"></span><br><span class="line">    n = <span class="number">5</span>;</span><br><span class="line">    total = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] w = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] v = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[total + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt; total + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - w[i] + v[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[total]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全背包问题的变形问题"><a href="#完全背包问题的变形问题" class="headerlink" title="完全背包问题的变形问题"></a>完全背包问题的变形问题</h1><h2 id="最小钱币数"><a href="#最小钱币数" class="headerlink" title="最小钱币数"></a>最小钱币数</h2><blockquote><p> 给定一个数组arr,该数组中的各个数代表钱币的面值,每个面值的数量无限多, 给定一个aim,用arr中的钱币凑齐aim数,是的凑出的钱币数量最少</p></blockquote><p>直接上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCoins1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)构造动态数组 (2)此时的数组其实已经初始化为全0了;</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][aim + <span class="number">1</span>];  <span class="comment">//n行,aim+1列;此时的列的索引就是当前凑的货币总额;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)初始化第一行;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;  <span class="comment">//此时j就是当前行的钱币凑成的总额;注意是从1开始的,也就是说第0列的值为0;</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = max;<span class="comment">//先赋值为max;</span></span><br><span class="line">        <span class="comment">//第一个判定条件是保证第二个判定条件数组下标不越界</span></span><br><span class="line">        <span class="comment">//只是初始化第一行,将arr[0]的倍数列初始化响应的倍数;</span></span><br><span class="line">        <span class="keyword">if</span> (j - arr[<span class="number">0</span>] &gt;= <span class="number">0</span> &amp;&amp; dp[<span class="number">0</span>][j - arr[<span class="number">0</span>]] != max) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - arr[<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//最外层按列遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;<span class="comment">//内层按行遍历</span></span><br><span class="line">            left = max;</span><br><span class="line">            <span class="comment">//判断j是不是&gt;arr[i],并且第j-arr[i]列不是max</span></span><br><span class="line">            <span class="keyword">if</span> (j - arr[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j - arr[i]] != max) &#123;</span><br><span class="line">                left = dp[i][j - arr[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这一步,比较left和上一行的大小才进行真正的数组初始化;</span></span><br><span class="line">            dp[i][j] = Math.min(left, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][aim] != max ? dp[n - <span class="number">1</span>][aim] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩空间的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简洁的写法;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//创建数组</span></span><br><span class="line">     <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[aim + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//初始化第一行</span></span><br><span class="line">     <span class="keyword">int</span> max = Integer.MAX_VALUE;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; aim + <span class="number">1</span>; i++) &#123;</span><br><span class="line">         dp[i] = max;</span><br><span class="line">         <span class="keyword">if</span> (i &gt;= arr[<span class="number">0</span>] &amp;&amp; dp[i - arr[<span class="number">0</span>]] != max) &#123;</span><br><span class="line">             dp[i] = dp[i - arr[<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = arr[i]; j &lt; aim + <span class="number">1</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (dp[j - arr[i]] != max) &#123;</span><br><span class="line">                 dp[j] = Math.min(dp[j], dp[j - arr[i]] + <span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[aim] != max ? dp[aim] : -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="换钱币的方法数"><a href="#换钱币的方法数" class="headerlink" title="换钱币的方法数"></a>换钱币的方法数</h2><blockquote><p>上一题是求最少钱币的数量,现在是让求有几种可以换算的方法(每种钱币数量无限)之前我们所有的动态规划目标都是一个:求最优解,现在让求的是所有的解的个数</p></blockquote><p><strong>直接上代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[aim + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aim + <span class="number">1</span>; i += arr[<span class="number">0</span>]) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr[i]; j &lt; aim+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的点是:需要把第0列初始化为1,而不是0;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客过程全纪录</title>
      <link href="/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/"/>
      <url>/2017/03/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E5%85%A8%E7%BA%AA%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li><p>安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>一路next即可</p></li><li><p>安装<a href="http://git-scm.com/download/" target="_blank" rel="noopener">git</a>,一路next即可</p></li><li><p>注册github账号,这个步骤就不说了吧…</p></li><li><p>生成ssh key(这一步非必须)</p><ol><li><p>检测之前是否有生成过ssh没</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/.ssh   //注意 ~/.ssh之间没有空格</span><br></pre></td></tr></table></figure><p>如果提示：<code>No such file or directory</code> 说明你还未生成<code>ssh key</code></p></li><li><p>生成新的ssh key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;  //这个邮箱地址就是你注册github使用的邮箱</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/zhangxin/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>第三行是在询问你将生成的ssh key放在哪里默认是你的用户目录,这里直接回车就好</p></li><li><p>接下来或让你创建一个密码,并再次确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Created directory &apos;/c/Users/zhangxin/.ssh&apos;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure></li><li><p>添加 ssh key 到 github</p><p>打开本地<code>/c/Users/zhangxin/.ssh</code>,你的肯定不是我这个文件,改成你在是第二步保存的文件位置,将<code>id_rsa.pub</code>文件用记事本打开,将此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。复制这个文件的内容,登陆你的github,点击右上角头像处的下拉列表 <code>Settings—&gt;SSH and GPG keys —&gt; 右上角 New SSH key</code>,把你本地生成的密钥复制到里面（key文本框中）， 点击<code>add key</code>就 ok 了.同时你也可以设置title用来为这个 key 做一个标示,因为我们很可能在多台电脑上都写博客并推送,不同的电脑需要按照相同的步骤,当然生成的ssh key是不同的,如果你需要同时在另一台电脑上工作,就需要把另一台电脑的ssh key 也添加到你的github中,title所以,你自己可以区分开就好,比如单位的,用一个<code>work</code>,在家的用一个<code>home</code>,随你喜欢.</p></li><li><p>测试 ssh 是否正确设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br><span class="line"></span><br><span class="line">//这一步输入yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>如果正常的话,就是显示这些内容了.</p></li></ol></li><li><p>设置用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;userName&quot;             //你的用户名,要加双引号的啊</span><br><span class="line">$ git config --global user.email  &quot;userName@xxx.com&quot;  //填写自己的邮箱 ,也要加双引号的啊</span><br></pre></td></tr></table></figure><p>查看用户设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h1 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h1><ol><li><p>登陆 github ,创建一个新的仓库,名字叫做 <code>xxx.github.io</code>,这里xxx要换成你的 github 的用户名,点击「Create Repository」 完成创建。</p></li><li><p>创建一个文件夹来保存你写的博客,例如在 E 盘下创建文件夹 <code>blogs</code></p></li><li><p>进入该文件夹,鼠标右键,打开<code>git bash</code></p></li><li><p>安装<code>hexo</code>,在bash中输入<code>npm install -g hexo</code></p></li><li><p><code>bash</code>中进入<code>bolgs</code>文件夹下,<code>cd E:/blogs</code></p></li><li><p>输入<code>hexo init</code></p></li><li><p>现在已经搭建起来一个本地博客了 , 输入以下命令验证</p><p><code>$ hexo g</code> -生成</p><p><code>$ hexo s</code> -启动服务本地预览 </p><p>然后到浏览器输入localhost:4000进行预览(ctrl + c 停止本地预览)</p><p>​</p><p>​</p></li></ol><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>   目前使用的是<code>hexo</code>默认的主题,其实也很好看的,如果你不喜欢,可以更换主题,这里推荐<code>jacman</code>,</p><ol><li><p>下载主题</p><p>将主题下载到<code>blogs/theme</code>目录下在<code>bash</code>中执行<code>git clone https://github.com/wuchong/jacman.git E:/blogs/themes/jacman</code></p></li><li><p>更换主题</p><p>修改<code>blogs</code>目录下的config.yml配置文件中的theme属性，将其设置为jacman</p></li><li><p>启用主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean --因为主题换了 你需要clean以下老主题生成的缓存</span><br><span class="line">cd themes/jacman</span><br><span class="line">git pull</span><br><span class="line">hexo g   --生成</span><br><span class="line">hexo s   --启动本地预览</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h1 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h1><p>经过上面的步骤之后,就可以开始写博客并上传到github上了,步骤如下:</p><ol><li>进入到<code>Blogs</code>文件加下,运行<code>hexo n &quot;博客文件名&quot;</code></li><li>找到<code>Blogs/source/_posts/xxx</code>其中xxx是第一步新键的博客文件名,默认为<code>.md文件</code></li><li>打开该文件,书写博客,保存</li><li><code>执行 ./ok.sh</code>,中间可能会遇到让你输入用户名和密码的情况,输入即可.（关于ok.sh，请看下面的快捷部署）</li></ol><h1 id="快捷部署"><a href="#快捷部署" class="headerlink" title="快捷部署"></a>快捷部署</h1><ol><li><p>进入 Hexo 的根目录 接着操作以下命令</p><p><code>$ cd Hexo</code></p><p>注意 1：现在我们需要clone我们自己的GitHub仓库了</p><p>注意 3：切记下面是<strong>你自己的仓库名</strong> , 把名字都改过来 , 下面我用的是我的仓库名字</p><p><code>$ git clone https://github.com/zachaxy/zachaxy.github.io.git .deploy/zachaxy.github.io</code></p><p>翻译下这条命令的意思</p><p>将我们之前创建的GitHub 仓库克隆到本地 , 命令会新建一个目录叫做.deploy用于存放克隆的代码。</p><p>然后会在.deploy文件夹下生成一个 <strong>你的名字.github.io</strong> 的文件夹用于存放文件</p></li><li><p>接着在 Hexo <strong>根目录</strong>下创建一个 .txt 文件 , 把下面的命令复制进去</p></li><li><p>注意 ：<strong>你的GitHub名字</strong>是什么就<strong>把你的名字全部改到下面</strong> , 细心点。稍微解释一下下面的命令，在部署文章之前，我们肯定已经使用 <code>hexo n &quot;xxx&quot;</code>产生了一个xxx.md的文件，并书写完博客了，那么接下来这个第一行就是生成博客对应的html文件等，这些文件都放在 <code>hexo/public</code> 路径下；第二条指令是将 <code>public</code> 下的所有文件 拷贝到 本地的<code>.deploy/zachaxy.github.io</code> 路径下（相同文件会覆盖）；第三条指令，进入<code>.deploy/zachaxy.github.io</code>路径；接下来第四条到第六条指令，就是普通的提交命令，不在解释。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">cp -R public/* .deploy/zachaxy.github.io</span><br><span class="line">cd .deploy/zachaxy.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m  &quot;update&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ol start="4"><li>将这个 <strong>.txt 文件的后缀改成 .sh</strong> , 它就变成了脚本文件 , 我们就将文件改成 <strong>ok.sh</strong> 。</li><li>从此以后需要部署本地博客到 GitHub , 在 hexo 根目录下，直接<code>./ok.sh</code> , 会弹出提示 , 需要输入 GitHub 的用户名跟密码 , 按提示输入自己的用户名和密码即可</li></ol><h1 id="jacman配置"><a href="#jacman配置" class="headerlink" title="jacman配置"></a>jacman配置</h1><p><a href="https://smartbeng.github.io/2017/03/26/blogFinish/" target="_blank" rel="noopener">最适合新手的 GitHub + Hexo 「大话」博客搭建教程</a></p><p><a href="http://whatbeg.com/2017/04/13/hexosomeopt.html" target="_blank" rel="noopener">Hexo新的一些优化</a></p><p> <a href="http://kubicode.me/2016/03/18/Hexo/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/" target="_blank" rel="noopener">[小技巧]让Hexo在使用Mathjax时支持多行公式</a></p><p><a href="http://kubicode.me/2016/03/16/Hexo/Fix-Hexo-Bug-In-Mathjax/" target="_blank" rel="noopener">修复Hexo写Mathjax公式多个下标失效的问题</a></p><p><a href="http://www.jianshu.com/p/6c1196f12302" target="_blank" rel="noopener">用 Hexo 搭建个人博客-02：进阶试验</a></p><p> <a href="http://whatbeg.com/2016/09/17/hexo-migrate.html" target="_blank" rel="noopener">Hexo部署环境迁移–多台电脑搭建Hexo环境</a></p><p> <a href="http://lowrank.science/Hexo-Migration/" target="_blank" rel="noopener">多机更新 Hexo 博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2017/03/30/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2017/03/30/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><blockquote><p>有n个物品，每个物品的重量为weight[i]，每个物品的价值为value[i]。现在有一个背包，它所能容纳的重量为total，问：当你面对这么多有价值的物品时，你的背包所能带走的最大价值是多少？</p></blockquote><ul><li>n:物品数量</li><li>weight[] :每个物品的重量</li><li>value[]: 每个物品的价值</li><li>total:背包的最大承重</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>使用一个<code>dp[n + 1][weight + 1]</code>数组,其中<code>dp[i][j]</code>表示如果背包重量是<code>j</code>的情况下,使用前<code>i</code>个物品的最优解,</p><p>那么<code>dp[i][j]</code>的值如何确定呢?</p><p>首先:确定当前最大的承重是<code>j</code>,那么用不用物品<code>i</code>呢?</p><p>如果使用,<code>dp[i][j] = dp[i-1][j-w[i]]+v[i]</code></p><p>如果不使用<code>i</code>,那么<code>dp[i][j] = dp[i-1][j]</code></p><p>所以<code>dp[i][j]</code>的值就是上述两者的最大值;</p><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  Scanner in = <span class="keyword">new</span> Scanner(System.in);  </span><br><span class="line">  <span class="keyword">while</span> (in.hasNext()) &#123;  </span><br><span class="line">    <span class="keyword">int</span> n = in.nextInt();  <span class="comment">//背包数量;</span></span><br><span class="line">    <span class="keyword">int</span> weight = in.nextInt();  <span class="comment">//重量;</span></span><br><span class="line">    <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//value;</span></span><br><span class="line">    <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//weight;</span></span><br><span class="line"><span class="comment">//我们这里都是用了一个+1的操作,就是说不从0开始计算了,而是从1开始计算,这样更容易理解吧;</span></span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][weight + <span class="number">1</span>];  <span class="comment">//结果集;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;  </span><br><span class="line">      w[i] = in.nextInt();  </span><br><span class="line">      v[i] = in.nextInt();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;  </span><br><span class="line">      res[i][<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化第一行;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=weight; j++) &#123;  </span><br><span class="line">      res[<span class="number">0</span>][j] = <span class="number">0</span>;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//开始规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;  </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= weight; j++) &#123;  <span class="comment">//这里k代表的是当前背包的重量;</span></span><br><span class="line">        res[i][j] = res[i - <span class="number">1</span>][j];    <span class="comment">//不用当前j</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= w[i]) &#123;  <span class="comment">//当前包的重量小于j,考虑很周到,如果当前包重量过大,也是不行的...</span></span><br><span class="line">          <span class="keyword">if</span> (res[i-<span class="number">1</span>][j - w[i]] + v[i] &gt; res[i-<span class="number">1</span>][j])  <span class="comment">//用当前i比不用更大,那么就用上;</span></span><br><span class="line">          &#123;  </span><br><span class="line">            res[i][j] = res[i-<span class="number">1</span>][j - w[i]] + v[i];    <span class="comment">//使用当前i;</span></span><br><span class="line">          &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(res[n][weight]);  </span><br><span class="line">  &#125;  </span><br><span class="line">  in.close();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="压缩空间"><a href="#压缩空间" class="headerlink" title="压缩空间"></a>压缩空间</h2><p>上面的实现方法用了一个二维数组,其实完全可以用一个一维数组来代替;</p><blockquote><p>这里有一个要注意的地方:编程思路和上面是一样的,也是两层循环,只不过现在从二维变成了一维,可是我们需要<code>dp[i][j] = dp[i-1][j-w[i]]+v[i]</code>的情况,如果内层循环也是从1开始计数的话,前面的值就被覆盖了,后面的值依赖前面的值,所以内层循环从右到左开始循环;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  Scanner in = <span class="keyword">new</span> Scanner(System.in);  </span><br><span class="line">  <span class="keyword">while</span> (in.hasNext()) &#123;  </span><br><span class="line">    <span class="keyword">int</span> n = in.nextInt();  <span class="comment">//背包数量</span></span><br><span class="line">    <span class="keyword">int</span> weight = in.nextInt();  <span class="comment">//背包承重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//values;</span></span><br><span class="line">    <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];  <span class="comment">//weights;</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[weight + <span class="number">1</span>];  <span class="comment">//结果集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;  </span><br><span class="line">      w[i] = in.nextInt();  </span><br><span class="line">      v[i] = in.nextInt();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;  </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = weight; k&gt;=<span class="number">0</span>; k--) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (w[i] &lt;= k) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (v[i] + res[k - w[i]] &gt; res[k])  </span><br><span class="line">          &#123;  </span><br><span class="line">            res[k] = v[i] + res[k - w[i]];  </span><br><span class="line">          &#125;  </span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(res[weight]);  </span><br><span class="line">  &#125;  </span><br><span class="line">  in.close();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个更简洁的写法"><a href="#一个更简洁的写法" class="headerlink" title="一个更简洁的写法"></a>一个更简洁的写法</h2><p>  注意传入进来的v和w是从0开始的,不是从1开始的了;上面使用的从1开始只是为了方便的说明问题,现在v和w都是从0开始的,只是res结果集还是使用的<code>total+1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[] weights, <span class="keyword">int</span> maxWeight)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[maxWeight + <span class="number">1</span>];  <span class="comment">//动态规划数组;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;  <span class="comment">//遍历到第i个物品;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = maxWeight; j &gt;= weights[i]; j--) &#123;  <span class="comment">//内层循环倒着来;注意人家的终止条件啊;</span></span><br><span class="line">      <span class="keyword">int</span> takeValue = values[i] + res[j - weights[i]];  <span class="comment">//使用当前i</span></span><br><span class="line">      <span class="keyword">if</span> (takeValue &gt; res[j]) &#123;  <span class="comment">//使用当前i的时候如果比不使用的时候大,那么将res[j]的位置替换成使用的情况;</span></span><br><span class="line">        res[j] = takeValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res[ans.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包的一个变形问题"><a href="#01背包的一个变形问题" class="headerlink" title="01背包的一个变形问题"></a>01背包的一个变形问题</h2><blockquote><p>给定一个物品数组,每个物品都有一个价值,每个物品数量为1,再得定一个整数aim代表期望的价值,求组成aim的最小物品数量,如果组不成,那么返回-1;</p></blockquote><p><strong>使用二维数组的做法</strong></p><p><code>dp[i][j]</code>代表的是<code>aim=j</code>的情况下,使用前面<code>i</code>种钱币的最优解;那么在接下来的规划中如何做呢?</p><p>首先我们是把数组中的每个元素都初始化为<code>Integer.MAX_VALUE</code>了,那么<code>j</code>的情况下,考虑能不能使用<code>i</code>,如果<code>dp[i-1][j-v[i]]</code>不是最大值,那么就可以用上<code>j</code>,否则赋值为<code>dp[i-1][j]</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> n = arr.length;</span><br><span class="line">  <span class="keyword">int</span> max = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][aim + <span class="number">1</span>]; <span class="comment">//创建dp数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//和之前一样,初始化数组的第一行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = max;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只给恰好等于的元素置为1;</span></span><br><span class="line">  <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt;= aim) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> leftup = <span class="number">0</span>; <span class="comment">// 左上角某个位置的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">//最外层从上到下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123; <span class="comment">//最内层从左到右遍历</span></span><br><span class="line">      leftup = max;</span><br><span class="line">      <span class="keyword">if</span> (j - arr[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - arr[i]] != max) &#123; <span class="comment">//现在是上一行的,有值才赋值=&gt;保证只使用一次;</span></span><br><span class="line">        leftup = dp[i - <span class="number">1</span>][j - arr[i]] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i][j] = Math.min(leftup, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n - <span class="number">1</span>][aim] != max ? dp[n - <span class="number">1</span>][aim] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用一维数组的做法</strong></p><p>注意内层循环依然使用从右到左的方式;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f5</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> n = arr.length;</span><br><span class="line">  <span class="keyword">int</span> max = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[aim + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">    dp[j] = max;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt;= aim) &#123;</span><br><span class="line">    dp[arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> leftup = <span class="number">0</span>; <span class="comment">// 左上角某个位置的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = aim; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      leftup = max;</span><br><span class="line">      <span class="comment">// if (j - arr[i] &gt;= 0 &amp;&amp; dp[i][j - arr[i]] != max) //之前是只要 a[i][j-cur]上有值就赋值</span></span><br><span class="line">      <span class="keyword">if</span> (j - arr[i] &gt;= <span class="number">0</span> &amp;&amp; dp[j - arr[i]] != max) &#123;</span><br><span class="line">        leftup = dp[j - arr[i]] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[j] = Math.min(leftup, dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[aim] != max ? dp[aim] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
